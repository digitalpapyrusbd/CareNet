Draft actjon.workflow for github by chatgpt.

GitHub Actions — CI / CD workflow (single-file)

Below is a ready-to-drop workflow you can put at .github/workflows/ci-cd.yml. It runs on PRs and pushes, performs lint/test/build for frontend & backend, runs integration tests against Postgres+Redis services, produces build artifacts, and deploys to staging automatically and production only when the job targets the production environment (which should be protected by GitHub environment reviewers / approvals).

Save the file and adjust secrets/env values (listed after the YAML).


---

# .github/workflows/ci-cd.yml
name: CI / CD Pipeline

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
  push:
    branches: [ main, staging ]
  workflow_dispatch:

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: '20'                # adjust as needed
  POSTGRES_DB: caregiver_dev
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  REDIS_PORT: 6379

jobs:
  # 1) Lint, unit tests, and build for frontend and backend (fast feedback)
  test-and-build:
    name: Lint → Unit Tests → Build
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U $POSTGRES_USER -d $POSTGRES_DB"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7
        ports: ['6379:6379']
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    strategy:
      matrix:
        workdir: [ 'frontend', 'backend' ]   # assumes repo has /frontend and /backend folders
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: |
            ${{ matrix.workdir }}/node_modules
            ~/.npm
          key: ${{ runner.os }}-node-${{ env.NODE_VERSION }}-${{ matrix.workdir }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.NODE_VERSION }}-${{ matrix.workdir }}-

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies (${{
          matrix.workdir }})
        working-directory: ${{ matrix.workdir }}
        run: npm ci

      - name: Run lint (${{
          matrix.workdir }})
        working-directory: ${{ matrix.workdir }}
        run: npm run lint --if-present

      - name: Run unit tests (${{
          matrix.workdir }})
        working-directory: ${{ matrix.workdir }}
        run: npm run test --if-present -- --runInBand

      - name: Build (${{
          matrix.workdir }})
        if: github.event_name != 'pull_request' || github.event_name == 'workflow_dispatch'
        working-directory: ${{ matrix.workdir }}
        run: npm run build --if-present

  # 2) Integration / E2E tests (single job to avoid DB collisions)
  integration-tests:
    name: Integration & E2E Tests
    runs-on: ubuntu-latest
    needs: test-and-build
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
        ports:
          - 5433:5432
        options: >-
          --health-cmd "pg_isready -U $POSTGRES_USER -d $POSTGRES_DB"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7
        ports: ['6380:6379']
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install root deps (if monorepo tooling)
        run: |
          if [ -f package-lock.json ]; then npm ci; fi

      - name: Start backend in test mode
        working-directory: backend
        run: |
          npm ci
          # ensure env points to test DB/Redis
          export DATABASE_URL="postgresql://${{ env.POSTGRES_USER }}:${{ env.POSTGRES_PASSWORD }}@localhost:5433/${{ env.POSTGRES_DB }}"
          export REDIS_URL="redis://localhost:6380"
          npm run migrate --if-present
          npm run start:test &

      - name: Run E2E tests (frontend / API)
        working-directory: frontend
        run: |
          npm ci
          # assume e2e script exists, e.g. playwright/cypress
          npm run e2e --if-present

      - name: Upload test logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-logs
          path: |
            backend/logs || frontend/test-results || ./logs || **/test-results

  # 3) Create build artifacts to reuse in Deploy jobs
  package-artifacts:
    name: Package build artifacts
    runs-on: ubuntu-latest
    needs: [test-and-build, integration-tests]
    if: always()
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Collect frontend build
        if: exists('frontend/.next') || success()
        run: |
          mkdir -p artifacts/frontend
          if [ -d frontend/.next ]; then cp -r frontend/.next artifacts/frontend/ || true; fi
          if [ -d frontend/public ]; then cp -r frontend/public artifacts/frontend/ || true; fi

      - name: Collect backend build
        run: |
          mkdir -p artifacts/backend
          if [ -d backend/dist ]; then cp -r backend/dist artifacts/backend/ || true; fi
          if [ -f backend/package.json ]; then cp backend/package.json artifacts/backend/ || true; fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: artifacts

  # 4) Deploy to staging automatically on push to staging branch
  deploy-staging:
    name: Deploy → Staging
    runs-on: ubuntu-latest
    needs: package-artifacts
    if: github.ref == 'refs/heads/staging' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: artifacts

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.1
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_PRIVATE_KEY }}

      - name: Rsync files to staging host
        env:
          SSH_USER: ${{ secrets.STAGING_SSH_USER }}
          SSH_HOST: ${{ secrets.STAGING_SSH_HOST }}
          DEPLOY_PATH: ${{ secrets.STAGING_DEPLOY_PATH }}
        run: |
          rsync -avz --delete artifacts/frontend/ $SSH_USER@$SSH_HOST:$DEPLOY_PATH/frontend/
          rsync -avz --delete artifacts/backend/ $SSH_USER@$SSH_HOST:$DEPLOY_PATH/backend/
          ssh $SSH_USER@$SSH_HOST "cd $DEPLOY_PATH && ./deploy-scripts/reload-services.sh staging"

      - name: Notify (optional)
        if: ${{ secrets.SLACK_WEBHOOK != '' }}
        uses: rtCamp/action-slack-notify@v2
        with:
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          message: "Deployed commit ${{ github.sha }} to staging."

  # 5) Deploy to production — gated by environment protection (requires human approval)
  deploy-prod:
    name: Deploy → Production
    runs-on: ubuntu-latest
    needs: package-artifacts
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: production       # Protect this environment in repo settings to require approvals
      url: https://caregiver.bd
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: artifacts

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.1
        with:
          ssh-private-key: ${{ secrets.PROD_SSH_PRIVATE_KEY }}

      - name: Rsync files to production host
        env:
          SSH_USER: ${{ secrets.PROD_SSH_USER }}
          SSH_HOST: ${{ secrets.PROD_SSH_HOST }}
          DEPLOY_PATH: ${{ secrets.PROD_DEPLOY_PATH }}
        run: |
          rsync -avz --delete artifacts/frontend/ $SSH_USER@$SSH_HOST:$DEPLOY_PATH/frontend/
          rsync -avz --delete artifacts/backend/ $SSH_USER@$SSH_HOST:$DEPLOY_PATH/backend/
          ssh $SSH_USER@$SSH_HOST "cd $DEPLOY_PATH && ./deploy-scripts/reload-services.sh production"

      - name: Post-deploy smoke checks
        run: |
          # simple health endpoint checks - customize URLs
          curl -fS https://caregiver.bd/health || (echo "Smoke check failed" && exit 1)

      - name: Notify Prod (optional)
        if: ${{ secrets.SLACK_WEBHOOK != '' }}
        uses: rtCamp/action-slack-notify@v2
        with:
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          message: "Deployed commit ${{ github.sha }} to production."


---

Things to configure (secrets & repo settings)

Add these secrets in your repository Settings → Secrets & variables → Actions:

STAGING_SSH_PRIVATE_KEY — SSH private key for staging user

STAGING_SSH_USER, STAGING_SSH_HOST, STAGING_DEPLOY_PATH

PROD_SSH_PRIVATE_KEY, PROD_SSH_USER, PROD_SSH_HOST, PROD_DEPLOY_PATH

SLACK_WEBHOOK (optional)

Any DB/API credentials used by your tests (but prefer using ephemeral/test credentials)


Repository settings:

Protect main branch and require PR review & passing checks before merge.

Configure Environment production and require reviewers/approvals — that makes the production deploy job wait for human approval (GitHub enforces this).

Add required status checks (lint/tests) to branch protection rules.


Notes and recommendations (short)

The job assumes a monorepo with frontend/ and backend/ folders. Adjust matrix.workdir or job steps to match your repo layout.

For React Native CI you’ll need separate iOS/Android pipelines or use Expo build services; keep mobile CI separate from web CI for clarity.

For PHI/health-data flows: do not send secrets or real PHI to third-party actions unless you trust them and review their code. Prefer self-hosted runners for sensitive deployments.

Use GitHub environments to enforce manual approvals for production deploys — that prevents accidental prod pushes.

Add security scans: Snyk, Dependabot, or Trivy container scans as extra jobs if you want vulnerability gating.



---

If you want, I’ll:

adapt this to a pnpm + TurboRepo monorepo layout, or

add a Docker-based build + deploy to Kubernetes job (including image build, push to registry, and Helm upgrade).


Which one next?