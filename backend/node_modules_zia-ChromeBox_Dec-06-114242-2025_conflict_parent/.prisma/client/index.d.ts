
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model assignments
 * 
 */
export type assignments = $Result.DefaultSelection<Prisma.$assignmentsPayload>
/**
 * Model audit_logs
 * 
 */
export type audit_logs = $Result.DefaultSelection<Prisma.$audit_logsPayload>
/**
 * Model care_logs
 * 
 */
export type care_logs = $Result.DefaultSelection<Prisma.$care_logsPayload>
/**
 * Model caregivers
 * 
 */
export type caregivers = $Result.DefaultSelection<Prisma.$caregiversPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model disputes
 * 
 */
export type disputes = $Result.DefaultSelection<Prisma.$disputesPayload>
/**
 * Model escrows
 * 
 */
export type escrows = $Result.DefaultSelection<Prisma.$escrowsPayload>
/**
 * Model escrow_records
 * 
 */
export type escrow_records = $Result.DefaultSelection<Prisma.$escrow_recordsPayload>
/**
 * Model escrow_ledger
 * 
 */
export type escrow_ledger = $Result.DefaultSelection<Prisma.$escrow_ledgerPayload>
/**
 * Model provider_transactions
 * 
 */
export type provider_transactions = $Result.DefaultSelection<Prisma.$provider_transactionsPayload>
/**
 * Model transaction_logs
 * 
 */
export type transaction_logs = $Result.DefaultSelection<Prisma.$transaction_logsPayload>
/**
 * Model feedbacks
 * 
 */
export type feedbacks = $Result.DefaultSelection<Prisma.$feedbacksPayload>
/**
 * Model health_records
 * 
 */
export type health_records = $Result.DefaultSelection<Prisma.$health_recordsPayload>
/**
 * Model job_applications
 * 
 */
export type job_applications = $Result.DefaultSelection<Prisma.$job_applicationsPayload>
/**
 * Model jobs
 * 
 */
export type jobs = $Result.DefaultSelection<Prisma.$jobsPayload>
/**
 * Model marketplace_jobs
 * 
 */
export type marketplace_jobs = $Result.DefaultSelection<Prisma.$marketplace_jobsPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model packages
 * 
 */
export type packages = $Result.DefaultSelection<Prisma.$packagesPayload>
/**
 * Model patients
 * 
 */
export type patients = $Result.DefaultSelection<Prisma.$patientsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model scheduled_tasks
 * 
 */
export type scheduled_tasks = $Result.DefaultSelection<Prisma.$scheduled_tasksPayload>
/**
 * Model service_zones
 * 
 */
export type service_zones = $Result.DefaultSelection<Prisma.$service_zonesPayload>
/**
 * Model user_devices
 * 
 */
export type user_devices = $Result.DefaultSelection<Prisma.$user_devicesPayload>
/**
 * Model verification_codes
 * 
 */
export type verification_codes = $Result.DefaultSelection<Prisma.$verification_codesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  MODERATOR: 'MODERATOR',
  COMPANY: 'COMPANY',
  CAREGIVER: 'CAREGIVER',
  GUARDIAN: 'GUARDIAN',
  PATIENT: 'PATIENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const KYCStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const PaymentMethod: {
  BKASH: 'BKASH',
  NAGAD: 'NAGAD',
  CARD: 'CARD',
  BANK_TRANSFER: 'BANK_TRANSFER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const JobStatus: {
  PENDING_ASSIGNMENT: 'PENDING_ASSIGNMENT',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  DISPUTED: 'DISPUTED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const AssignmentRole: {
  PRIMARY: 'PRIMARY',
  BACKUP: 'BACKUP'
};

export type AssignmentRole = (typeof AssignmentRole)[keyof typeof AssignmentRole]


export const AssignmentStatus: {
  ASSIGNED: 'ASSIGNED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  REPLACED: 'REPLACED'
};

export type AssignmentStatus = (typeof AssignmentStatus)[keyof typeof AssignmentStatus]


export const CareLogType: {
  CHECK_IN: 'CHECK_IN',
  VITALS: 'VITALS',
  MEDICATION: 'MEDICATION',
  MEAL: 'MEAL',
  ACTIVITY: 'ACTIVITY',
  INCIDENT: 'INCIDENT',
  CHECK_OUT: 'CHECK_OUT'
};

export type CareLogType = (typeof CareLogType)[keyof typeof CareLogType]


export const FeedbackType: {
  CAREGIVER: 'CAREGIVER',
  COMPANY: 'COMPANY',
  GUARDIAN: 'GUARDIAN'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const NotificationType: {
  SMS: 'SMS',
  EMAIL: 'EMAIL',
  PUSH: 'PUSH',
  IN_APP: 'IN_APP'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED',
  READ: 'READ'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const DisputeStatus: {
  OPEN: 'OPEN',
  UNDER_REVIEW: 'UNDER_REVIEW',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type DisputeStatus = (typeof DisputeStatus)[keyof typeof DisputeStatus]


export const DisputeType: {
  PAYMENT: 'PAYMENT',
  QUALITY: 'QUALITY',
  SAFETY: 'SAFETY',
  NO_SHOW: 'NO_SHOW',
  OTHER: 'OTHER'
};

export type DisputeType = (typeof DisputeType)[keyof typeof DisputeType]


export const BackgroundCheckStatus: {
  PENDING: 'PENDING',
  CLEARED: 'CLEARED',
  FLAGGED: 'FLAGGED'
};

export type BackgroundCheckStatus = (typeof BackgroundCheckStatus)[keyof typeof BackgroundCheckStatus]


export const SubscriptionTier: {
  STARTER: 'STARTER',
  GROWTH: 'GROWTH',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const PackageCategory: {
  ELDERLY_CARE: 'ELDERLY_CARE',
  POST_SURGERY: 'POST_SURGERY',
  CHRONIC_ILLNESS: 'CHRONIC_ILLNESS',
  COMPANION: 'COMPANION',
  NURSING: 'NURSING'
};

export type PackageCategory = (typeof PackageCategory)[keyof typeof PackageCategory]


export const MobilityLevel: {
  INDEPENDENT: 'INDEPENDENT',
  ASSISTED: 'ASSISTED',
  WHEELCHAIR: 'WHEELCHAIR',
  BEDRIDDEN: 'BEDRIDDEN'
};

export type MobilityLevel = (typeof MobilityLevel)[keyof typeof MobilityLevel]


export const CognitiveStatus: {
  NORMAL: 'NORMAL',
  MILD_IMPAIRMENT: 'MILD_IMPAIRMENT',
  MODERATE: 'MODERATE',
  SEVERE: 'SEVERE'
};

export type CognitiveStatus = (typeof CognitiveStatus)[keyof typeof CognitiveStatus]


export const HealthRecordType: {
  PRESCRIPTION: 'PRESCRIPTION',
  LAB_REPORT: 'LAB_REPORT',
  DIAGNOSIS: 'DIAGNOSIS',
  MEDICATION_SCHEDULE: 'MEDICATION_SCHEDULE',
  NOTE: 'NOTE'
};

export type HealthRecordType = (typeof HealthRecordType)[keyof typeof HealthRecordType]


export const PayoutMethod: {
  BANK_TRANSFER: 'BANK_TRANSFER',
  BKASH: 'BKASH',
  NAGAD: 'NAGAD'
};

export type PayoutMethod = (typeof PayoutMethod)[keyof typeof PayoutMethod]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type AssignmentRole = $Enums.AssignmentRole

export const AssignmentRole: typeof $Enums.AssignmentRole

export type AssignmentStatus = $Enums.AssignmentStatus

export const AssignmentStatus: typeof $Enums.AssignmentStatus

export type CareLogType = $Enums.CareLogType

export const CareLogType: typeof $Enums.CareLogType

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type DisputeStatus = $Enums.DisputeStatus

export const DisputeStatus: typeof $Enums.DisputeStatus

export type DisputeType = $Enums.DisputeType

export const DisputeType: typeof $Enums.DisputeType

export type BackgroundCheckStatus = $Enums.BackgroundCheckStatus

export const BackgroundCheckStatus: typeof $Enums.BackgroundCheckStatus

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type PackageCategory = $Enums.PackageCategory

export const PackageCategory: typeof $Enums.PackageCategory

export type MobilityLevel = $Enums.MobilityLevel

export const MobilityLevel: typeof $Enums.MobilityLevel

export type CognitiveStatus = $Enums.CognitiveStatus

export const CognitiveStatus: typeof $Enums.CognitiveStatus

export type HealthRecordType = $Enums.HealthRecordType

export const HealthRecordType: typeof $Enums.HealthRecordType

export type PayoutMethod = $Enums.PayoutMethod

export const PayoutMethod: typeof $Enums.PayoutMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assignments
 * const assignments = await prisma.assignments.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assignments
   * const assignments = await prisma.assignments.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.assignments`: Exposes CRUD operations for the **assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignments.findMany()
    * ```
    */
  get assignments(): Prisma.assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audit_logs`: Exposes CRUD operations for the **audit_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audit_logs
    * const audit_logs = await prisma.audit_logs.findMany()
    * ```
    */
  get audit_logs(): Prisma.audit_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.care_logs`: Exposes CRUD operations for the **care_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Care_logs
    * const care_logs = await prisma.care_logs.findMany()
    * ```
    */
  get care_logs(): Prisma.care_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caregivers`: Exposes CRUD operations for the **caregivers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caregivers
    * const caregivers = await prisma.caregivers.findMany()
    * ```
    */
  get caregivers(): Prisma.caregiversDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disputes`: Exposes CRUD operations for the **disputes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disputes
    * const disputes = await prisma.disputes.findMany()
    * ```
    */
  get disputes(): Prisma.disputesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.escrows`: Exposes CRUD operations for the **escrows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escrows
    * const escrows = await prisma.escrows.findMany()
    * ```
    */
  get escrows(): Prisma.escrowsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.escrow_records`: Exposes CRUD operations for the **escrow_records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escrow_records
    * const escrow_records = await prisma.escrow_records.findMany()
    * ```
    */
  get escrow_records(): Prisma.escrow_recordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.escrow_ledger`: Exposes CRUD operations for the **escrow_ledger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escrow_ledgers
    * const escrow_ledgers = await prisma.escrow_ledger.findMany()
    * ```
    */
  get escrow_ledger(): Prisma.escrow_ledgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_transactions`: Exposes CRUD operations for the **provider_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_transactions
    * const provider_transactions = await prisma.provider_transactions.findMany()
    * ```
    */
  get provider_transactions(): Prisma.provider_transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction_logs`: Exposes CRUD operations for the **transaction_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaction_logs
    * const transaction_logs = await prisma.transaction_logs.findMany()
    * ```
    */
  get transaction_logs(): Prisma.transaction_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedbacks`: Exposes CRUD operations for the **feedbacks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedbacks.findMany()
    * ```
    */
  get feedbacks(): Prisma.feedbacksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.health_records`: Exposes CRUD operations for the **health_records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Health_records
    * const health_records = await prisma.health_records.findMany()
    * ```
    */
  get health_records(): Prisma.health_recordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_applications`: Exposes CRUD operations for the **job_applications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_applications
    * const job_applications = await prisma.job_applications.findMany()
    * ```
    */
  get job_applications(): Prisma.job_applicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketplace_jobs`: Exposes CRUD operations for the **marketplace_jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marketplace_jobs
    * const marketplace_jobs = await prisma.marketplace_jobs.findMany()
    * ```
    */
  get marketplace_jobs(): Prisma.marketplace_jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packages`: Exposes CRUD operations for the **packages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.packages.findMany()
    * ```
    */
  get packages(): Prisma.packagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patients`: Exposes CRUD operations for the **patients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patients.findMany()
    * ```
    */
  get patients(): Prisma.patientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduled_tasks`: Exposes CRUD operations for the **scheduled_tasks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scheduled_tasks
    * const scheduled_tasks = await prisma.scheduled_tasks.findMany()
    * ```
    */
  get scheduled_tasks(): Prisma.scheduled_tasksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service_zones`: Exposes CRUD operations for the **service_zones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_zones
    * const service_zones = await prisma.service_zones.findMany()
    * ```
    */
  get service_zones(): Prisma.service_zonesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_devices`: Exposes CRUD operations for the **user_devices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_devices
    * const user_devices = await prisma.user_devices.findMany()
    * ```
    */
  get user_devices(): Prisma.user_devicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification_codes`: Exposes CRUD operations for the **verification_codes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verification_codes
    * const verification_codes = await prisma.verification_codes.findMany()
    * ```
    */
  get verification_codes(): Prisma.verification_codesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    assignments: 'assignments',
    audit_logs: 'audit_logs',
    care_logs: 'care_logs',
    caregivers: 'caregivers',
    companies: 'companies',
    disputes: 'disputes',
    escrows: 'escrows',
    escrow_records: 'escrow_records',
    escrow_ledger: 'escrow_ledger',
    provider_transactions: 'provider_transactions',
    transaction_logs: 'transaction_logs',
    feedbacks: 'feedbacks',
    health_records: 'health_records',
    job_applications: 'job_applications',
    jobs: 'jobs',
    marketplace_jobs: 'marketplace_jobs',
    notifications: 'notifications',
    packages: 'packages',
    patients: 'patients',
    payments: 'payments',
    scheduled_tasks: 'scheduled_tasks',
    service_zones: 'service_zones',
    user_devices: 'user_devices',
    verification_codes: 'verification_codes',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "assignments" | "audit_logs" | "care_logs" | "caregivers" | "companies" | "disputes" | "escrows" | "escrow_records" | "escrow_ledger" | "provider_transactions" | "transaction_logs" | "feedbacks" | "health_records" | "job_applications" | "jobs" | "marketplace_jobs" | "notifications" | "packages" | "patients" | "payments" | "scheduled_tasks" | "service_zones" | "user_devices" | "verification_codes" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      assignments: {
        payload: Prisma.$assignmentsPayload<ExtArgs>
        fields: Prisma.assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          findFirst: {
            args: Prisma.assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          findMany: {
            args: Prisma.assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>[]
          }
          create: {
            args: Prisma.assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          createMany: {
            args: Prisma.assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>[]
          }
          delete: {
            args: Prisma.assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          update: {
            args: Prisma.assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          aggregate: {
            args: Prisma.AssignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignments>
          }
          groupBy: {
            args: Prisma.assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentsCountAggregateOutputType> | number
          }
        }
      }
      audit_logs: {
        payload: Prisma.$audit_logsPayload<ExtArgs>
        fields: Prisma.audit_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.audit_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.audit_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findFirst: {
            args: Prisma.audit_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.audit_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          findMany: {
            args: Prisma.audit_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          create: {
            args: Prisma.audit_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          createMany: {
            args: Prisma.audit_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.audit_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          delete: {
            args: Prisma.audit_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          update: {
            args: Prisma.audit_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          deleteMany: {
            args: Prisma.audit_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.audit_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.audit_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>[]
          }
          upsert: {
            args: Prisma.audit_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$audit_logsPayload>
          }
          aggregate: {
            args: Prisma.Audit_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudit_logs>
          }
          groupBy: {
            args: Prisma.audit_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.audit_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Audit_logsCountAggregateOutputType> | number
          }
        }
      }
      care_logs: {
        payload: Prisma.$care_logsPayload<ExtArgs>
        fields: Prisma.care_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.care_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.care_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>
          }
          findFirst: {
            args: Prisma.care_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.care_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>
          }
          findMany: {
            args: Prisma.care_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>[]
          }
          create: {
            args: Prisma.care_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>
          }
          createMany: {
            args: Prisma.care_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.care_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>[]
          }
          delete: {
            args: Prisma.care_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>
          }
          update: {
            args: Prisma.care_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>
          }
          deleteMany: {
            args: Prisma.care_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.care_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.care_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>[]
          }
          upsert: {
            args: Prisma.care_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$care_logsPayload>
          }
          aggregate: {
            args: Prisma.Care_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCare_logs>
          }
          groupBy: {
            args: Prisma.care_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Care_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.care_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Care_logsCountAggregateOutputType> | number
          }
        }
      }
      caregivers: {
        payload: Prisma.$caregiversPayload<ExtArgs>
        fields: Prisma.caregiversFieldRefs
        operations: {
          findUnique: {
            args: Prisma.caregiversFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.caregiversFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>
          }
          findFirst: {
            args: Prisma.caregiversFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.caregiversFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>
          }
          findMany: {
            args: Prisma.caregiversFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>[]
          }
          create: {
            args: Prisma.caregiversCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>
          }
          createMany: {
            args: Prisma.caregiversCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.caregiversCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>[]
          }
          delete: {
            args: Prisma.caregiversDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>
          }
          update: {
            args: Prisma.caregiversUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>
          }
          deleteMany: {
            args: Prisma.caregiversDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.caregiversUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.caregiversUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>[]
          }
          upsert: {
            args: Prisma.caregiversUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$caregiversPayload>
          }
          aggregate: {
            args: Prisma.CaregiversAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaregivers>
          }
          groupBy: {
            args: Prisma.caregiversGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaregiversGroupByOutputType>[]
          }
          count: {
            args: Prisma.caregiversCountArgs<ExtArgs>
            result: $Utils.Optional<CaregiversCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      disputes: {
        payload: Prisma.$disputesPayload<ExtArgs>
        fields: Prisma.disputesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.disputesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.disputesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>
          }
          findFirst: {
            args: Prisma.disputesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.disputesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>
          }
          findMany: {
            args: Prisma.disputesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>[]
          }
          create: {
            args: Prisma.disputesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>
          }
          createMany: {
            args: Prisma.disputesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.disputesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>[]
          }
          delete: {
            args: Prisma.disputesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>
          }
          update: {
            args: Prisma.disputesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>
          }
          deleteMany: {
            args: Prisma.disputesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.disputesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.disputesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>[]
          }
          upsert: {
            args: Prisma.disputesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disputesPayload>
          }
          aggregate: {
            args: Prisma.DisputesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisputes>
          }
          groupBy: {
            args: Prisma.disputesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputesGroupByOutputType>[]
          }
          count: {
            args: Prisma.disputesCountArgs<ExtArgs>
            result: $Utils.Optional<DisputesCountAggregateOutputType> | number
          }
        }
      }
      escrows: {
        payload: Prisma.$escrowsPayload<ExtArgs>
        fields: Prisma.escrowsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.escrowsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.escrowsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>
          }
          findFirst: {
            args: Prisma.escrowsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.escrowsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>
          }
          findMany: {
            args: Prisma.escrowsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>[]
          }
          create: {
            args: Prisma.escrowsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>
          }
          createMany: {
            args: Prisma.escrowsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.escrowsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>[]
          }
          delete: {
            args: Prisma.escrowsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>
          }
          update: {
            args: Prisma.escrowsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>
          }
          deleteMany: {
            args: Prisma.escrowsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.escrowsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.escrowsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>[]
          }
          upsert: {
            args: Prisma.escrowsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrowsPayload>
          }
          aggregate: {
            args: Prisma.EscrowsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrows>
          }
          groupBy: {
            args: Prisma.escrowsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscrowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.escrowsCountArgs<ExtArgs>
            result: $Utils.Optional<EscrowsCountAggregateOutputType> | number
          }
        }
      }
      escrow_records: {
        payload: Prisma.$escrow_recordsPayload<ExtArgs>
        fields: Prisma.escrow_recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.escrow_recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.escrow_recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>
          }
          findFirst: {
            args: Prisma.escrow_recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.escrow_recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>
          }
          findMany: {
            args: Prisma.escrow_recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>[]
          }
          create: {
            args: Prisma.escrow_recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>
          }
          createMany: {
            args: Prisma.escrow_recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.escrow_recordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>[]
          }
          delete: {
            args: Prisma.escrow_recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>
          }
          update: {
            args: Prisma.escrow_recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>
          }
          deleteMany: {
            args: Prisma.escrow_recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.escrow_recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.escrow_recordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>[]
          }
          upsert: {
            args: Prisma.escrow_recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_recordsPayload>
          }
          aggregate: {
            args: Prisma.Escrow_recordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrow_records>
          }
          groupBy: {
            args: Prisma.escrow_recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Escrow_recordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.escrow_recordsCountArgs<ExtArgs>
            result: $Utils.Optional<Escrow_recordsCountAggregateOutputType> | number
          }
        }
      }
      escrow_ledger: {
        payload: Prisma.$escrow_ledgerPayload<ExtArgs>
        fields: Prisma.escrow_ledgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.escrow_ledgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.escrow_ledgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>
          }
          findFirst: {
            args: Prisma.escrow_ledgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.escrow_ledgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>
          }
          findMany: {
            args: Prisma.escrow_ledgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>[]
          }
          create: {
            args: Prisma.escrow_ledgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>
          }
          createMany: {
            args: Prisma.escrow_ledgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.escrow_ledgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>[]
          }
          delete: {
            args: Prisma.escrow_ledgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>
          }
          update: {
            args: Prisma.escrow_ledgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>
          }
          deleteMany: {
            args: Prisma.escrow_ledgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.escrow_ledgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.escrow_ledgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>[]
          }
          upsert: {
            args: Prisma.escrow_ledgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escrow_ledgerPayload>
          }
          aggregate: {
            args: Prisma.Escrow_ledgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscrow_ledger>
          }
          groupBy: {
            args: Prisma.escrow_ledgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Escrow_ledgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.escrow_ledgerCountArgs<ExtArgs>
            result: $Utils.Optional<Escrow_ledgerCountAggregateOutputType> | number
          }
        }
      }
      provider_transactions: {
        payload: Prisma.$provider_transactionsPayload<ExtArgs>
        fields: Prisma.provider_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provider_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provider_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>
          }
          findFirst: {
            args: Prisma.provider_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provider_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>
          }
          findMany: {
            args: Prisma.provider_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>[]
          }
          create: {
            args: Prisma.provider_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>
          }
          createMany: {
            args: Prisma.provider_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.provider_transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>[]
          }
          delete: {
            args: Prisma.provider_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>
          }
          update: {
            args: Prisma.provider_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.provider_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provider_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.provider_transactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>[]
          }
          upsert: {
            args: Prisma.provider_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Provider_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider_transactions>
          }
          groupBy: {
            args: Prisma.provider_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Provider_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.provider_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Provider_transactionsCountAggregateOutputType> | number
          }
        }
      }
      transaction_logs: {
        payload: Prisma.$transaction_logsPayload<ExtArgs>
        fields: Prisma.transaction_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaction_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaction_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>
          }
          findFirst: {
            args: Prisma.transaction_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaction_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>
          }
          findMany: {
            args: Prisma.transaction_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>[]
          }
          create: {
            args: Prisma.transaction_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>
          }
          createMany: {
            args: Prisma.transaction_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transaction_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>[]
          }
          delete: {
            args: Prisma.transaction_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>
          }
          update: {
            args: Prisma.transaction_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>
          }
          deleteMany: {
            args: Prisma.transaction_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaction_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transaction_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>[]
          }
          upsert: {
            args: Prisma.transaction_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaction_logsPayload>
          }
          aggregate: {
            args: Prisma.Transaction_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction_logs>
          }
          groupBy: {
            args: Prisma.transaction_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Transaction_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaction_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Transaction_logsCountAggregateOutputType> | number
          }
        }
      }
      feedbacks: {
        payload: Prisma.$feedbacksPayload<ExtArgs>
        fields: Prisma.feedbacksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feedbacksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feedbacksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          findFirst: {
            args: Prisma.feedbacksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feedbacksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          findMany: {
            args: Prisma.feedbacksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>[]
          }
          create: {
            args: Prisma.feedbacksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          createMany: {
            args: Prisma.feedbacksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.feedbacksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>[]
          }
          delete: {
            args: Prisma.feedbacksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          update: {
            args: Prisma.feedbacksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          deleteMany: {
            args: Prisma.feedbacksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feedbacksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.feedbacksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>[]
          }
          upsert: {
            args: Prisma.feedbacksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          aggregate: {
            args: Prisma.FeedbacksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbacks>
          }
          groupBy: {
            args: Prisma.feedbacksGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbacksGroupByOutputType>[]
          }
          count: {
            args: Prisma.feedbacksCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbacksCountAggregateOutputType> | number
          }
        }
      }
      health_records: {
        payload: Prisma.$health_recordsPayload<ExtArgs>
        fields: Prisma.health_recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.health_recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.health_recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>
          }
          findFirst: {
            args: Prisma.health_recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.health_recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>
          }
          findMany: {
            args: Prisma.health_recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>[]
          }
          create: {
            args: Prisma.health_recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>
          }
          createMany: {
            args: Prisma.health_recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.health_recordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>[]
          }
          delete: {
            args: Prisma.health_recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>
          }
          update: {
            args: Prisma.health_recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>
          }
          deleteMany: {
            args: Prisma.health_recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.health_recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.health_recordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>[]
          }
          upsert: {
            args: Prisma.health_recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$health_recordsPayload>
          }
          aggregate: {
            args: Prisma.Health_recordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealth_records>
          }
          groupBy: {
            args: Prisma.health_recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Health_recordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.health_recordsCountArgs<ExtArgs>
            result: $Utils.Optional<Health_recordsCountAggregateOutputType> | number
          }
        }
      }
      job_applications: {
        payload: Prisma.$job_applicationsPayload<ExtArgs>
        fields: Prisma.job_applicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_applicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_applicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>
          }
          findFirst: {
            args: Prisma.job_applicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_applicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>
          }
          findMany: {
            args: Prisma.job_applicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>[]
          }
          create: {
            args: Prisma.job_applicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>
          }
          createMany: {
            args: Prisma.job_applicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.job_applicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>[]
          }
          delete: {
            args: Prisma.job_applicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>
          }
          update: {
            args: Prisma.job_applicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>
          }
          deleteMany: {
            args: Prisma.job_applicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_applicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.job_applicationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>[]
          }
          upsert: {
            args: Prisma.job_applicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_applicationsPayload>
          }
          aggregate: {
            args: Prisma.Job_applicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_applications>
          }
          groupBy: {
            args: Prisma.job_applicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_applicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_applicationsCountArgs<ExtArgs>
            result: $Utils.Optional<Job_applicationsCountAggregateOutputType> | number
          }
        }
      }
      jobs: {
        payload: Prisma.$jobsPayload<ExtArgs>
        fields: Prisma.jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findFirst: {
            args: Prisma.jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findMany: {
            args: Prisma.jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          create: {
            args: Prisma.jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          createMany: {
            args: Prisma.jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          delete: {
            args: Prisma.jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          update: {
            args: Prisma.jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          deleteMany: {
            args: Prisma.jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.jobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          upsert: {
            args: Prisma.jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      marketplace_jobs: {
        payload: Prisma.$marketplace_jobsPayload<ExtArgs>
        fields: Prisma.marketplace_jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.marketplace_jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.marketplace_jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>
          }
          findFirst: {
            args: Prisma.marketplace_jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.marketplace_jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>
          }
          findMany: {
            args: Prisma.marketplace_jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>[]
          }
          create: {
            args: Prisma.marketplace_jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>
          }
          createMany: {
            args: Prisma.marketplace_jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.marketplace_jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>[]
          }
          delete: {
            args: Prisma.marketplace_jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>
          }
          update: {
            args: Prisma.marketplace_jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>
          }
          deleteMany: {
            args: Prisma.marketplace_jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.marketplace_jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.marketplace_jobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>[]
          }
          upsert: {
            args: Prisma.marketplace_jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marketplace_jobsPayload>
          }
          aggregate: {
            args: Prisma.Marketplace_jobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplace_jobs>
          }
          groupBy: {
            args: Prisma.marketplace_jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Marketplace_jobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.marketplace_jobsCountArgs<ExtArgs>
            result: $Utils.Optional<Marketplace_jobsCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      packages: {
        payload: Prisma.$packagesPayload<ExtArgs>
        fields: Prisma.packagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.packagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.packagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          findFirst: {
            args: Prisma.packagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.packagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          findMany: {
            args: Prisma.packagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>[]
          }
          create: {
            args: Prisma.packagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          createMany: {
            args: Prisma.packagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.packagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>[]
          }
          delete: {
            args: Prisma.packagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          update: {
            args: Prisma.packagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          deleteMany: {
            args: Prisma.packagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.packagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.packagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>[]
          }
          upsert: {
            args: Prisma.packagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$packagesPayload>
          }
          aggregate: {
            args: Prisma.PackagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackages>
          }
          groupBy: {
            args: Prisma.packagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.packagesCountArgs<ExtArgs>
            result: $Utils.Optional<PackagesCountAggregateOutputType> | number
          }
        }
      }
      patients: {
        payload: Prisma.$patientsPayload<ExtArgs>
        fields: Prisma.patientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findFirst: {
            args: Prisma.patientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findMany: {
            args: Prisma.patientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          create: {
            args: Prisma.patientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          createMany: {
            args: Prisma.patientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          delete: {
            args: Prisma.patientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          update: {
            args: Prisma.patientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          deleteMany: {
            args: Prisma.patientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          upsert: {
            args: Prisma.patientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          aggregate: {
            args: Prisma.PatientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatients>
          }
          groupBy: {
            args: Prisma.patientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patientsCountArgs<ExtArgs>
            result: $Utils.Optional<PatientsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      scheduled_tasks: {
        payload: Prisma.$scheduled_tasksPayload<ExtArgs>
        fields: Prisma.scheduled_tasksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.scheduled_tasksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.scheduled_tasksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>
          }
          findFirst: {
            args: Prisma.scheduled_tasksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.scheduled_tasksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>
          }
          findMany: {
            args: Prisma.scheduled_tasksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>[]
          }
          create: {
            args: Prisma.scheduled_tasksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>
          }
          createMany: {
            args: Prisma.scheduled_tasksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.scheduled_tasksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>[]
          }
          delete: {
            args: Prisma.scheduled_tasksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>
          }
          update: {
            args: Prisma.scheduled_tasksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>
          }
          deleteMany: {
            args: Prisma.scheduled_tasksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.scheduled_tasksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.scheduled_tasksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>[]
          }
          upsert: {
            args: Prisma.scheduled_tasksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scheduled_tasksPayload>
          }
          aggregate: {
            args: Prisma.Scheduled_tasksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduled_tasks>
          }
          groupBy: {
            args: Prisma.scheduled_tasksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Scheduled_tasksGroupByOutputType>[]
          }
          count: {
            args: Prisma.scheduled_tasksCountArgs<ExtArgs>
            result: $Utils.Optional<Scheduled_tasksCountAggregateOutputType> | number
          }
        }
      }
      service_zones: {
        payload: Prisma.$service_zonesPayload<ExtArgs>
        fields: Prisma.service_zonesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_zonesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_zonesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>
          }
          findFirst: {
            args: Prisma.service_zonesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_zonesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>
          }
          findMany: {
            args: Prisma.service_zonesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>[]
          }
          create: {
            args: Prisma.service_zonesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>
          }
          createMany: {
            args: Prisma.service_zonesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.service_zonesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>[]
          }
          delete: {
            args: Prisma.service_zonesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>
          }
          update: {
            args: Prisma.service_zonesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>
          }
          deleteMany: {
            args: Prisma.service_zonesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_zonesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.service_zonesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>[]
          }
          upsert: {
            args: Prisma.service_zonesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_zonesPayload>
          }
          aggregate: {
            args: Prisma.Service_zonesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_zones>
          }
          groupBy: {
            args: Prisma.service_zonesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_zonesGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_zonesCountArgs<ExtArgs>
            result: $Utils.Optional<Service_zonesCountAggregateOutputType> | number
          }
        }
      }
      user_devices: {
        payload: Prisma.$user_devicesPayload<ExtArgs>
        fields: Prisma.user_devicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_devicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_devicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>
          }
          findFirst: {
            args: Prisma.user_devicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_devicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>
          }
          findMany: {
            args: Prisma.user_devicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>[]
          }
          create: {
            args: Prisma.user_devicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>
          }
          createMany: {
            args: Prisma.user_devicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_devicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>[]
          }
          delete: {
            args: Prisma.user_devicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>
          }
          update: {
            args: Prisma.user_devicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>
          }
          deleteMany: {
            args: Prisma.user_devicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_devicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_devicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>[]
          }
          upsert: {
            args: Prisma.user_devicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_devicesPayload>
          }
          aggregate: {
            args: Prisma.User_devicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_devices>
          }
          groupBy: {
            args: Prisma.user_devicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_devicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_devicesCountArgs<ExtArgs>
            result: $Utils.Optional<User_devicesCountAggregateOutputType> | number
          }
        }
      }
      verification_codes: {
        payload: Prisma.$verification_codesPayload<ExtArgs>
        fields: Prisma.verification_codesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.verification_codesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.verification_codesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>
          }
          findFirst: {
            args: Prisma.verification_codesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.verification_codesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>
          }
          findMany: {
            args: Prisma.verification_codesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>[]
          }
          create: {
            args: Prisma.verification_codesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>
          }
          createMany: {
            args: Prisma.verification_codesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.verification_codesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>[]
          }
          delete: {
            args: Prisma.verification_codesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>
          }
          update: {
            args: Prisma.verification_codesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>
          }
          deleteMany: {
            args: Prisma.verification_codesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.verification_codesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.verification_codesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>[]
          }
          upsert: {
            args: Prisma.verification_codesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_codesPayload>
          }
          aggregate: {
            args: Prisma.Verification_codesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification_codes>
          }
          groupBy: {
            args: Prisma.verification_codesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Verification_codesGroupByOutputType>[]
          }
          count: {
            args: Prisma.verification_codesCountArgs<ExtArgs>
            result: $Utils.Optional<Verification_codesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    assignments?: assignmentsOmit
    audit_logs?: audit_logsOmit
    care_logs?: care_logsOmit
    caregivers?: caregiversOmit
    companies?: companiesOmit
    disputes?: disputesOmit
    escrows?: escrowsOmit
    escrow_records?: escrow_recordsOmit
    escrow_ledger?: escrow_ledgerOmit
    provider_transactions?: provider_transactionsOmit
    transaction_logs?: transaction_logsOmit
    feedbacks?: feedbacksOmit
    health_records?: health_recordsOmit
    job_applications?: job_applicationsOmit
    jobs?: jobsOmit
    marketplace_jobs?: marketplace_jobsOmit
    notifications?: notificationsOmit
    packages?: packagesOmit
    patients?: patientsOmit
    payments?: paymentsOmit
    scheduled_tasks?: scheduled_tasksOmit
    service_zones?: service_zonesOmit
    user_devices?: user_devicesOmit
    verification_codes?: verification_codesOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AssignmentsCountOutputType
   */

  export type AssignmentsCountOutputType = {
    care_logs: number
  }

  export type AssignmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    care_logs?: boolean | AssignmentsCountOutputTypeCountCare_logsArgs
  }

  // Custom InputTypes
  /**
   * AssignmentsCountOutputType without action
   */
  export type AssignmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentsCountOutputType
     */
    select?: AssignmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentsCountOutputType without action
   */
  export type AssignmentsCountOutputTypeCountCare_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: care_logsWhereInput
  }


  /**
   * Count Type CaregiversCountOutputType
   */

  export type CaregiversCountOutputType = {
    assignments_assignments_replaced_byTocaregivers: number
    assignments_assignments_caregiver_idTocaregivers: number
    care_logs: number
    job_applications: number
    marketplace_jobs: number
  }

  export type CaregiversCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments_assignments_replaced_byTocaregivers?: boolean | CaregiversCountOutputTypeCountAssignments_assignments_replaced_byTocaregiversArgs
    assignments_assignments_caregiver_idTocaregivers?: boolean | CaregiversCountOutputTypeCountAssignments_assignments_caregiver_idTocaregiversArgs
    care_logs?: boolean | CaregiversCountOutputTypeCountCare_logsArgs
    job_applications?: boolean | CaregiversCountOutputTypeCountJob_applicationsArgs
    marketplace_jobs?: boolean | CaregiversCountOutputTypeCountMarketplace_jobsArgs
  }

  // Custom InputTypes
  /**
   * CaregiversCountOutputType without action
   */
  export type CaregiversCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaregiversCountOutputType
     */
    select?: CaregiversCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaregiversCountOutputType without action
   */
  export type CaregiversCountOutputTypeCountAssignments_assignments_replaced_byTocaregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentsWhereInput
  }

  /**
   * CaregiversCountOutputType without action
   */
  export type CaregiversCountOutputTypeCountAssignments_assignments_caregiver_idTocaregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentsWhereInput
  }

  /**
   * CaregiversCountOutputType without action
   */
  export type CaregiversCountOutputTypeCountCare_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: care_logsWhereInput
  }

  /**
   * CaregiversCountOutputType without action
   */
  export type CaregiversCountOutputTypeCountJob_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_applicationsWhereInput
  }

  /**
   * CaregiversCountOutputType without action
   */
  export type CaregiversCountOutputTypeCountMarketplace_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marketplace_jobsWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    caregivers: number
    jobs: number
    marketplace_jobs: number
    packages: number
    service_zones: number
    users: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers?: boolean | CompaniesCountOutputTypeCountCaregiversArgs
    jobs?: boolean | CompaniesCountOutputTypeCountJobsArgs
    marketplace_jobs?: boolean | CompaniesCountOutputTypeCountMarketplace_jobsArgs
    packages?: boolean | CompaniesCountOutputTypeCountPackagesArgs
    service_zones?: boolean | CompaniesCountOutputTypeCountService_zonesArgs
    users?: boolean | CompaniesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCaregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: caregiversWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountMarketplace_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marketplace_jobsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: packagesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountService_zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_zonesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type Escrow_recordsCountOutputType
   */

  export type Escrow_recordsCountOutputType = {
    ledger_entries: number
  }

  export type Escrow_recordsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledger_entries?: boolean | Escrow_recordsCountOutputTypeCountLedger_entriesArgs
  }

  // Custom InputTypes
  /**
   * Escrow_recordsCountOutputType without action
   */
  export type Escrow_recordsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Escrow_recordsCountOutputType
     */
    select?: Escrow_recordsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Escrow_recordsCountOutputType without action
   */
  export type Escrow_recordsCountOutputTypeCountLedger_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escrow_ledgerWhereInput
  }


  /**
   * Count Type Provider_transactionsCountOutputType
   */

  export type Provider_transactionsCountOutputType = {
    logs: number
  }

  export type Provider_transactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | Provider_transactionsCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * Provider_transactionsCountOutputType without action
   */
  export type Provider_transactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider_transactionsCountOutputType
     */
    select?: Provider_transactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Provider_transactionsCountOutputType without action
   */
  export type Provider_transactionsCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaction_logsWhereInput
  }


  /**
   * Count Type JobsCountOutputType
   */

  export type JobsCountOutputType = {
    assignments: number
    care_logs: number
    disputes: number
    payments: number
  }

  export type JobsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | JobsCountOutputTypeCountAssignmentsArgs
    care_logs?: boolean | JobsCountOutputTypeCountCare_logsArgs
    disputes?: boolean | JobsCountOutputTypeCountDisputesArgs
    payments?: boolean | JobsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobsCountOutputType
     */
    select?: JobsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentsWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountCare_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: care_logsWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountDisputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disputesWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type Marketplace_jobsCountOutputType
   */

  export type Marketplace_jobsCountOutputType = {
    job_applications: number
  }

  export type Marketplace_jobsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_applications?: boolean | Marketplace_jobsCountOutputTypeCountJob_applicationsArgs
  }

  // Custom InputTypes
  /**
   * Marketplace_jobsCountOutputType without action
   */
  export type Marketplace_jobsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketplace_jobsCountOutputType
     */
    select?: Marketplace_jobsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Marketplace_jobsCountOutputType without action
   */
  export type Marketplace_jobsCountOutputTypeCountJob_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_applicationsWhereInput
  }


  /**
   * Count Type PackagesCountOutputType
   */

  export type PackagesCountOutputType = {
    jobs: number
  }

  export type PackagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | PackagesCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * PackagesCountOutputType without action
   */
  export type PackagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackagesCountOutputType
     */
    select?: PackagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackagesCountOutputType without action
   */
  export type PackagesCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
  }


  /**
   * Count Type PatientsCountOutputType
   */

  export type PatientsCountOutputType = {
    care_logs: number
    health_records: number
    jobs: number
  }

  export type PatientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    care_logs?: boolean | PatientsCountOutputTypeCountCare_logsArgs
    health_records?: boolean | PatientsCountOutputTypeCountHealth_recordsArgs
    jobs?: boolean | PatientsCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientsCountOutputType
     */
    select?: PatientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountCare_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: care_logsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountHealth_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: health_recordsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    audit_logs: number
    disputes_disputes_againstTousers: number
    disputes_disputes_raised_byTousers: number
    feedbacks_feedbacks_to_user_idTousers: number
    feedbacks_feedbacks_from_user_idTousers: number
    job_applications: number
    jobs: number
    notifications: number
    patients: number
    payments: number
    user_devices: number
    verification_codes: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit_logs?: boolean | UsersCountOutputTypeCountAudit_logsArgs
    disputes_disputes_againstTousers?: boolean | UsersCountOutputTypeCountDisputes_disputes_againstTousersArgs
    disputes_disputes_raised_byTousers?: boolean | UsersCountOutputTypeCountDisputes_disputes_raised_byTousersArgs
    feedbacks_feedbacks_to_user_idTousers?: boolean | UsersCountOutputTypeCountFeedbacks_feedbacks_to_user_idTousersArgs
    feedbacks_feedbacks_from_user_idTousers?: boolean | UsersCountOutputTypeCountFeedbacks_feedbacks_from_user_idTousersArgs
    job_applications?: boolean | UsersCountOutputTypeCountJob_applicationsArgs
    jobs?: boolean | UsersCountOutputTypeCountJobsArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    patients?: boolean | UsersCountOutputTypeCountPatientsArgs
    payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
    user_devices?: boolean | UsersCountOutputTypeCountUser_devicesArgs
    verification_codes?: boolean | UsersCountOutputTypeCountVerification_codesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAudit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDisputes_disputes_againstTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disputesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDisputes_disputes_raised_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disputesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFeedbacks_feedbacks_to_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbacksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFeedbacks_feedbacks_from_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbacksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJob_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_applicationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_devicesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVerification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: verification_codesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model assignments
   */

  export type AggregateAssignments = {
    _count: AssignmentsCountAggregateOutputType | null
    _min: AssignmentsMinAggregateOutputType | null
    _max: AssignmentsMaxAggregateOutputType | null
  }

  export type AssignmentsMinAggregateOutputType = {
    id: string | null
    job_id: string | null
    caregiver_id: string | null
    role: $Enums.AssignmentRole | null
    shift_start_time: string | null
    shift_end_time: string | null
    status: $Enums.AssignmentStatus | null
    replaced_by: string | null
    replacement_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AssignmentsMaxAggregateOutputType = {
    id: string | null
    job_id: string | null
    caregiver_id: string | null
    role: $Enums.AssignmentRole | null
    shift_start_time: string | null
    shift_end_time: string | null
    status: $Enums.AssignmentStatus | null
    replaced_by: string | null
    replacement_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AssignmentsCountAggregateOutputType = {
    id: number
    job_id: number
    caregiver_id: number
    role: number
    shift_start_time: number
    shift_end_time: number
    days_of_week: number
    status: number
    replaced_by: number
    replacement_reason: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AssignmentsMinAggregateInputType = {
    id?: true
    job_id?: true
    caregiver_id?: true
    role?: true
    shift_start_time?: true
    shift_end_time?: true
    status?: true
    replaced_by?: true
    replacement_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type AssignmentsMaxAggregateInputType = {
    id?: true
    job_id?: true
    caregiver_id?: true
    role?: true
    shift_start_time?: true
    shift_end_time?: true
    status?: true
    replaced_by?: true
    replacement_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type AssignmentsCountAggregateInputType = {
    id?: true
    job_id?: true
    caregiver_id?: true
    role?: true
    shift_start_time?: true
    shift_end_time?: true
    days_of_week?: true
    status?: true
    replaced_by?: true
    replacement_reason?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AssignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignments to aggregate.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assignments
    **/
    _count?: true | AssignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentsMaxAggregateInputType
  }

  export type GetAssignmentsAggregateType<T extends AssignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignments[P]>
      : GetScalarType<T[P], AggregateAssignments[P]>
  }




  export type assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentsWhereInput
    orderBy?: assignmentsOrderByWithAggregationInput | assignmentsOrderByWithAggregationInput[]
    by: AssignmentsScalarFieldEnum[] | AssignmentsScalarFieldEnum
    having?: assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentsCountAggregateInputType | true
    _min?: AssignmentsMinAggregateInputType
    _max?: AssignmentsMaxAggregateInputType
  }

  export type AssignmentsGroupByOutputType = {
    id: string
    job_id: string
    caregiver_id: string
    role: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonValue
    status: $Enums.AssignmentStatus
    replaced_by: string | null
    replacement_reason: string | null
    created_at: Date
    updated_at: Date
    _count: AssignmentsCountAggregateOutputType | null
    _min: AssignmentsMinAggregateOutputType | null
    _max: AssignmentsMaxAggregateOutputType | null
  }

  type GetAssignmentsGroupByPayload<T extends assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentsGroupByOutputType[P]>
        }
      >
    >


  export type assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    caregiver_id?: boolean
    role?: boolean
    shift_start_time?: boolean
    shift_end_time?: boolean
    days_of_week?: boolean
    status?: boolean
    replaced_by?: boolean
    replacement_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    caregivers_assignments_replaced_byTocaregivers?: boolean | assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs>
    caregivers_assignments_caregiver_idTocaregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    care_logs?: boolean | assignments$care_logsArgs<ExtArgs>
    _count?: boolean | AssignmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignments"]>

  export type assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    caregiver_id?: boolean
    role?: boolean
    shift_start_time?: boolean
    shift_end_time?: boolean
    days_of_week?: boolean
    status?: boolean
    replaced_by?: boolean
    replacement_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    caregivers_assignments_replaced_byTocaregivers?: boolean | assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs>
    caregivers_assignments_caregiver_idTocaregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignments"]>

  export type assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    caregiver_id?: boolean
    role?: boolean
    shift_start_time?: boolean
    shift_end_time?: boolean
    days_of_week?: boolean
    status?: boolean
    replaced_by?: boolean
    replacement_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    caregivers_assignments_replaced_byTocaregivers?: boolean | assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs>
    caregivers_assignments_caregiver_idTocaregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignments"]>

  export type assignmentsSelectScalar = {
    id?: boolean
    job_id?: boolean
    caregiver_id?: boolean
    role?: boolean
    shift_start_time?: boolean
    shift_end_time?: boolean
    days_of_week?: boolean
    status?: boolean
    replaced_by?: boolean
    replacement_reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "caregiver_id" | "role" | "shift_start_time" | "shift_end_time" | "days_of_week" | "status" | "replaced_by" | "replacement_reason" | "created_at" | "updated_at", ExtArgs["result"]["assignments"]>
  export type assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers_assignments_replaced_byTocaregivers?: boolean | assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs>
    caregivers_assignments_caregiver_idTocaregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    care_logs?: boolean | assignments$care_logsArgs<ExtArgs>
    _count?: boolean | AssignmentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type assignmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers_assignments_replaced_byTocaregivers?: boolean | assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs>
    caregivers_assignments_caregiver_idTocaregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type assignmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers_assignments_replaced_byTocaregivers?: boolean | assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs>
    caregivers_assignments_caregiver_idTocaregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assignments"
    objects: {
      caregivers_assignments_replaced_byTocaregivers: Prisma.$caregiversPayload<ExtArgs> | null
      caregivers_assignments_caregiver_idTocaregivers: Prisma.$caregiversPayload<ExtArgs>
      jobs: Prisma.$jobsPayload<ExtArgs>
      care_logs: Prisma.$care_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_id: string
      caregiver_id: string
      role: $Enums.AssignmentRole
      shift_start_time: string
      shift_end_time: string
      days_of_week: Prisma.JsonValue
      status: $Enums.AssignmentStatus
      replaced_by: string | null
      replacement_reason: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["assignments"]>
    composites: {}
  }

  type assignmentsGetPayload<S extends boolean | null | undefined | assignmentsDefaultArgs> = $Result.GetResult<Prisma.$assignmentsPayload, S>

  type assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentsCountAggregateInputType | true
    }

  export interface assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assignments'], meta: { name: 'assignments' } }
    /**
     * Find zero or one Assignments that matches the filter.
     * @param {assignmentsFindUniqueArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assignmentsFindUniqueArgs>(args: SelectSubset<T, assignmentsFindUniqueArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {assignmentsFindUniqueOrThrowArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindFirstArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assignmentsFindFirstArgs>(args?: SelectSubset<T, assignmentsFindFirstArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindFirstOrThrowArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignments.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentsWithIdOnly = await prisma.assignments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends assignmentsFindManyArgs>(args?: SelectSubset<T, assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignments.
     * @param {assignmentsCreateArgs} args - Arguments to create a Assignments.
     * @example
     * // Create one Assignments
     * const Assignments = await prisma.assignments.create({
     *   data: {
     *     // ... data to create a Assignments
     *   }
     * })
     * 
     */
    create<T extends assignmentsCreateArgs>(args: SelectSubset<T, assignmentsCreateArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {assignmentsCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignments = await prisma.assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assignmentsCreateManyArgs>(args?: SelectSubset<T, assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {assignmentsCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignments = await prisma.assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentsWithIdOnly = await prisma.assignments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignments.
     * @param {assignmentsDeleteArgs} args - Arguments to delete one Assignments.
     * @example
     * // Delete one Assignments
     * const Assignments = await prisma.assignments.delete({
     *   where: {
     *     // ... filter to delete one Assignments
     *   }
     * })
     * 
     */
    delete<T extends assignmentsDeleteArgs>(args: SelectSubset<T, assignmentsDeleteArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignments.
     * @param {assignmentsUpdateArgs} args - Arguments to update one Assignments.
     * @example
     * // Update one Assignments
     * const assignments = await prisma.assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assignmentsUpdateArgs>(args: SelectSubset<T, assignmentsUpdateArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {assignmentsDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assignmentsDeleteManyArgs>(args?: SelectSubset<T, assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignments = await prisma.assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assignmentsUpdateManyArgs>(args: SelectSubset<T, assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {assignmentsUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignments = await prisma.assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentsWithIdOnly = await prisma.assignments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignments.
     * @param {assignmentsUpsertArgs} args - Arguments to update or create a Assignments.
     * @example
     * // Update or create a Assignments
     * const assignments = await prisma.assignments.upsert({
     *   create: {
     *     // ... data to create a Assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignments we want to update
     *   }
     * })
     */
    upsert<T extends assignmentsUpsertArgs>(args: SelectSubset<T, assignmentsUpsertArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignments.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends assignmentsCountArgs>(
      args?: Subset<T, assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentsAggregateArgs>(args: Subset<T, AssignmentsAggregateArgs>): Prisma.PrismaPromise<GetAssignmentsAggregateType<T>>

    /**
     * Group by Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assignments model
   */
  readonly fields: assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caregivers_assignments_replaced_byTocaregivers<T extends assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs> = {}>(args?: Subset<T, assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    caregivers_assignments_caregiver_idTocaregivers<T extends caregiversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, caregiversDefaultArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    care_logs<T extends assignments$care_logsArgs<ExtArgs> = {}>(args?: Subset<T, assignments$care_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assignments model
   */
  interface assignmentsFieldRefs {
    readonly id: FieldRef<"assignments", 'String'>
    readonly job_id: FieldRef<"assignments", 'String'>
    readonly caregiver_id: FieldRef<"assignments", 'String'>
    readonly role: FieldRef<"assignments", 'AssignmentRole'>
    readonly shift_start_time: FieldRef<"assignments", 'String'>
    readonly shift_end_time: FieldRef<"assignments", 'String'>
    readonly days_of_week: FieldRef<"assignments", 'Json'>
    readonly status: FieldRef<"assignments", 'AssignmentStatus'>
    readonly replaced_by: FieldRef<"assignments", 'String'>
    readonly replacement_reason: FieldRef<"assignments", 'String'>
    readonly created_at: FieldRef<"assignments", 'DateTime'>
    readonly updated_at: FieldRef<"assignments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * assignments findUnique
   */
  export type assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments findUniqueOrThrow
   */
  export type assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments findFirst
   */
  export type assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * assignments findFirstOrThrow
   */
  export type assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * assignments findMany
   */
  export type assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assignments.
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * assignments create
   */
  export type assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a assignments.
     */
    data: XOR<assignmentsCreateInput, assignmentsUncheckedCreateInput>
  }

  /**
   * assignments createMany
   */
  export type assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assignments.
     */
    data: assignmentsCreateManyInput | assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assignments createManyAndReturn
   */
  export type assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many assignments.
     */
    data: assignmentsCreateManyInput | assignmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignments update
   */
  export type assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a assignments.
     */
    data: XOR<assignmentsUpdateInput, assignmentsUncheckedUpdateInput>
    /**
     * Choose, which assignments to update.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments updateMany
   */
  export type assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assignments.
     */
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     */
    where?: assignmentsWhereInput
    /**
     * Limit how many assignments to update.
     */
    limit?: number
  }

  /**
   * assignments updateManyAndReturn
   */
  export type assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update assignments.
     */
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     */
    where?: assignmentsWhereInput
    /**
     * Limit how many assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignments upsert
   */
  export type assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the assignments to update in case it exists.
     */
    where: assignmentsWhereUniqueInput
    /**
     * In case the assignments found by the `where` argument doesn't exist, create a new assignments with this data.
     */
    create: XOR<assignmentsCreateInput, assignmentsUncheckedCreateInput>
    /**
     * In case the assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assignmentsUpdateInput, assignmentsUncheckedUpdateInput>
  }

  /**
   * assignments delete
   */
  export type assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter which assignments to delete.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments deleteMany
   */
  export type assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignments to delete
     */
    where?: assignmentsWhereInput
    /**
     * Limit how many assignments to delete.
     */
    limit?: number
  }

  /**
   * assignments.caregivers_assignments_replaced_byTocaregivers
   */
  export type assignments$caregivers_assignments_replaced_byTocaregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    where?: caregiversWhereInput
  }

  /**
   * assignments.care_logs
   */
  export type assignments$care_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    where?: care_logsWhereInput
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    cursor?: care_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Care_logsScalarFieldEnum | Care_logsScalarFieldEnum[]
  }

  /**
   * assignments without action
   */
  export type assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
  }


  /**
   * Model audit_logs
   */

  export type AggregateAudit_logs = {
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  export type Audit_logsMinAggregateOutputType = {
    id: string | null
    actor_id: string | null
    actor_role: string | null
    action_type: string | null
    entity_type: string | null
    entity_id: string | null
    ip_address: string | null
    user_agent: string | null
    timestamp: Date | null
  }

  export type Audit_logsMaxAggregateOutputType = {
    id: string | null
    actor_id: string | null
    actor_role: string | null
    action_type: string | null
    entity_type: string | null
    entity_id: string | null
    ip_address: string | null
    user_agent: string | null
    timestamp: Date | null
  }

  export type Audit_logsCountAggregateOutputType = {
    id: number
    actor_id: number
    actor_role: number
    action_type: number
    entity_type: number
    entity_id: number
    changes: number
    ip_address: number
    user_agent: number
    timestamp: number
    _all: number
  }


  export type Audit_logsMinAggregateInputType = {
    id?: true
    actor_id?: true
    actor_role?: true
    action_type?: true
    entity_type?: true
    entity_id?: true
    ip_address?: true
    user_agent?: true
    timestamp?: true
  }

  export type Audit_logsMaxAggregateInputType = {
    id?: true
    actor_id?: true
    actor_role?: true
    action_type?: true
    entity_type?: true
    entity_id?: true
    ip_address?: true
    user_agent?: true
    timestamp?: true
  }

  export type Audit_logsCountAggregateInputType = {
    id?: true
    actor_id?: true
    actor_role?: true
    action_type?: true
    entity_type?: true
    entity_id?: true
    changes?: true
    ip_address?: true
    user_agent?: true
    timestamp?: true
    _all?: true
  }

  export type Audit_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to aggregate.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned audit_logs
    **/
    _count?: true | Audit_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Audit_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Audit_logsMaxAggregateInputType
  }

  export type GetAudit_logsAggregateType<T extends Audit_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAudit_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudit_logs[P]>
      : GetScalarType<T[P], AggregateAudit_logs[P]>
  }




  export type audit_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithAggregationInput | audit_logsOrderByWithAggregationInput[]
    by: Audit_logsScalarFieldEnum[] | Audit_logsScalarFieldEnum
    having?: audit_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Audit_logsCountAggregateInputType | true
    _min?: Audit_logsMinAggregateInputType
    _max?: Audit_logsMaxAggregateInputType
  }

  export type Audit_logsGroupByOutputType = {
    id: string
    actor_id: string | null
    actor_role: string | null
    action_type: string
    entity_type: string
    entity_id: string
    changes: JsonValue | null
    ip_address: string | null
    user_agent: string | null
    timestamp: Date
    _count: Audit_logsCountAggregateOutputType | null
    _min: Audit_logsMinAggregateOutputType | null
    _max: Audit_logsMaxAggregateOutputType | null
  }

  type GetAudit_logsGroupByPayload<T extends audit_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Audit_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Audit_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Audit_logsGroupByOutputType[P]>
        }
      >
    >


  export type audit_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actor_id?: boolean
    actor_role?: boolean
    action_type?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    ip_address?: boolean
    user_agent?: boolean
    timestamp?: boolean
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actor_id?: boolean
    actor_role?: boolean
    action_type?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    ip_address?: boolean
    user_agent?: boolean
    timestamp?: boolean
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actor_id?: boolean
    actor_role?: boolean
    action_type?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    ip_address?: boolean
    user_agent?: boolean
    timestamp?: boolean
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }, ExtArgs["result"]["audit_logs"]>

  export type audit_logsSelectScalar = {
    id?: boolean
    actor_id?: boolean
    actor_role?: boolean
    action_type?: boolean
    entity_type?: boolean
    entity_id?: boolean
    changes?: boolean
    ip_address?: boolean
    user_agent?: boolean
    timestamp?: boolean
  }

  export type audit_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actor_id" | "actor_role" | "action_type" | "entity_type" | "entity_id" | "changes" | "ip_address" | "user_agent" | "timestamp", ExtArgs["result"]["audit_logs"]>
  export type audit_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }
  export type audit_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }
  export type audit_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | audit_logs$usersArgs<ExtArgs>
  }

  export type $audit_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "audit_logs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actor_id: string | null
      actor_role: string | null
      action_type: string
      entity_type: string
      entity_id: string
      changes: Prisma.JsonValue | null
      ip_address: string | null
      user_agent: string | null
      timestamp: Date
    }, ExtArgs["result"]["audit_logs"]>
    composites: {}
  }

  type audit_logsGetPayload<S extends boolean | null | undefined | audit_logsDefaultArgs> = $Result.GetResult<Prisma.$audit_logsPayload, S>

  type audit_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<audit_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Audit_logsCountAggregateInputType | true
    }

  export interface audit_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['audit_logs'], meta: { name: 'audit_logs' } }
    /**
     * Find zero or one Audit_logs that matches the filter.
     * @param {audit_logsFindUniqueArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audit_logsFindUniqueArgs>(args: SelectSubset<T, audit_logsFindUniqueArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Audit_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audit_logsFindUniqueOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audit_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, audit_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audit_logsFindFirstArgs>(args?: SelectSubset<T, audit_logsFindFirstArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Audit_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindFirstOrThrowArgs} args - Arguments to find a Audit_logs
     * @example
     * // Get one Audit_logs
     * const audit_logs = await prisma.audit_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audit_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, audit_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany()
     * 
     * // Get first 10 Audit_logs
     * const audit_logs = await prisma.audit_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends audit_logsFindManyArgs>(args?: SelectSubset<T, audit_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Audit_logs.
     * @param {audit_logsCreateArgs} args - Arguments to create a Audit_logs.
     * @example
     * // Create one Audit_logs
     * const Audit_logs = await prisma.audit_logs.create({
     *   data: {
     *     // ... data to create a Audit_logs
     *   }
     * })
     * 
     */
    create<T extends audit_logsCreateArgs>(args: SelectSubset<T, audit_logsCreateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Audit_logs.
     * @param {audit_logsCreateManyArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends audit_logsCreateManyArgs>(args?: SelectSubset<T, audit_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Audit_logs and returns the data saved in the database.
     * @param {audit_logsCreateManyAndReturnArgs} args - Arguments to create many Audit_logs.
     * @example
     * // Create many Audit_logs
     * const audit_logs = await prisma.audit_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends audit_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, audit_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Audit_logs.
     * @param {audit_logsDeleteArgs} args - Arguments to delete one Audit_logs.
     * @example
     * // Delete one Audit_logs
     * const Audit_logs = await prisma.audit_logs.delete({
     *   where: {
     *     // ... filter to delete one Audit_logs
     *   }
     * })
     * 
     */
    delete<T extends audit_logsDeleteArgs>(args: SelectSubset<T, audit_logsDeleteArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Audit_logs.
     * @param {audit_logsUpdateArgs} args - Arguments to update one Audit_logs.
     * @example
     * // Update one Audit_logs
     * const audit_logs = await prisma.audit_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends audit_logsUpdateArgs>(args: SelectSubset<T, audit_logsUpdateArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Audit_logs.
     * @param {audit_logsDeleteManyArgs} args - Arguments to filter Audit_logs to delete.
     * @example
     * // Delete a few Audit_logs
     * const { count } = await prisma.audit_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends audit_logsDeleteManyArgs>(args?: SelectSubset<T, audit_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends audit_logsUpdateManyArgs>(args: SelectSubset<T, audit_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audit_logs and returns the data updated in the database.
     * @param {audit_logsUpdateManyAndReturnArgs} args - Arguments to update many Audit_logs.
     * @example
     * // Update many Audit_logs
     * const audit_logs = await prisma.audit_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Audit_logs and only return the `id`
     * const audit_logsWithIdOnly = await prisma.audit_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends audit_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, audit_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Audit_logs.
     * @param {audit_logsUpsertArgs} args - Arguments to update or create a Audit_logs.
     * @example
     * // Update or create a Audit_logs
     * const audit_logs = await prisma.audit_logs.upsert({
     *   create: {
     *     // ... data to create a Audit_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audit_logs we want to update
     *   }
     * })
     */
    upsert<T extends audit_logsUpsertArgs>(args: SelectSubset<T, audit_logsUpsertArgs<ExtArgs>>): Prisma__audit_logsClient<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsCountArgs} args - Arguments to filter Audit_logs to count.
     * @example
     * // Count the number of Audit_logs
     * const count = await prisma.audit_logs.count({
     *   where: {
     *     // ... the filter for the Audit_logs we want to count
     *   }
     * })
    **/
    count<T extends audit_logsCountArgs>(
      args?: Subset<T, audit_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Audit_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Audit_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Audit_logsAggregateArgs>(args: Subset<T, Audit_logsAggregateArgs>): Prisma.PrismaPromise<GetAudit_logsAggregateType<T>>

    /**
     * Group by Audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audit_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends audit_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audit_logsGroupByArgs['orderBy'] }
        : { orderBy?: audit_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, audit_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudit_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the audit_logs model
   */
  readonly fields: audit_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audit_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audit_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends audit_logs$usersArgs<ExtArgs> = {}>(args?: Subset<T, audit_logs$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the audit_logs model
   */
  interface audit_logsFieldRefs {
    readonly id: FieldRef<"audit_logs", 'String'>
    readonly actor_id: FieldRef<"audit_logs", 'String'>
    readonly actor_role: FieldRef<"audit_logs", 'String'>
    readonly action_type: FieldRef<"audit_logs", 'String'>
    readonly entity_type: FieldRef<"audit_logs", 'String'>
    readonly entity_id: FieldRef<"audit_logs", 'String'>
    readonly changes: FieldRef<"audit_logs", 'Json'>
    readonly ip_address: FieldRef<"audit_logs", 'String'>
    readonly user_agent: FieldRef<"audit_logs", 'String'>
    readonly timestamp: FieldRef<"audit_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * audit_logs findUnique
   */
  export type audit_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findUniqueOrThrow
   */
  export type audit_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs findFirst
   */
  export type audit_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findFirstOrThrow
   */
  export type audit_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of audit_logs.
     */
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs findMany
   */
  export type audit_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter, which audit_logs to fetch.
     */
    where?: audit_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of audit_logs to fetch.
     */
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing audit_logs.
     */
    cursor?: audit_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` audit_logs.
     */
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * audit_logs create
   */
  export type audit_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a audit_logs.
     */
    data: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
  }

  /**
   * audit_logs createMany
   */
  export type audit_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * audit_logs createManyAndReturn
   */
  export type audit_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to create many audit_logs.
     */
    data: audit_logsCreateManyInput | audit_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit_logs update
   */
  export type audit_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a audit_logs.
     */
    data: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
    /**
     * Choose, which audit_logs to update.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs updateMany
   */
  export type audit_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
  }

  /**
   * audit_logs updateManyAndReturn
   */
  export type audit_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * The data used to update audit_logs.
     */
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyInput>
    /**
     * Filter which audit_logs to update
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * audit_logs upsert
   */
  export type audit_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the audit_logs to update in case it exists.
     */
    where: audit_logsWhereUniqueInput
    /**
     * In case the audit_logs found by the `where` argument doesn't exist, create a new audit_logs with this data.
     */
    create: XOR<audit_logsCreateInput, audit_logsUncheckedCreateInput>
    /**
     * In case the audit_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audit_logsUpdateInput, audit_logsUncheckedUpdateInput>
  }

  /**
   * audit_logs delete
   */
  export type audit_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    /**
     * Filter which audit_logs to delete.
     */
    where: audit_logsWhereUniqueInput
  }

  /**
   * audit_logs deleteMany
   */
  export type audit_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which audit_logs to delete
     */
    where?: audit_logsWhereInput
    /**
     * Limit how many audit_logs to delete.
     */
    limit?: number
  }

  /**
   * audit_logs.users
   */
  export type audit_logs$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * audit_logs without action
   */
  export type audit_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
  }


  /**
   * Model care_logs
   */

  export type AggregateCare_logs = {
    _count: Care_logsCountAggregateOutputType | null
    _avg: Care_logsAvgAggregateOutputType | null
    _sum: Care_logsSumAggregateOutputType | null
    _min: Care_logsMinAggregateOutputType | null
    _max: Care_logsMaxAggregateOutputType | null
  }

  export type Care_logsAvgAggregateOutputType = {
    location_lat: Decimal | null
    location_lng: Decimal | null
  }

  export type Care_logsSumAggregateOutputType = {
    location_lat: Decimal | null
    location_lng: Decimal | null
  }

  export type Care_logsMinAggregateOutputType = {
    id: string | null
    job_id: string | null
    assignment_id: string | null
    caregiver_id: string | null
    patient_id: string | null
    log_type: $Enums.CareLogType | null
    timestamp: Date | null
    location_lat: Decimal | null
    location_lng: Decimal | null
    notes: string | null
    guardian_notified: boolean | null
    createdAt: Date | null
  }

  export type Care_logsMaxAggregateOutputType = {
    id: string | null
    job_id: string | null
    assignment_id: string | null
    caregiver_id: string | null
    patient_id: string | null
    log_type: $Enums.CareLogType | null
    timestamp: Date | null
    location_lat: Decimal | null
    location_lng: Decimal | null
    notes: string | null
    guardian_notified: boolean | null
    createdAt: Date | null
  }

  export type Care_logsCountAggregateOutputType = {
    id: number
    job_id: number
    assignment_id: number
    caregiver_id: number
    patient_id: number
    log_type: number
    timestamp: number
    location_lat: number
    location_lng: number
    data: number
    notes: number
    photo_urls: number
    guardian_notified: number
    createdAt: number
    _all: number
  }


  export type Care_logsAvgAggregateInputType = {
    location_lat?: true
    location_lng?: true
  }

  export type Care_logsSumAggregateInputType = {
    location_lat?: true
    location_lng?: true
  }

  export type Care_logsMinAggregateInputType = {
    id?: true
    job_id?: true
    assignment_id?: true
    caregiver_id?: true
    patient_id?: true
    log_type?: true
    timestamp?: true
    location_lat?: true
    location_lng?: true
    notes?: true
    guardian_notified?: true
    createdAt?: true
  }

  export type Care_logsMaxAggregateInputType = {
    id?: true
    job_id?: true
    assignment_id?: true
    caregiver_id?: true
    patient_id?: true
    log_type?: true
    timestamp?: true
    location_lat?: true
    location_lng?: true
    notes?: true
    guardian_notified?: true
    createdAt?: true
  }

  export type Care_logsCountAggregateInputType = {
    id?: true
    job_id?: true
    assignment_id?: true
    caregiver_id?: true
    patient_id?: true
    log_type?: true
    timestamp?: true
    location_lat?: true
    location_lng?: true
    data?: true
    notes?: true
    photo_urls?: true
    guardian_notified?: true
    createdAt?: true
    _all?: true
  }

  export type Care_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which care_logs to aggregate.
     */
    where?: care_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of care_logs to fetch.
     */
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: care_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` care_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` care_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned care_logs
    **/
    _count?: true | Care_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Care_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Care_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Care_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Care_logsMaxAggregateInputType
  }

  export type GetCare_logsAggregateType<T extends Care_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateCare_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCare_logs[P]>
      : GetScalarType<T[P], AggregateCare_logs[P]>
  }




  export type care_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: care_logsWhereInput
    orderBy?: care_logsOrderByWithAggregationInput | care_logsOrderByWithAggregationInput[]
    by: Care_logsScalarFieldEnum[] | Care_logsScalarFieldEnum
    having?: care_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Care_logsCountAggregateInputType | true
    _avg?: Care_logsAvgAggregateInputType
    _sum?: Care_logsSumAggregateInputType
    _min?: Care_logsMinAggregateInputType
    _max?: Care_logsMaxAggregateInputType
  }

  export type Care_logsGroupByOutputType = {
    id: string
    job_id: string
    assignment_id: string | null
    caregiver_id: string
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date
    location_lat: Decimal | null
    location_lng: Decimal | null
    data: JsonValue
    notes: string | null
    photo_urls: JsonValue | null
    guardian_notified: boolean
    createdAt: Date
    _count: Care_logsCountAggregateOutputType | null
    _avg: Care_logsAvgAggregateOutputType | null
    _sum: Care_logsSumAggregateOutputType | null
    _min: Care_logsMinAggregateOutputType | null
    _max: Care_logsMaxAggregateOutputType | null
  }

  type GetCare_logsGroupByPayload<T extends care_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Care_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Care_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Care_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Care_logsGroupByOutputType[P]>
        }
      >
    >


  export type care_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    assignment_id?: boolean
    caregiver_id?: boolean
    patient_id?: boolean
    log_type?: boolean
    timestamp?: boolean
    location_lat?: boolean
    location_lng?: boolean
    data?: boolean
    notes?: boolean
    photo_urls?: boolean
    guardian_notified?: boolean
    createdAt?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    assignments?: boolean | care_logs$assignmentsArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["care_logs"]>

  export type care_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    assignment_id?: boolean
    caregiver_id?: boolean
    patient_id?: boolean
    log_type?: boolean
    timestamp?: boolean
    location_lat?: boolean
    location_lng?: boolean
    data?: boolean
    notes?: boolean
    photo_urls?: boolean
    guardian_notified?: boolean
    createdAt?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    assignments?: boolean | care_logs$assignmentsArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["care_logs"]>

  export type care_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    assignment_id?: boolean
    caregiver_id?: boolean
    patient_id?: boolean
    log_type?: boolean
    timestamp?: boolean
    location_lat?: boolean
    location_lng?: boolean
    data?: boolean
    notes?: boolean
    photo_urls?: boolean
    guardian_notified?: boolean
    createdAt?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    assignments?: boolean | care_logs$assignmentsArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["care_logs"]>

  export type care_logsSelectScalar = {
    id?: boolean
    job_id?: boolean
    assignment_id?: boolean
    caregiver_id?: boolean
    patient_id?: boolean
    log_type?: boolean
    timestamp?: boolean
    location_lat?: boolean
    location_lng?: boolean
    data?: boolean
    notes?: boolean
    photo_urls?: boolean
    guardian_notified?: boolean
    createdAt?: boolean
  }

  export type care_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "assignment_id" | "caregiver_id" | "patient_id" | "log_type" | "timestamp" | "location_lat" | "location_lng" | "data" | "notes" | "photo_urls" | "guardian_notified" | "createdAt", ExtArgs["result"]["care_logs"]>
  export type care_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    assignments?: boolean | care_logs$assignmentsArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type care_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    assignments?: boolean | care_logs$assignmentsArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type care_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    assignments?: boolean | care_logs$assignmentsArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $care_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "care_logs"
    objects: {
      patients: Prisma.$patientsPayload<ExtArgs>
      caregivers: Prisma.$caregiversPayload<ExtArgs>
      assignments: Prisma.$assignmentsPayload<ExtArgs> | null
      jobs: Prisma.$jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_id: string
      assignment_id: string | null
      caregiver_id: string
      patient_id: string
      log_type: $Enums.CareLogType
      timestamp: Date
      location_lat: Prisma.Decimal | null
      location_lng: Prisma.Decimal | null
      data: Prisma.JsonValue
      notes: string | null
      photo_urls: Prisma.JsonValue | null
      guardian_notified: boolean
      createdAt: Date
    }, ExtArgs["result"]["care_logs"]>
    composites: {}
  }

  type care_logsGetPayload<S extends boolean | null | undefined | care_logsDefaultArgs> = $Result.GetResult<Prisma.$care_logsPayload, S>

  type care_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<care_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Care_logsCountAggregateInputType | true
    }

  export interface care_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['care_logs'], meta: { name: 'care_logs' } }
    /**
     * Find zero or one Care_logs that matches the filter.
     * @param {care_logsFindUniqueArgs} args - Arguments to find a Care_logs
     * @example
     * // Get one Care_logs
     * const care_logs = await prisma.care_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends care_logsFindUniqueArgs>(args: SelectSubset<T, care_logsFindUniqueArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Care_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {care_logsFindUniqueOrThrowArgs} args - Arguments to find a Care_logs
     * @example
     * // Get one Care_logs
     * const care_logs = await prisma.care_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends care_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, care_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Care_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {care_logsFindFirstArgs} args - Arguments to find a Care_logs
     * @example
     * // Get one Care_logs
     * const care_logs = await prisma.care_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends care_logsFindFirstArgs>(args?: SelectSubset<T, care_logsFindFirstArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Care_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {care_logsFindFirstOrThrowArgs} args - Arguments to find a Care_logs
     * @example
     * // Get one Care_logs
     * const care_logs = await prisma.care_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends care_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, care_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Care_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {care_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Care_logs
     * const care_logs = await prisma.care_logs.findMany()
     * 
     * // Get first 10 Care_logs
     * const care_logs = await prisma.care_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const care_logsWithIdOnly = await prisma.care_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends care_logsFindManyArgs>(args?: SelectSubset<T, care_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Care_logs.
     * @param {care_logsCreateArgs} args - Arguments to create a Care_logs.
     * @example
     * // Create one Care_logs
     * const Care_logs = await prisma.care_logs.create({
     *   data: {
     *     // ... data to create a Care_logs
     *   }
     * })
     * 
     */
    create<T extends care_logsCreateArgs>(args: SelectSubset<T, care_logsCreateArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Care_logs.
     * @param {care_logsCreateManyArgs} args - Arguments to create many Care_logs.
     * @example
     * // Create many Care_logs
     * const care_logs = await prisma.care_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends care_logsCreateManyArgs>(args?: SelectSubset<T, care_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Care_logs and returns the data saved in the database.
     * @param {care_logsCreateManyAndReturnArgs} args - Arguments to create many Care_logs.
     * @example
     * // Create many Care_logs
     * const care_logs = await prisma.care_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Care_logs and only return the `id`
     * const care_logsWithIdOnly = await prisma.care_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends care_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, care_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Care_logs.
     * @param {care_logsDeleteArgs} args - Arguments to delete one Care_logs.
     * @example
     * // Delete one Care_logs
     * const Care_logs = await prisma.care_logs.delete({
     *   where: {
     *     // ... filter to delete one Care_logs
     *   }
     * })
     * 
     */
    delete<T extends care_logsDeleteArgs>(args: SelectSubset<T, care_logsDeleteArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Care_logs.
     * @param {care_logsUpdateArgs} args - Arguments to update one Care_logs.
     * @example
     * // Update one Care_logs
     * const care_logs = await prisma.care_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends care_logsUpdateArgs>(args: SelectSubset<T, care_logsUpdateArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Care_logs.
     * @param {care_logsDeleteManyArgs} args - Arguments to filter Care_logs to delete.
     * @example
     * // Delete a few Care_logs
     * const { count } = await prisma.care_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends care_logsDeleteManyArgs>(args?: SelectSubset<T, care_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Care_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {care_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Care_logs
     * const care_logs = await prisma.care_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends care_logsUpdateManyArgs>(args: SelectSubset<T, care_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Care_logs and returns the data updated in the database.
     * @param {care_logsUpdateManyAndReturnArgs} args - Arguments to update many Care_logs.
     * @example
     * // Update many Care_logs
     * const care_logs = await prisma.care_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Care_logs and only return the `id`
     * const care_logsWithIdOnly = await prisma.care_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends care_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, care_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Care_logs.
     * @param {care_logsUpsertArgs} args - Arguments to update or create a Care_logs.
     * @example
     * // Update or create a Care_logs
     * const care_logs = await prisma.care_logs.upsert({
     *   create: {
     *     // ... data to create a Care_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Care_logs we want to update
     *   }
     * })
     */
    upsert<T extends care_logsUpsertArgs>(args: SelectSubset<T, care_logsUpsertArgs<ExtArgs>>): Prisma__care_logsClient<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Care_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {care_logsCountArgs} args - Arguments to filter Care_logs to count.
     * @example
     * // Count the number of Care_logs
     * const count = await prisma.care_logs.count({
     *   where: {
     *     // ... the filter for the Care_logs we want to count
     *   }
     * })
    **/
    count<T extends care_logsCountArgs>(
      args?: Subset<T, care_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Care_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Care_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Care_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Care_logsAggregateArgs>(args: Subset<T, Care_logsAggregateArgs>): Prisma.PrismaPromise<GetCare_logsAggregateType<T>>

    /**
     * Group by Care_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {care_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends care_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: care_logsGroupByArgs['orderBy'] }
        : { orderBy?: care_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, care_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCare_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the care_logs model
   */
  readonly fields: care_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for care_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__care_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends patientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientsDefaultArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    caregivers<T extends caregiversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, caregiversDefaultArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignments<T extends care_logs$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, care_logs$assignmentsArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobs<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the care_logs model
   */
  interface care_logsFieldRefs {
    readonly id: FieldRef<"care_logs", 'String'>
    readonly job_id: FieldRef<"care_logs", 'String'>
    readonly assignment_id: FieldRef<"care_logs", 'String'>
    readonly caregiver_id: FieldRef<"care_logs", 'String'>
    readonly patient_id: FieldRef<"care_logs", 'String'>
    readonly log_type: FieldRef<"care_logs", 'CareLogType'>
    readonly timestamp: FieldRef<"care_logs", 'DateTime'>
    readonly location_lat: FieldRef<"care_logs", 'Decimal'>
    readonly location_lng: FieldRef<"care_logs", 'Decimal'>
    readonly data: FieldRef<"care_logs", 'Json'>
    readonly notes: FieldRef<"care_logs", 'String'>
    readonly photo_urls: FieldRef<"care_logs", 'Json'>
    readonly guardian_notified: FieldRef<"care_logs", 'Boolean'>
    readonly createdAt: FieldRef<"care_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * care_logs findUnique
   */
  export type care_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * Filter, which care_logs to fetch.
     */
    where: care_logsWhereUniqueInput
  }

  /**
   * care_logs findUniqueOrThrow
   */
  export type care_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * Filter, which care_logs to fetch.
     */
    where: care_logsWhereUniqueInput
  }

  /**
   * care_logs findFirst
   */
  export type care_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * Filter, which care_logs to fetch.
     */
    where?: care_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of care_logs to fetch.
     */
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for care_logs.
     */
    cursor?: care_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` care_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` care_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of care_logs.
     */
    distinct?: Care_logsScalarFieldEnum | Care_logsScalarFieldEnum[]
  }

  /**
   * care_logs findFirstOrThrow
   */
  export type care_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * Filter, which care_logs to fetch.
     */
    where?: care_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of care_logs to fetch.
     */
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for care_logs.
     */
    cursor?: care_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` care_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` care_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of care_logs.
     */
    distinct?: Care_logsScalarFieldEnum | Care_logsScalarFieldEnum[]
  }

  /**
   * care_logs findMany
   */
  export type care_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * Filter, which care_logs to fetch.
     */
    where?: care_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of care_logs to fetch.
     */
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing care_logs.
     */
    cursor?: care_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` care_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` care_logs.
     */
    skip?: number
    distinct?: Care_logsScalarFieldEnum | Care_logsScalarFieldEnum[]
  }

  /**
   * care_logs create
   */
  export type care_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a care_logs.
     */
    data: XOR<care_logsCreateInput, care_logsUncheckedCreateInput>
  }

  /**
   * care_logs createMany
   */
  export type care_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many care_logs.
     */
    data: care_logsCreateManyInput | care_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * care_logs createManyAndReturn
   */
  export type care_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * The data used to create many care_logs.
     */
    data: care_logsCreateManyInput | care_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * care_logs update
   */
  export type care_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a care_logs.
     */
    data: XOR<care_logsUpdateInput, care_logsUncheckedUpdateInput>
    /**
     * Choose, which care_logs to update.
     */
    where: care_logsWhereUniqueInput
  }

  /**
   * care_logs updateMany
   */
  export type care_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update care_logs.
     */
    data: XOR<care_logsUpdateManyMutationInput, care_logsUncheckedUpdateManyInput>
    /**
     * Filter which care_logs to update
     */
    where?: care_logsWhereInput
    /**
     * Limit how many care_logs to update.
     */
    limit?: number
  }

  /**
   * care_logs updateManyAndReturn
   */
  export type care_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * The data used to update care_logs.
     */
    data: XOR<care_logsUpdateManyMutationInput, care_logsUncheckedUpdateManyInput>
    /**
     * Filter which care_logs to update
     */
    where?: care_logsWhereInput
    /**
     * Limit how many care_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * care_logs upsert
   */
  export type care_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the care_logs to update in case it exists.
     */
    where: care_logsWhereUniqueInput
    /**
     * In case the care_logs found by the `where` argument doesn't exist, create a new care_logs with this data.
     */
    create: XOR<care_logsCreateInput, care_logsUncheckedCreateInput>
    /**
     * In case the care_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<care_logsUpdateInput, care_logsUncheckedUpdateInput>
  }

  /**
   * care_logs delete
   */
  export type care_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    /**
     * Filter which care_logs to delete.
     */
    where: care_logsWhereUniqueInput
  }

  /**
   * care_logs deleteMany
   */
  export type care_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which care_logs to delete
     */
    where?: care_logsWhereInput
    /**
     * Limit how many care_logs to delete.
     */
    limit?: number
  }

  /**
   * care_logs.assignments
   */
  export type care_logs$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    where?: assignmentsWhereInput
  }

  /**
   * care_logs without action
   */
  export type care_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
  }


  /**
   * Model caregivers
   */

  export type AggregateCaregivers = {
    _count: CaregiversCountAggregateOutputType | null
    _avg: CaregiversAvgAggregateOutputType | null
    _sum: CaregiversSumAggregateOutputType | null
    _min: CaregiversMinAggregateOutputType | null
    _max: CaregiversMaxAggregateOutputType | null
  }

  export type CaregiversAvgAggregateOutputType = {
    location_lat: Decimal | null
    location_lng: Decimal | null
    experience_years: number | null
    hourly_rate: Decimal | null
    rating_avg: Decimal | null
    rating_count: number | null
    total_jobs_completed: number | null
  }

  export type CaregiversSumAggregateOutputType = {
    location_lat: Decimal | null
    location_lng: Decimal | null
    experience_years: number | null
    hourly_rate: Decimal | null
    rating_avg: Decimal | null
    rating_count: number | null
    total_jobs_completed: number | null
  }

  export type CaregiversMinAggregateOutputType = {
    id: string | null
    userId: string | null
    company_id: string | null
    nid: string | null
    nid_url: string | null
    photo_url: string | null
    date_of_birth: Date | null
    gender: $Enums.Gender | null
    address: string | null
    location_lat: Decimal | null
    location_lng: Decimal | null
    experience_years: number | null
    hourly_rate: Decimal | null
    background_check_status: $Enums.BackgroundCheckStatus | null
    background_check_date: Date | null
    rating_avg: Decimal | null
    rating_count: number | null
    total_jobs_completed: number | null
    is_available: boolean | null
    is_verified: boolean | null
    verification_notes: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CaregiversMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    company_id: string | null
    nid: string | null
    nid_url: string | null
    photo_url: string | null
    date_of_birth: Date | null
    gender: $Enums.Gender | null
    address: string | null
    location_lat: Decimal | null
    location_lng: Decimal | null
    experience_years: number | null
    hourly_rate: Decimal | null
    background_check_status: $Enums.BackgroundCheckStatus | null
    background_check_date: Date | null
    rating_avg: Decimal | null
    rating_count: number | null
    total_jobs_completed: number | null
    is_available: boolean | null
    is_verified: boolean | null
    verification_notes: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CaregiversCountAggregateOutputType = {
    id: number
    userId: number
    company_id: number
    nid: number
    nid_url: number
    photo_url: number
    date_of_birth: number
    gender: number
    address: number
    location_lat: number
    location_lng: number
    skills: number
    certifications: number
    experience_years: number
    languages: number
    availabilityCalendar: number
    hourly_rate: number
    background_check_status: number
    background_check_date: number
    rating_avg: number
    rating_count: number
    total_jobs_completed: number
    is_available: number
    is_verified: number
    verification_notes: number
    deleted_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CaregiversAvgAggregateInputType = {
    location_lat?: true
    location_lng?: true
    experience_years?: true
    hourly_rate?: true
    rating_avg?: true
    rating_count?: true
    total_jobs_completed?: true
  }

  export type CaregiversSumAggregateInputType = {
    location_lat?: true
    location_lng?: true
    experience_years?: true
    hourly_rate?: true
    rating_avg?: true
    rating_count?: true
    total_jobs_completed?: true
  }

  export type CaregiversMinAggregateInputType = {
    id?: true
    userId?: true
    company_id?: true
    nid?: true
    nid_url?: true
    photo_url?: true
    date_of_birth?: true
    gender?: true
    address?: true
    location_lat?: true
    location_lng?: true
    experience_years?: true
    hourly_rate?: true
    background_check_status?: true
    background_check_date?: true
    rating_avg?: true
    rating_count?: true
    total_jobs_completed?: true
    is_available?: true
    is_verified?: true
    verification_notes?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type CaregiversMaxAggregateInputType = {
    id?: true
    userId?: true
    company_id?: true
    nid?: true
    nid_url?: true
    photo_url?: true
    date_of_birth?: true
    gender?: true
    address?: true
    location_lat?: true
    location_lng?: true
    experience_years?: true
    hourly_rate?: true
    background_check_status?: true
    background_check_date?: true
    rating_avg?: true
    rating_count?: true
    total_jobs_completed?: true
    is_available?: true
    is_verified?: true
    verification_notes?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type CaregiversCountAggregateInputType = {
    id?: true
    userId?: true
    company_id?: true
    nid?: true
    nid_url?: true
    photo_url?: true
    date_of_birth?: true
    gender?: true
    address?: true
    location_lat?: true
    location_lng?: true
    skills?: true
    certifications?: true
    experience_years?: true
    languages?: true
    availabilityCalendar?: true
    hourly_rate?: true
    background_check_status?: true
    background_check_date?: true
    rating_avg?: true
    rating_count?: true
    total_jobs_completed?: true
    is_available?: true
    is_verified?: true
    verification_notes?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CaregiversAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which caregivers to aggregate.
     */
    where?: caregiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caregivers to fetch.
     */
    orderBy?: caregiversOrderByWithRelationInput | caregiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: caregiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caregivers
    **/
    _count?: true | CaregiversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaregiversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaregiversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaregiversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaregiversMaxAggregateInputType
  }

  export type GetCaregiversAggregateType<T extends CaregiversAggregateArgs> = {
        [P in keyof T & keyof AggregateCaregivers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaregivers[P]>
      : GetScalarType<T[P], AggregateCaregivers[P]>
  }




  export type caregiversGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: caregiversWhereInput
    orderBy?: caregiversOrderByWithAggregationInput | caregiversOrderByWithAggregationInput[]
    by: CaregiversScalarFieldEnum[] | CaregiversScalarFieldEnum
    having?: caregiversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaregiversCountAggregateInputType | true
    _avg?: CaregiversAvgAggregateInputType
    _sum?: CaregiversSumAggregateInputType
    _min?: CaregiversMinAggregateInputType
    _max?: CaregiversMaxAggregateInputType
  }

  export type CaregiversGroupByOutputType = {
    id: string
    userId: string
    company_id: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date
    gender: $Enums.Gender
    address: string
    location_lat: Decimal | null
    location_lng: Decimal | null
    skills: JsonValue
    certifications: JsonValue | null
    experience_years: number
    languages: JsonValue
    availabilityCalendar: JsonValue | null
    hourly_rate: Decimal | null
    background_check_status: $Enums.BackgroundCheckStatus
    background_check_date: Date | null
    rating_avg: Decimal
    rating_count: number
    total_jobs_completed: number
    is_available: boolean
    is_verified: boolean
    verification_notes: string | null
    deleted_at: Date | null
    created_at: Date
    updated_at: Date
    _count: CaregiversCountAggregateOutputType | null
    _avg: CaregiversAvgAggregateOutputType | null
    _sum: CaregiversSumAggregateOutputType | null
    _min: CaregiversMinAggregateOutputType | null
    _max: CaregiversMaxAggregateOutputType | null
  }

  type GetCaregiversGroupByPayload<T extends caregiversGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaregiversGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaregiversGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaregiversGroupByOutputType[P]>
            : GetScalarType<T[P], CaregiversGroupByOutputType[P]>
        }
      >
    >


  export type caregiversSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company_id?: boolean
    nid?: boolean
    nid_url?: boolean
    photo_url?: boolean
    date_of_birth?: boolean
    gender?: boolean
    address?: boolean
    location_lat?: boolean
    location_lng?: boolean
    skills?: boolean
    certifications?: boolean
    experience_years?: boolean
    languages?: boolean
    availabilityCalendar?: boolean
    hourly_rate?: boolean
    background_check_status?: boolean
    background_check_date?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    total_jobs_completed?: boolean
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    assignments_assignments_replaced_byTocaregivers?: boolean | caregivers$assignments_assignments_replaced_byTocaregiversArgs<ExtArgs>
    assignments_assignments_caregiver_idTocaregivers?: boolean | caregivers$assignments_assignments_caregiver_idTocaregiversArgs<ExtArgs>
    care_logs?: boolean | caregivers$care_logsArgs<ExtArgs>
    companies?: boolean | caregivers$companiesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    job_applications?: boolean | caregivers$job_applicationsArgs<ExtArgs>
    marketplace_jobs?: boolean | caregivers$marketplace_jobsArgs<ExtArgs>
    _count?: boolean | CaregiversCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caregivers"]>

  export type caregiversSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company_id?: boolean
    nid?: boolean
    nid_url?: boolean
    photo_url?: boolean
    date_of_birth?: boolean
    gender?: boolean
    address?: boolean
    location_lat?: boolean
    location_lng?: boolean
    skills?: boolean
    certifications?: boolean
    experience_years?: boolean
    languages?: boolean
    availabilityCalendar?: boolean
    hourly_rate?: boolean
    background_check_status?: boolean
    background_check_date?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    total_jobs_completed?: boolean
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | caregivers$companiesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caregivers"]>

  export type caregiversSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company_id?: boolean
    nid?: boolean
    nid_url?: boolean
    photo_url?: boolean
    date_of_birth?: boolean
    gender?: boolean
    address?: boolean
    location_lat?: boolean
    location_lng?: boolean
    skills?: boolean
    certifications?: boolean
    experience_years?: boolean
    languages?: boolean
    availabilityCalendar?: boolean
    hourly_rate?: boolean
    background_check_status?: boolean
    background_check_date?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    total_jobs_completed?: boolean
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | caregivers$companiesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caregivers"]>

  export type caregiversSelectScalar = {
    id?: boolean
    userId?: boolean
    company_id?: boolean
    nid?: boolean
    nid_url?: boolean
    photo_url?: boolean
    date_of_birth?: boolean
    gender?: boolean
    address?: boolean
    location_lat?: boolean
    location_lng?: boolean
    skills?: boolean
    certifications?: boolean
    experience_years?: boolean
    languages?: boolean
    availabilityCalendar?: boolean
    hourly_rate?: boolean
    background_check_status?: boolean
    background_check_date?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    total_jobs_completed?: boolean
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type caregiversOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "company_id" | "nid" | "nid_url" | "photo_url" | "date_of_birth" | "gender" | "address" | "location_lat" | "location_lng" | "skills" | "certifications" | "experience_years" | "languages" | "availabilityCalendar" | "hourly_rate" | "background_check_status" | "background_check_date" | "rating_avg" | "rating_count" | "total_jobs_completed" | "is_available" | "is_verified" | "verification_notes" | "deleted_at" | "created_at" | "updated_at", ExtArgs["result"]["caregivers"]>
  export type caregiversInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments_assignments_replaced_byTocaregivers?: boolean | caregivers$assignments_assignments_replaced_byTocaregiversArgs<ExtArgs>
    assignments_assignments_caregiver_idTocaregivers?: boolean | caregivers$assignments_assignments_caregiver_idTocaregiversArgs<ExtArgs>
    care_logs?: boolean | caregivers$care_logsArgs<ExtArgs>
    companies?: boolean | caregivers$companiesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    job_applications?: boolean | caregivers$job_applicationsArgs<ExtArgs>
    marketplace_jobs?: boolean | caregivers$marketplace_jobsArgs<ExtArgs>
    _count?: boolean | CaregiversCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type caregiversIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | caregivers$companiesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type caregiversIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | caregivers$companiesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $caregiversPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "caregivers"
    objects: {
      assignments_assignments_replaced_byTocaregivers: Prisma.$assignmentsPayload<ExtArgs>[]
      assignments_assignments_caregiver_idTocaregivers: Prisma.$assignmentsPayload<ExtArgs>[]
      care_logs: Prisma.$care_logsPayload<ExtArgs>[]
      companies: Prisma.$companiesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      job_applications: Prisma.$job_applicationsPayload<ExtArgs>[]
      marketplace_jobs: Prisma.$marketplace_jobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      company_id: string | null
      nid: string
      nid_url: string
      photo_url: string
      date_of_birth: Date
      gender: $Enums.Gender
      address: string
      location_lat: Prisma.Decimal | null
      location_lng: Prisma.Decimal | null
      skills: Prisma.JsonValue
      certifications: Prisma.JsonValue | null
      experience_years: number
      languages: Prisma.JsonValue
      availabilityCalendar: Prisma.JsonValue | null
      hourly_rate: Prisma.Decimal | null
      background_check_status: $Enums.BackgroundCheckStatus
      background_check_date: Date | null
      rating_avg: Prisma.Decimal
      rating_count: number
      total_jobs_completed: number
      is_available: boolean
      is_verified: boolean
      verification_notes: string | null
      deleted_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["caregivers"]>
    composites: {}
  }

  type caregiversGetPayload<S extends boolean | null | undefined | caregiversDefaultArgs> = $Result.GetResult<Prisma.$caregiversPayload, S>

  type caregiversCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<caregiversFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaregiversCountAggregateInputType | true
    }

  export interface caregiversDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['caregivers'], meta: { name: 'caregivers' } }
    /**
     * Find zero or one Caregivers that matches the filter.
     * @param {caregiversFindUniqueArgs} args - Arguments to find a Caregivers
     * @example
     * // Get one Caregivers
     * const caregivers = await prisma.caregivers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends caregiversFindUniqueArgs>(args: SelectSubset<T, caregiversFindUniqueArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Caregivers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {caregiversFindUniqueOrThrowArgs} args - Arguments to find a Caregivers
     * @example
     * // Get one Caregivers
     * const caregivers = await prisma.caregivers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends caregiversFindUniqueOrThrowArgs>(args: SelectSubset<T, caregiversFindUniqueOrThrowArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caregivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caregiversFindFirstArgs} args - Arguments to find a Caregivers
     * @example
     * // Get one Caregivers
     * const caregivers = await prisma.caregivers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends caregiversFindFirstArgs>(args?: SelectSubset<T, caregiversFindFirstArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caregivers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caregiversFindFirstOrThrowArgs} args - Arguments to find a Caregivers
     * @example
     * // Get one Caregivers
     * const caregivers = await prisma.caregivers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends caregiversFindFirstOrThrowArgs>(args?: SelectSubset<T, caregiversFindFirstOrThrowArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caregivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caregiversFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caregivers
     * const caregivers = await prisma.caregivers.findMany()
     * 
     * // Get first 10 Caregivers
     * const caregivers = await prisma.caregivers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caregiversWithIdOnly = await prisma.caregivers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends caregiversFindManyArgs>(args?: SelectSubset<T, caregiversFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Caregivers.
     * @param {caregiversCreateArgs} args - Arguments to create a Caregivers.
     * @example
     * // Create one Caregivers
     * const Caregivers = await prisma.caregivers.create({
     *   data: {
     *     // ... data to create a Caregivers
     *   }
     * })
     * 
     */
    create<T extends caregiversCreateArgs>(args: SelectSubset<T, caregiversCreateArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caregivers.
     * @param {caregiversCreateManyArgs} args - Arguments to create many Caregivers.
     * @example
     * // Create many Caregivers
     * const caregivers = await prisma.caregivers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends caregiversCreateManyArgs>(args?: SelectSubset<T, caregiversCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Caregivers and returns the data saved in the database.
     * @param {caregiversCreateManyAndReturnArgs} args - Arguments to create many Caregivers.
     * @example
     * // Create many Caregivers
     * const caregivers = await prisma.caregivers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Caregivers and only return the `id`
     * const caregiversWithIdOnly = await prisma.caregivers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends caregiversCreateManyAndReturnArgs>(args?: SelectSubset<T, caregiversCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Caregivers.
     * @param {caregiversDeleteArgs} args - Arguments to delete one Caregivers.
     * @example
     * // Delete one Caregivers
     * const Caregivers = await prisma.caregivers.delete({
     *   where: {
     *     // ... filter to delete one Caregivers
     *   }
     * })
     * 
     */
    delete<T extends caregiversDeleteArgs>(args: SelectSubset<T, caregiversDeleteArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Caregivers.
     * @param {caregiversUpdateArgs} args - Arguments to update one Caregivers.
     * @example
     * // Update one Caregivers
     * const caregivers = await prisma.caregivers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends caregiversUpdateArgs>(args: SelectSubset<T, caregiversUpdateArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caregivers.
     * @param {caregiversDeleteManyArgs} args - Arguments to filter Caregivers to delete.
     * @example
     * // Delete a few Caregivers
     * const { count } = await prisma.caregivers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends caregiversDeleteManyArgs>(args?: SelectSubset<T, caregiversDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caregiversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caregivers
     * const caregivers = await prisma.caregivers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends caregiversUpdateManyArgs>(args: SelectSubset<T, caregiversUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caregivers and returns the data updated in the database.
     * @param {caregiversUpdateManyAndReturnArgs} args - Arguments to update many Caregivers.
     * @example
     * // Update many Caregivers
     * const caregivers = await prisma.caregivers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Caregivers and only return the `id`
     * const caregiversWithIdOnly = await prisma.caregivers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends caregiversUpdateManyAndReturnArgs>(args: SelectSubset<T, caregiversUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Caregivers.
     * @param {caregiversUpsertArgs} args - Arguments to update or create a Caregivers.
     * @example
     * // Update or create a Caregivers
     * const caregivers = await prisma.caregivers.upsert({
     *   create: {
     *     // ... data to create a Caregivers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caregivers we want to update
     *   }
     * })
     */
    upsert<T extends caregiversUpsertArgs>(args: SelectSubset<T, caregiversUpsertArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caregiversCountArgs} args - Arguments to filter Caregivers to count.
     * @example
     * // Count the number of Caregivers
     * const count = await prisma.caregivers.count({
     *   where: {
     *     // ... the filter for the Caregivers we want to count
     *   }
     * })
    **/
    count<T extends caregiversCountArgs>(
      args?: Subset<T, caregiversCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaregiversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaregiversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaregiversAggregateArgs>(args: Subset<T, CaregiversAggregateArgs>): Prisma.PrismaPromise<GetCaregiversAggregateType<T>>

    /**
     * Group by Caregivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {caregiversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends caregiversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: caregiversGroupByArgs['orderBy'] }
        : { orderBy?: caregiversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, caregiversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaregiversGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the caregivers model
   */
  readonly fields: caregiversFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for caregivers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__caregiversClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments_assignments_replaced_byTocaregivers<T extends caregivers$assignments_assignments_replaced_byTocaregiversArgs<ExtArgs> = {}>(args?: Subset<T, caregivers$assignments_assignments_replaced_byTocaregiversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments_assignments_caregiver_idTocaregivers<T extends caregivers$assignments_assignments_caregiver_idTocaregiversArgs<ExtArgs> = {}>(args?: Subset<T, caregivers$assignments_assignments_caregiver_idTocaregiversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    care_logs<T extends caregivers$care_logsArgs<ExtArgs> = {}>(args?: Subset<T, caregivers$care_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends caregivers$companiesArgs<ExtArgs> = {}>(args?: Subset<T, caregivers$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job_applications<T extends caregivers$job_applicationsArgs<ExtArgs> = {}>(args?: Subset<T, caregivers$job_applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marketplace_jobs<T extends caregivers$marketplace_jobsArgs<ExtArgs> = {}>(args?: Subset<T, caregivers$marketplace_jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the caregivers model
   */
  interface caregiversFieldRefs {
    readonly id: FieldRef<"caregivers", 'String'>
    readonly userId: FieldRef<"caregivers", 'String'>
    readonly company_id: FieldRef<"caregivers", 'String'>
    readonly nid: FieldRef<"caregivers", 'String'>
    readonly nid_url: FieldRef<"caregivers", 'String'>
    readonly photo_url: FieldRef<"caregivers", 'String'>
    readonly date_of_birth: FieldRef<"caregivers", 'DateTime'>
    readonly gender: FieldRef<"caregivers", 'Gender'>
    readonly address: FieldRef<"caregivers", 'String'>
    readonly location_lat: FieldRef<"caregivers", 'Decimal'>
    readonly location_lng: FieldRef<"caregivers", 'Decimal'>
    readonly skills: FieldRef<"caregivers", 'Json'>
    readonly certifications: FieldRef<"caregivers", 'Json'>
    readonly experience_years: FieldRef<"caregivers", 'Int'>
    readonly languages: FieldRef<"caregivers", 'Json'>
    readonly availabilityCalendar: FieldRef<"caregivers", 'Json'>
    readonly hourly_rate: FieldRef<"caregivers", 'Decimal'>
    readonly background_check_status: FieldRef<"caregivers", 'BackgroundCheckStatus'>
    readonly background_check_date: FieldRef<"caregivers", 'DateTime'>
    readonly rating_avg: FieldRef<"caregivers", 'Decimal'>
    readonly rating_count: FieldRef<"caregivers", 'Int'>
    readonly total_jobs_completed: FieldRef<"caregivers", 'Int'>
    readonly is_available: FieldRef<"caregivers", 'Boolean'>
    readonly is_verified: FieldRef<"caregivers", 'Boolean'>
    readonly verification_notes: FieldRef<"caregivers", 'String'>
    readonly deleted_at: FieldRef<"caregivers", 'DateTime'>
    readonly created_at: FieldRef<"caregivers", 'DateTime'>
    readonly updated_at: FieldRef<"caregivers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * caregivers findUnique
   */
  export type caregiversFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * Filter, which caregivers to fetch.
     */
    where: caregiversWhereUniqueInput
  }

  /**
   * caregivers findUniqueOrThrow
   */
  export type caregiversFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * Filter, which caregivers to fetch.
     */
    where: caregiversWhereUniqueInput
  }

  /**
   * caregivers findFirst
   */
  export type caregiversFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * Filter, which caregivers to fetch.
     */
    where?: caregiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caregivers to fetch.
     */
    orderBy?: caregiversOrderByWithRelationInput | caregiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caregivers.
     */
    cursor?: caregiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caregivers.
     */
    distinct?: CaregiversScalarFieldEnum | CaregiversScalarFieldEnum[]
  }

  /**
   * caregivers findFirstOrThrow
   */
  export type caregiversFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * Filter, which caregivers to fetch.
     */
    where?: caregiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caregivers to fetch.
     */
    orderBy?: caregiversOrderByWithRelationInput | caregiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caregivers.
     */
    cursor?: caregiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caregivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caregivers.
     */
    distinct?: CaregiversScalarFieldEnum | CaregiversScalarFieldEnum[]
  }

  /**
   * caregivers findMany
   */
  export type caregiversFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * Filter, which caregivers to fetch.
     */
    where?: caregiversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caregivers to fetch.
     */
    orderBy?: caregiversOrderByWithRelationInput | caregiversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caregivers.
     */
    cursor?: caregiversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caregivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caregivers.
     */
    skip?: number
    distinct?: CaregiversScalarFieldEnum | CaregiversScalarFieldEnum[]
  }

  /**
   * caregivers create
   */
  export type caregiversCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * The data needed to create a caregivers.
     */
    data: XOR<caregiversCreateInput, caregiversUncheckedCreateInput>
  }

  /**
   * caregivers createMany
   */
  export type caregiversCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caregivers.
     */
    data: caregiversCreateManyInput | caregiversCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * caregivers createManyAndReturn
   */
  export type caregiversCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * The data used to create many caregivers.
     */
    data: caregiversCreateManyInput | caregiversCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * caregivers update
   */
  export type caregiversUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * The data needed to update a caregivers.
     */
    data: XOR<caregiversUpdateInput, caregiversUncheckedUpdateInput>
    /**
     * Choose, which caregivers to update.
     */
    where: caregiversWhereUniqueInput
  }

  /**
   * caregivers updateMany
   */
  export type caregiversUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caregivers.
     */
    data: XOR<caregiversUpdateManyMutationInput, caregiversUncheckedUpdateManyInput>
    /**
     * Filter which caregivers to update
     */
    where?: caregiversWhereInput
    /**
     * Limit how many caregivers to update.
     */
    limit?: number
  }

  /**
   * caregivers updateManyAndReturn
   */
  export type caregiversUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * The data used to update caregivers.
     */
    data: XOR<caregiversUpdateManyMutationInput, caregiversUncheckedUpdateManyInput>
    /**
     * Filter which caregivers to update
     */
    where?: caregiversWhereInput
    /**
     * Limit how many caregivers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * caregivers upsert
   */
  export type caregiversUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * The filter to search for the caregivers to update in case it exists.
     */
    where: caregiversWhereUniqueInput
    /**
     * In case the caregivers found by the `where` argument doesn't exist, create a new caregivers with this data.
     */
    create: XOR<caregiversCreateInput, caregiversUncheckedCreateInput>
    /**
     * In case the caregivers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<caregiversUpdateInput, caregiversUncheckedUpdateInput>
  }

  /**
   * caregivers delete
   */
  export type caregiversDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    /**
     * Filter which caregivers to delete.
     */
    where: caregiversWhereUniqueInput
  }

  /**
   * caregivers deleteMany
   */
  export type caregiversDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which caregivers to delete
     */
    where?: caregiversWhereInput
    /**
     * Limit how many caregivers to delete.
     */
    limit?: number
  }

  /**
   * caregivers.assignments_assignments_replaced_byTocaregivers
   */
  export type caregivers$assignments_assignments_replaced_byTocaregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    where?: assignmentsWhereInput
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    cursor?: assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * caregivers.assignments_assignments_caregiver_idTocaregivers
   */
  export type caregivers$assignments_assignments_caregiver_idTocaregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    where?: assignmentsWhereInput
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    cursor?: assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * caregivers.care_logs
   */
  export type caregivers$care_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    where?: care_logsWhereInput
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    cursor?: care_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Care_logsScalarFieldEnum | Care_logsScalarFieldEnum[]
  }

  /**
   * caregivers.companies
   */
  export type caregivers$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * caregivers.job_applications
   */
  export type caregivers$job_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    where?: job_applicationsWhereInput
    orderBy?: job_applicationsOrderByWithRelationInput | job_applicationsOrderByWithRelationInput[]
    cursor?: job_applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_applicationsScalarFieldEnum | Job_applicationsScalarFieldEnum[]
  }

  /**
   * caregivers.marketplace_jobs
   */
  export type caregivers$marketplace_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    where?: marketplace_jobsWhereInput
    orderBy?: marketplace_jobsOrderByWithRelationInput | marketplace_jobsOrderByWithRelationInput[]
    cursor?: marketplace_jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Marketplace_jobsScalarFieldEnum | Marketplace_jobsScalarFieldEnum[]
  }

  /**
   * caregivers without action
   */
  export type caregiversDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    commission_rate: Decimal | null
    rating_avg: Decimal | null
    rating_count: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    commission_rate: Decimal | null
    rating_avg: Decimal | null
    rating_count: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    company_name: string | null
    trade_license: string | null
    trade_license_url: string | null
    tin: string | null
    contact_person: string | null
    contact_phone: string | null
    contact_email: string | null
    address: string | null
    logo_url: string | null
    description: string | null
    payout_method: $Enums.PayoutMethod | null
    payout_account: string | null
    commission_rate: Decimal | null
    subscription_tier: $Enums.SubscriptionTier | null
    subscription_expires_at: Date | null
    rating_avg: Decimal | null
    rating_count: number | null
    is_verified: boolean | null
    verification_notes: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    company_name: string | null
    trade_license: string | null
    trade_license_url: string | null
    tin: string | null
    contact_person: string | null
    contact_phone: string | null
    contact_email: string | null
    address: string | null
    logo_url: string | null
    description: string | null
    payout_method: $Enums.PayoutMethod | null
    payout_account: string | null
    commission_rate: Decimal | null
    subscription_tier: $Enums.SubscriptionTier | null
    subscription_expires_at: Date | null
    rating_avg: Decimal | null
    rating_count: number | null
    is_verified: boolean | null
    verification_notes: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    userId: number
    company_name: number
    trade_license: number
    trade_license_url: number
    tin: number
    contact_person: number
    contact_phone: number
    contact_email: number
    address: number
    logo_url: number
    description: number
    specializations: number
    payout_method: number
    payout_account: number
    commission_rate: number
    subscription_tier: number
    subscription_expires_at: number
    rating_avg: number
    rating_count: number
    is_verified: number
    verification_notes: number
    deleted_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    commission_rate?: true
    rating_avg?: true
    rating_count?: true
  }

  export type CompaniesSumAggregateInputType = {
    commission_rate?: true
    rating_avg?: true
    rating_count?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    userId?: true
    company_name?: true
    trade_license?: true
    trade_license_url?: true
    tin?: true
    contact_person?: true
    contact_phone?: true
    contact_email?: true
    address?: true
    logo_url?: true
    description?: true
    payout_method?: true
    payout_account?: true
    commission_rate?: true
    subscription_tier?: true
    subscription_expires_at?: true
    rating_avg?: true
    rating_count?: true
    is_verified?: true
    verification_notes?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    userId?: true
    company_name?: true
    trade_license?: true
    trade_license_url?: true
    tin?: true
    contact_person?: true
    contact_phone?: true
    contact_email?: true
    address?: true
    logo_url?: true
    description?: true
    payout_method?: true
    payout_account?: true
    commission_rate?: true
    subscription_tier?: true
    subscription_expires_at?: true
    rating_avg?: true
    rating_count?: true
    is_verified?: true
    verification_notes?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    userId?: true
    company_name?: true
    trade_license?: true
    trade_license_url?: true
    tin?: true
    contact_person?: true
    contact_phone?: true
    contact_email?: true
    address?: true
    logo_url?: true
    description?: true
    specializations?: true
    payout_method?: true
    payout_account?: true
    commission_rate?: true
    subscription_tier?: true
    subscription_expires_at?: true
    rating_avg?: true
    rating_count?: true
    is_verified?: true
    verification_notes?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url: string | null
    tin: string | null
    contact_person: string
    contact_phone: string
    contact_email: string | null
    address: string
    logo_url: string | null
    description: string | null
    specializations: JsonValue | null
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate: Decimal
    subscription_tier: $Enums.SubscriptionTier
    subscription_expires_at: Date | null
    rating_avg: Decimal
    rating_count: number
    is_verified: boolean
    verification_notes: string | null
    deleted_at: Date | null
    created_at: Date
    updated_at: Date
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company_name?: boolean
    trade_license?: boolean
    trade_license_url?: boolean
    tin?: boolean
    contact_person?: boolean
    contact_phone?: boolean
    contact_email?: boolean
    address?: boolean
    logo_url?: boolean
    description?: boolean
    specializations?: boolean
    payout_method?: boolean
    payout_account?: boolean
    commission_rate?: boolean
    subscription_tier?: boolean
    subscription_expires_at?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    caregivers?: boolean | companies$caregiversArgs<ExtArgs>
    jobs?: boolean | companies$jobsArgs<ExtArgs>
    marketplace_jobs?: boolean | companies$marketplace_jobsArgs<ExtArgs>
    packages?: boolean | companies$packagesArgs<ExtArgs>
    service_zones?: boolean | companies$service_zonesArgs<ExtArgs>
    users?: boolean | companies$usersArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company_name?: boolean
    trade_license?: boolean
    trade_license_url?: boolean
    tin?: boolean
    contact_person?: boolean
    contact_phone?: boolean
    contact_email?: boolean
    address?: boolean
    logo_url?: boolean
    description?: boolean
    specializations?: boolean
    payout_method?: boolean
    payout_account?: boolean
    commission_rate?: boolean
    subscription_tier?: boolean
    subscription_expires_at?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company_name?: boolean
    trade_license?: boolean
    trade_license_url?: boolean
    tin?: boolean
    contact_person?: boolean
    contact_phone?: boolean
    contact_email?: boolean
    address?: boolean
    logo_url?: boolean
    description?: boolean
    specializations?: boolean
    payout_method?: boolean
    payout_account?: boolean
    commission_rate?: boolean
    subscription_tier?: boolean
    subscription_expires_at?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    userId?: boolean
    company_name?: boolean
    trade_license?: boolean
    trade_license_url?: boolean
    tin?: boolean
    contact_person?: boolean
    contact_phone?: boolean
    contact_email?: boolean
    address?: boolean
    logo_url?: boolean
    description?: boolean
    specializations?: boolean
    payout_method?: boolean
    payout_account?: boolean
    commission_rate?: boolean
    subscription_tier?: boolean
    subscription_expires_at?: boolean
    rating_avg?: boolean
    rating_count?: boolean
    is_verified?: boolean
    verification_notes?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "company_name" | "trade_license" | "trade_license_url" | "tin" | "contact_person" | "contact_phone" | "contact_email" | "address" | "logo_url" | "description" | "specializations" | "payout_method" | "payout_account" | "commission_rate" | "subscription_tier" | "subscription_expires_at" | "rating_avg" | "rating_count" | "is_verified" | "verification_notes" | "deleted_at" | "created_at" | "updated_at", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers?: boolean | companies$caregiversArgs<ExtArgs>
    jobs?: boolean | companies$jobsArgs<ExtArgs>
    marketplace_jobs?: boolean | companies$marketplace_jobsArgs<ExtArgs>
    packages?: boolean | companies$packagesArgs<ExtArgs>
    service_zones?: boolean | companies$service_zonesArgs<ExtArgs>
    users?: boolean | companies$usersArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      caregivers: Prisma.$caregiversPayload<ExtArgs>[]
      jobs: Prisma.$jobsPayload<ExtArgs>[]
      marketplace_jobs: Prisma.$marketplace_jobsPayload<ExtArgs>[]
      packages: Prisma.$packagesPayload<ExtArgs>[]
      service_zones: Prisma.$service_zonesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      company_name: string
      trade_license: string
      trade_license_url: string | null
      tin: string | null
      contact_person: string
      contact_phone: string
      contact_email: string | null
      address: string
      logo_url: string | null
      description: string | null
      specializations: Prisma.JsonValue | null
      payout_method: $Enums.PayoutMethod
      payout_account: string
      commission_rate: Prisma.Decimal
      subscription_tier: $Enums.SubscriptionTier
      subscription_expires_at: Date | null
      rating_avg: Prisma.Decimal
      rating_count: number
      is_verified: boolean
      verification_notes: string | null
      deleted_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caregivers<T extends companies$caregiversArgs<ExtArgs> = {}>(args?: Subset<T, companies$caregiversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends companies$jobsArgs<ExtArgs> = {}>(args?: Subset<T, companies$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    marketplace_jobs<T extends companies$marketplace_jobsArgs<ExtArgs> = {}>(args?: Subset<T, companies$marketplace_jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packages<T extends companies$packagesArgs<ExtArgs> = {}>(args?: Subset<T, companies$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_zones<T extends companies$service_zonesArgs<ExtArgs> = {}>(args?: Subset<T, companies$service_zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends companies$usersArgs<ExtArgs> = {}>(args?: Subset<T, companies$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'String'>
    readonly userId: FieldRef<"companies", 'String'>
    readonly company_name: FieldRef<"companies", 'String'>
    readonly trade_license: FieldRef<"companies", 'String'>
    readonly trade_license_url: FieldRef<"companies", 'String'>
    readonly tin: FieldRef<"companies", 'String'>
    readonly contact_person: FieldRef<"companies", 'String'>
    readonly contact_phone: FieldRef<"companies", 'String'>
    readonly contact_email: FieldRef<"companies", 'String'>
    readonly address: FieldRef<"companies", 'String'>
    readonly logo_url: FieldRef<"companies", 'String'>
    readonly description: FieldRef<"companies", 'String'>
    readonly specializations: FieldRef<"companies", 'Json'>
    readonly payout_method: FieldRef<"companies", 'PayoutMethod'>
    readonly payout_account: FieldRef<"companies", 'String'>
    readonly commission_rate: FieldRef<"companies", 'Decimal'>
    readonly subscription_tier: FieldRef<"companies", 'SubscriptionTier'>
    readonly subscription_expires_at: FieldRef<"companies", 'DateTime'>
    readonly rating_avg: FieldRef<"companies", 'Decimal'>
    readonly rating_count: FieldRef<"companies", 'Int'>
    readonly is_verified: FieldRef<"companies", 'Boolean'>
    readonly verification_notes: FieldRef<"companies", 'String'>
    readonly deleted_at: FieldRef<"companies", 'DateTime'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
    readonly updated_at: FieldRef<"companies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.caregivers
   */
  export type companies$caregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    where?: caregiversWhereInput
    orderBy?: caregiversOrderByWithRelationInput | caregiversOrderByWithRelationInput[]
    cursor?: caregiversWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaregiversScalarFieldEnum | CaregiversScalarFieldEnum[]
  }

  /**
   * companies.jobs
   */
  export type companies$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    cursor?: jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * companies.marketplace_jobs
   */
  export type companies$marketplace_jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    where?: marketplace_jobsWhereInput
    orderBy?: marketplace_jobsOrderByWithRelationInput | marketplace_jobsOrderByWithRelationInput[]
    cursor?: marketplace_jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Marketplace_jobsScalarFieldEnum | Marketplace_jobsScalarFieldEnum[]
  }

  /**
   * companies.packages
   */
  export type companies$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    where?: packagesWhereInput
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    cursor?: packagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * companies.service_zones
   */
  export type companies$service_zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    where?: service_zonesWhereInput
    orderBy?: service_zonesOrderByWithRelationInput | service_zonesOrderByWithRelationInput[]
    cursor?: service_zonesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Service_zonesScalarFieldEnum | Service_zonesScalarFieldEnum[]
  }

  /**
   * companies.users
   */
  export type companies$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model disputes
   */

  export type AggregateDisputes = {
    _count: DisputesCountAggregateOutputType | null
    _min: DisputesMinAggregateOutputType | null
    _max: DisputesMaxAggregateOutputType | null
  }

  export type DisputesMinAggregateOutputType = {
    id: string | null
    job_id: string | null
    raised_by: string | null
    against: string | null
    dispute_type: $Enums.DisputeType | null
    description: string | null
    status: $Enums.DisputeStatus | null
    assigned_moderator: string | null
    resolution: string | null
    resolution_action: string | null
    resolved_at: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputesMaxAggregateOutputType = {
    id: string | null
    job_id: string | null
    raised_by: string | null
    against: string | null
    dispute_type: $Enums.DisputeType | null
    description: string | null
    status: $Enums.DisputeStatus | null
    assigned_moderator: string | null
    resolution: string | null
    resolution_action: string | null
    resolved_at: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputesCountAggregateOutputType = {
    id: number
    job_id: number
    raised_by: number
    against: number
    dispute_type: number
    description: number
    evidence_urls: number
    status: number
    assigned_moderator: number
    resolution: number
    resolution_action: number
    resolved_at: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisputesMinAggregateInputType = {
    id?: true
    job_id?: true
    raised_by?: true
    against?: true
    dispute_type?: true
    description?: true
    status?: true
    assigned_moderator?: true
    resolution?: true
    resolution_action?: true
    resolved_at?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputesMaxAggregateInputType = {
    id?: true
    job_id?: true
    raised_by?: true
    against?: true
    dispute_type?: true
    description?: true
    status?: true
    assigned_moderator?: true
    resolution?: true
    resolution_action?: true
    resolved_at?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputesCountAggregateInputType = {
    id?: true
    job_id?: true
    raised_by?: true
    against?: true
    dispute_type?: true
    description?: true
    evidence_urls?: true
    status?: true
    assigned_moderator?: true
    resolution?: true
    resolution_action?: true
    resolved_at?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisputesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disputes to aggregate.
     */
    where?: disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disputes to fetch.
     */
    orderBy?: disputesOrderByWithRelationInput | disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned disputes
    **/
    _count?: true | DisputesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputesMaxAggregateInputType
  }

  export type GetDisputesAggregateType<T extends DisputesAggregateArgs> = {
        [P in keyof T & keyof AggregateDisputes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisputes[P]>
      : GetScalarType<T[P], AggregateDisputes[P]>
  }




  export type disputesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disputesWhereInput
    orderBy?: disputesOrderByWithAggregationInput | disputesOrderByWithAggregationInput[]
    by: DisputesScalarFieldEnum[] | DisputesScalarFieldEnum
    having?: disputesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputesCountAggregateInputType | true
    _min?: DisputesMinAggregateInputType
    _max?: DisputesMaxAggregateInputType
  }

  export type DisputesGroupByOutputType = {
    id: string
    job_id: string
    raised_by: string
    against: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls: JsonValue | null
    status: $Enums.DisputeStatus
    assigned_moderator: string | null
    resolution: string | null
    resolution_action: string | null
    resolved_at: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DisputesCountAggregateOutputType | null
    _min: DisputesMinAggregateOutputType | null
    _max: DisputesMaxAggregateOutputType | null
  }

  type GetDisputesGroupByPayload<T extends disputesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputesGroupByOutputType[P]>
            : GetScalarType<T[P], DisputesGroupByOutputType[P]>
        }
      >
    >


  export type disputesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    raised_by?: boolean
    against?: boolean
    dispute_type?: boolean
    description?: boolean
    evidence_urls?: boolean
    status?: boolean
    assigned_moderator?: boolean
    resolution?: boolean
    resolution_action?: boolean
    resolved_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_disputes_againstTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_disputes_raised_byTousers?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputes"]>

  export type disputesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    raised_by?: boolean
    against?: boolean
    dispute_type?: boolean
    description?: boolean
    evidence_urls?: boolean
    status?: boolean
    assigned_moderator?: boolean
    resolution?: boolean
    resolution_action?: boolean
    resolved_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_disputes_againstTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_disputes_raised_byTousers?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputes"]>

  export type disputesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    raised_by?: boolean
    against?: boolean
    dispute_type?: boolean
    description?: boolean
    evidence_urls?: boolean
    status?: boolean
    assigned_moderator?: boolean
    resolution?: boolean
    resolution_action?: boolean
    resolved_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_disputes_againstTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_disputes_raised_byTousers?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputes"]>

  export type disputesSelectScalar = {
    id?: boolean
    job_id?: boolean
    raised_by?: boolean
    against?: boolean
    dispute_type?: boolean
    description?: boolean
    evidence_urls?: boolean
    status?: boolean
    assigned_moderator?: boolean
    resolution?: boolean
    resolution_action?: boolean
    resolved_at?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type disputesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "raised_by" | "against" | "dispute_type" | "description" | "evidence_urls" | "status" | "assigned_moderator" | "resolution" | "resolution_action" | "resolved_at" | "createdAt" | "updatedAt", ExtArgs["result"]["disputes"]>
  export type disputesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_disputes_againstTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_disputes_raised_byTousers?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type disputesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_disputes_againstTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_disputes_raised_byTousers?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type disputesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_disputes_againstTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_disputes_raised_byTousers?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $disputesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "disputes"
    objects: {
      users_disputes_againstTousers: Prisma.$usersPayload<ExtArgs>
      users_disputes_raised_byTousers: Prisma.$usersPayload<ExtArgs>
      jobs: Prisma.$jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_id: string
      raised_by: string
      against: string
      dispute_type: $Enums.DisputeType
      description: string
      evidence_urls: Prisma.JsonValue | null
      status: $Enums.DisputeStatus
      assigned_moderator: string | null
      resolution: string | null
      resolution_action: string | null
      resolved_at: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["disputes"]>
    composites: {}
  }

  type disputesGetPayload<S extends boolean | null | undefined | disputesDefaultArgs> = $Result.GetResult<Prisma.$disputesPayload, S>

  type disputesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<disputesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisputesCountAggregateInputType | true
    }

  export interface disputesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['disputes'], meta: { name: 'disputes' } }
    /**
     * Find zero or one Disputes that matches the filter.
     * @param {disputesFindUniqueArgs} args - Arguments to find a Disputes
     * @example
     * // Get one Disputes
     * const disputes = await prisma.disputes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends disputesFindUniqueArgs>(args: SelectSubset<T, disputesFindUniqueArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Disputes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {disputesFindUniqueOrThrowArgs} args - Arguments to find a Disputes
     * @example
     * // Get one Disputes
     * const disputes = await prisma.disputes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends disputesFindUniqueOrThrowArgs>(args: SelectSubset<T, disputesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disputesFindFirstArgs} args - Arguments to find a Disputes
     * @example
     * // Get one Disputes
     * const disputes = await prisma.disputes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends disputesFindFirstArgs>(args?: SelectSubset<T, disputesFindFirstArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Disputes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disputesFindFirstOrThrowArgs} args - Arguments to find a Disputes
     * @example
     * // Get one Disputes
     * const disputes = await prisma.disputes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends disputesFindFirstOrThrowArgs>(args?: SelectSubset<T, disputesFindFirstOrThrowArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disputesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disputes
     * const disputes = await prisma.disputes.findMany()
     * 
     * // Get first 10 Disputes
     * const disputes = await prisma.disputes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disputesWithIdOnly = await prisma.disputes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends disputesFindManyArgs>(args?: SelectSubset<T, disputesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Disputes.
     * @param {disputesCreateArgs} args - Arguments to create a Disputes.
     * @example
     * // Create one Disputes
     * const Disputes = await prisma.disputes.create({
     *   data: {
     *     // ... data to create a Disputes
     *   }
     * })
     * 
     */
    create<T extends disputesCreateArgs>(args: SelectSubset<T, disputesCreateArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Disputes.
     * @param {disputesCreateManyArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const disputes = await prisma.disputes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends disputesCreateManyArgs>(args?: SelectSubset<T, disputesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Disputes and returns the data saved in the database.
     * @param {disputesCreateManyAndReturnArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const disputes = await prisma.disputes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Disputes and only return the `id`
     * const disputesWithIdOnly = await prisma.disputes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends disputesCreateManyAndReturnArgs>(args?: SelectSubset<T, disputesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Disputes.
     * @param {disputesDeleteArgs} args - Arguments to delete one Disputes.
     * @example
     * // Delete one Disputes
     * const Disputes = await prisma.disputes.delete({
     *   where: {
     *     // ... filter to delete one Disputes
     *   }
     * })
     * 
     */
    delete<T extends disputesDeleteArgs>(args: SelectSubset<T, disputesDeleteArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Disputes.
     * @param {disputesUpdateArgs} args - Arguments to update one Disputes.
     * @example
     * // Update one Disputes
     * const disputes = await prisma.disputes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends disputesUpdateArgs>(args: SelectSubset<T, disputesUpdateArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Disputes.
     * @param {disputesDeleteManyArgs} args - Arguments to filter Disputes to delete.
     * @example
     * // Delete a few Disputes
     * const { count } = await prisma.disputes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends disputesDeleteManyArgs>(args?: SelectSubset<T, disputesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disputesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disputes
     * const disputes = await prisma.disputes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends disputesUpdateManyArgs>(args: SelectSubset<T, disputesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes and returns the data updated in the database.
     * @param {disputesUpdateManyAndReturnArgs} args - Arguments to update many Disputes.
     * @example
     * // Update many Disputes
     * const disputes = await prisma.disputes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Disputes and only return the `id`
     * const disputesWithIdOnly = await prisma.disputes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends disputesUpdateManyAndReturnArgs>(args: SelectSubset<T, disputesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Disputes.
     * @param {disputesUpsertArgs} args - Arguments to update or create a Disputes.
     * @example
     * // Update or create a Disputes
     * const disputes = await prisma.disputes.upsert({
     *   create: {
     *     // ... data to create a Disputes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Disputes we want to update
     *   }
     * })
     */
    upsert<T extends disputesUpsertArgs>(args: SelectSubset<T, disputesUpsertArgs<ExtArgs>>): Prisma__disputesClient<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disputesCountArgs} args - Arguments to filter Disputes to count.
     * @example
     * // Count the number of Disputes
     * const count = await prisma.disputes.count({
     *   where: {
     *     // ... the filter for the Disputes we want to count
     *   }
     * })
    **/
    count<T extends disputesCountArgs>(
      args?: Subset<T, disputesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputesAggregateArgs>(args: Subset<T, DisputesAggregateArgs>): Prisma.PrismaPromise<GetDisputesAggregateType<T>>

    /**
     * Group by Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disputesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends disputesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: disputesGroupByArgs['orderBy'] }
        : { orderBy?: disputesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, disputesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the disputes model
   */
  readonly fields: disputesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for disputes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__disputesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_disputes_againstTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_disputes_raised_byTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the disputes model
   */
  interface disputesFieldRefs {
    readonly id: FieldRef<"disputes", 'String'>
    readonly job_id: FieldRef<"disputes", 'String'>
    readonly raised_by: FieldRef<"disputes", 'String'>
    readonly against: FieldRef<"disputes", 'String'>
    readonly dispute_type: FieldRef<"disputes", 'DisputeType'>
    readonly description: FieldRef<"disputes", 'String'>
    readonly evidence_urls: FieldRef<"disputes", 'Json'>
    readonly status: FieldRef<"disputes", 'DisputeStatus'>
    readonly assigned_moderator: FieldRef<"disputes", 'String'>
    readonly resolution: FieldRef<"disputes", 'String'>
    readonly resolution_action: FieldRef<"disputes", 'String'>
    readonly resolved_at: FieldRef<"disputes", 'DateTime'>
    readonly createdAt: FieldRef<"disputes", 'DateTime'>
    readonly updatedAt: FieldRef<"disputes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * disputes findUnique
   */
  export type disputesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * Filter, which disputes to fetch.
     */
    where: disputesWhereUniqueInput
  }

  /**
   * disputes findUniqueOrThrow
   */
  export type disputesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * Filter, which disputes to fetch.
     */
    where: disputesWhereUniqueInput
  }

  /**
   * disputes findFirst
   */
  export type disputesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * Filter, which disputes to fetch.
     */
    where?: disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disputes to fetch.
     */
    orderBy?: disputesOrderByWithRelationInput | disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disputes.
     */
    cursor?: disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disputes.
     */
    distinct?: DisputesScalarFieldEnum | DisputesScalarFieldEnum[]
  }

  /**
   * disputes findFirstOrThrow
   */
  export type disputesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * Filter, which disputes to fetch.
     */
    where?: disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disputes to fetch.
     */
    orderBy?: disputesOrderByWithRelationInput | disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disputes.
     */
    cursor?: disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disputes.
     */
    distinct?: DisputesScalarFieldEnum | DisputesScalarFieldEnum[]
  }

  /**
   * disputes findMany
   */
  export type disputesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * Filter, which disputes to fetch.
     */
    where?: disputesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disputes to fetch.
     */
    orderBy?: disputesOrderByWithRelationInput | disputesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing disputes.
     */
    cursor?: disputesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disputes.
     */
    skip?: number
    distinct?: DisputesScalarFieldEnum | DisputesScalarFieldEnum[]
  }

  /**
   * disputes create
   */
  export type disputesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * The data needed to create a disputes.
     */
    data: XOR<disputesCreateInput, disputesUncheckedCreateInput>
  }

  /**
   * disputes createMany
   */
  export type disputesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many disputes.
     */
    data: disputesCreateManyInput | disputesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * disputes createManyAndReturn
   */
  export type disputesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * The data used to create many disputes.
     */
    data: disputesCreateManyInput | disputesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * disputes update
   */
  export type disputesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * The data needed to update a disputes.
     */
    data: XOR<disputesUpdateInput, disputesUncheckedUpdateInput>
    /**
     * Choose, which disputes to update.
     */
    where: disputesWhereUniqueInput
  }

  /**
   * disputes updateMany
   */
  export type disputesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update disputes.
     */
    data: XOR<disputesUpdateManyMutationInput, disputesUncheckedUpdateManyInput>
    /**
     * Filter which disputes to update
     */
    where?: disputesWhereInput
    /**
     * Limit how many disputes to update.
     */
    limit?: number
  }

  /**
   * disputes updateManyAndReturn
   */
  export type disputesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * The data used to update disputes.
     */
    data: XOR<disputesUpdateManyMutationInput, disputesUncheckedUpdateManyInput>
    /**
     * Filter which disputes to update
     */
    where?: disputesWhereInput
    /**
     * Limit how many disputes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * disputes upsert
   */
  export type disputesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * The filter to search for the disputes to update in case it exists.
     */
    where: disputesWhereUniqueInput
    /**
     * In case the disputes found by the `where` argument doesn't exist, create a new disputes with this data.
     */
    create: XOR<disputesCreateInput, disputesUncheckedCreateInput>
    /**
     * In case the disputes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<disputesUpdateInput, disputesUncheckedUpdateInput>
  }

  /**
   * disputes delete
   */
  export type disputesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    /**
     * Filter which disputes to delete.
     */
    where: disputesWhereUniqueInput
  }

  /**
   * disputes deleteMany
   */
  export type disputesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disputes to delete
     */
    where?: disputesWhereInput
    /**
     * Limit how many disputes to delete.
     */
    limit?: number
  }

  /**
   * disputes without action
   */
  export type disputesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
  }


  /**
   * Model escrows
   */

  export type AggregateEscrows = {
    _count: EscrowsCountAggregateOutputType | null
    _avg: EscrowsAvgAggregateOutputType | null
    _sum: EscrowsSumAggregateOutputType | null
    _min: EscrowsMinAggregateOutputType | null
    _max: EscrowsMaxAggregateOutputType | null
  }

  export type EscrowsAvgAggregateOutputType = {
    amount: Decimal | null
    fee: Decimal | null
  }

  export type EscrowsSumAggregateOutputType = {
    amount: Decimal | null
    fee: Decimal | null
  }

  export type EscrowsMinAggregateOutputType = {
    id: string | null
    payment_id: string | null
    amount: Decimal | null
    fee: Decimal | null
    status: string | null
    released_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EscrowsMaxAggregateOutputType = {
    id: string | null
    payment_id: string | null
    amount: Decimal | null
    fee: Decimal | null
    status: string | null
    released_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EscrowsCountAggregateOutputType = {
    id: number
    payment_id: number
    amount: number
    fee: number
    status: number
    released_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EscrowsAvgAggregateInputType = {
    amount?: true
    fee?: true
  }

  export type EscrowsSumAggregateInputType = {
    amount?: true
    fee?: true
  }

  export type EscrowsMinAggregateInputType = {
    id?: true
    payment_id?: true
    amount?: true
    fee?: true
    status?: true
    released_at?: true
    created_at?: true
    updated_at?: true
  }

  export type EscrowsMaxAggregateInputType = {
    id?: true
    payment_id?: true
    amount?: true
    fee?: true
    status?: true
    released_at?: true
    created_at?: true
    updated_at?: true
  }

  export type EscrowsCountAggregateInputType = {
    id?: true
    payment_id?: true
    amount?: true
    fee?: true
    status?: true
    released_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EscrowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escrows to aggregate.
     */
    where?: escrowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrows to fetch.
     */
    orderBy?: escrowsOrderByWithRelationInput | escrowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: escrowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned escrows
    **/
    _count?: true | EscrowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscrowsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscrowsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscrowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscrowsMaxAggregateInputType
  }

  export type GetEscrowsAggregateType<T extends EscrowsAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrows[P]>
      : GetScalarType<T[P], AggregateEscrows[P]>
  }




  export type escrowsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escrowsWhereInput
    orderBy?: escrowsOrderByWithAggregationInput | escrowsOrderByWithAggregationInput[]
    by: EscrowsScalarFieldEnum[] | EscrowsScalarFieldEnum
    having?: escrowsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscrowsCountAggregateInputType | true
    _avg?: EscrowsAvgAggregateInputType
    _sum?: EscrowsSumAggregateInputType
    _min?: EscrowsMinAggregateInputType
    _max?: EscrowsMaxAggregateInputType
  }

  export type EscrowsGroupByOutputType = {
    id: string
    payment_id: string
    amount: Decimal
    fee: Decimal
    status: string
    released_at: Date | null
    created_at: Date
    updated_at: Date
    _count: EscrowsCountAggregateOutputType | null
    _avg: EscrowsAvgAggregateOutputType | null
    _sum: EscrowsSumAggregateOutputType | null
    _min: EscrowsMinAggregateOutputType | null
    _max: EscrowsMaxAggregateOutputType | null
  }

  type GetEscrowsGroupByPayload<T extends escrowsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscrowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscrowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscrowsGroupByOutputType[P]>
            : GetScalarType<T[P], EscrowsGroupByOutputType[P]>
        }
      >
    >


  export type escrowsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_id?: boolean
    amount?: boolean
    fee?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrows"]>

  export type escrowsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_id?: boolean
    amount?: boolean
    fee?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrows"]>

  export type escrowsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payment_id?: boolean
    amount?: boolean
    fee?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrows"]>

  export type escrowsSelectScalar = {
    id?: boolean
    payment_id?: boolean
    amount?: boolean
    fee?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type escrowsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "payment_id" | "amount" | "fee" | "status" | "released_at" | "created_at" | "updated_at", ExtArgs["result"]["escrows"]>
  export type escrowsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
  }
  export type escrowsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
  }
  export type escrowsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
  }

  export type $escrowsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "escrows"
    objects: {
      payments: Prisma.$paymentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      payment_id: string
      amount: Prisma.Decimal
      fee: Prisma.Decimal
      status: string
      released_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["escrows"]>
    composites: {}
  }

  type escrowsGetPayload<S extends boolean | null | undefined | escrowsDefaultArgs> = $Result.GetResult<Prisma.$escrowsPayload, S>

  type escrowsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<escrowsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EscrowsCountAggregateInputType | true
    }

  export interface escrowsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['escrows'], meta: { name: 'escrows' } }
    /**
     * Find zero or one Escrows that matches the filter.
     * @param {escrowsFindUniqueArgs} args - Arguments to find a Escrows
     * @example
     * // Get one Escrows
     * const escrows = await prisma.escrows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends escrowsFindUniqueArgs>(args: SelectSubset<T, escrowsFindUniqueArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Escrows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {escrowsFindUniqueOrThrowArgs} args - Arguments to find a Escrows
     * @example
     * // Get one Escrows
     * const escrows = await prisma.escrows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends escrowsFindUniqueOrThrowArgs>(args: SelectSubset<T, escrowsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrowsFindFirstArgs} args - Arguments to find a Escrows
     * @example
     * // Get one Escrows
     * const escrows = await prisma.escrows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends escrowsFindFirstArgs>(args?: SelectSubset<T, escrowsFindFirstArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escrows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrowsFindFirstOrThrowArgs} args - Arguments to find a Escrows
     * @example
     * // Get one Escrows
     * const escrows = await prisma.escrows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends escrowsFindFirstOrThrowArgs>(args?: SelectSubset<T, escrowsFindFirstOrThrowArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Escrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrowsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escrows
     * const escrows = await prisma.escrows.findMany()
     * 
     * // Get first 10 Escrows
     * const escrows = await prisma.escrows.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrowsWithIdOnly = await prisma.escrows.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends escrowsFindManyArgs>(args?: SelectSubset<T, escrowsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Escrows.
     * @param {escrowsCreateArgs} args - Arguments to create a Escrows.
     * @example
     * // Create one Escrows
     * const Escrows = await prisma.escrows.create({
     *   data: {
     *     // ... data to create a Escrows
     *   }
     * })
     * 
     */
    create<T extends escrowsCreateArgs>(args: SelectSubset<T, escrowsCreateArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Escrows.
     * @param {escrowsCreateManyArgs} args - Arguments to create many Escrows.
     * @example
     * // Create many Escrows
     * const escrows = await prisma.escrows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends escrowsCreateManyArgs>(args?: SelectSubset<T, escrowsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escrows and returns the data saved in the database.
     * @param {escrowsCreateManyAndReturnArgs} args - Arguments to create many Escrows.
     * @example
     * // Create many Escrows
     * const escrows = await prisma.escrows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escrows and only return the `id`
     * const escrowsWithIdOnly = await prisma.escrows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends escrowsCreateManyAndReturnArgs>(args?: SelectSubset<T, escrowsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Escrows.
     * @param {escrowsDeleteArgs} args - Arguments to delete one Escrows.
     * @example
     * // Delete one Escrows
     * const Escrows = await prisma.escrows.delete({
     *   where: {
     *     // ... filter to delete one Escrows
     *   }
     * })
     * 
     */
    delete<T extends escrowsDeleteArgs>(args: SelectSubset<T, escrowsDeleteArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Escrows.
     * @param {escrowsUpdateArgs} args - Arguments to update one Escrows.
     * @example
     * // Update one Escrows
     * const escrows = await prisma.escrows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends escrowsUpdateArgs>(args: SelectSubset<T, escrowsUpdateArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Escrows.
     * @param {escrowsDeleteManyArgs} args - Arguments to filter Escrows to delete.
     * @example
     * // Delete a few Escrows
     * const { count } = await prisma.escrows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends escrowsDeleteManyArgs>(args?: SelectSubset<T, escrowsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escrows
     * const escrows = await prisma.escrows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends escrowsUpdateManyArgs>(args: SelectSubset<T, escrowsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrows and returns the data updated in the database.
     * @param {escrowsUpdateManyAndReturnArgs} args - Arguments to update many Escrows.
     * @example
     * // Update many Escrows
     * const escrows = await prisma.escrows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Escrows and only return the `id`
     * const escrowsWithIdOnly = await prisma.escrows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends escrowsUpdateManyAndReturnArgs>(args: SelectSubset<T, escrowsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Escrows.
     * @param {escrowsUpsertArgs} args - Arguments to update or create a Escrows.
     * @example
     * // Update or create a Escrows
     * const escrows = await prisma.escrows.upsert({
     *   create: {
     *     // ... data to create a Escrows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escrows we want to update
     *   }
     * })
     */
    upsert<T extends escrowsUpsertArgs>(args: SelectSubset<T, escrowsUpsertArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrowsCountArgs} args - Arguments to filter Escrows to count.
     * @example
     * // Count the number of Escrows
     * const count = await prisma.escrows.count({
     *   where: {
     *     // ... the filter for the Escrows we want to count
     *   }
     * })
    **/
    count<T extends escrowsCountArgs>(
      args?: Subset<T, escrowsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscrowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscrowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscrowsAggregateArgs>(args: Subset<T, EscrowsAggregateArgs>): Prisma.PrismaPromise<GetEscrowsAggregateType<T>>

    /**
     * Group by Escrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends escrowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: escrowsGroupByArgs['orderBy'] }
        : { orderBy?: escrowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, escrowsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the escrows model
   */
  readonly fields: escrowsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for escrows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__escrowsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends paymentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paymentsDefaultArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the escrows model
   */
  interface escrowsFieldRefs {
    readonly id: FieldRef<"escrows", 'String'>
    readonly payment_id: FieldRef<"escrows", 'String'>
    readonly amount: FieldRef<"escrows", 'Decimal'>
    readonly fee: FieldRef<"escrows", 'Decimal'>
    readonly status: FieldRef<"escrows", 'String'>
    readonly released_at: FieldRef<"escrows", 'DateTime'>
    readonly created_at: FieldRef<"escrows", 'DateTime'>
    readonly updated_at: FieldRef<"escrows", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * escrows findUnique
   */
  export type escrowsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * Filter, which escrows to fetch.
     */
    where: escrowsWhereUniqueInput
  }

  /**
   * escrows findUniqueOrThrow
   */
  export type escrowsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * Filter, which escrows to fetch.
     */
    where: escrowsWhereUniqueInput
  }

  /**
   * escrows findFirst
   */
  export type escrowsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * Filter, which escrows to fetch.
     */
    where?: escrowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrows to fetch.
     */
    orderBy?: escrowsOrderByWithRelationInput | escrowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escrows.
     */
    cursor?: escrowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escrows.
     */
    distinct?: EscrowsScalarFieldEnum | EscrowsScalarFieldEnum[]
  }

  /**
   * escrows findFirstOrThrow
   */
  export type escrowsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * Filter, which escrows to fetch.
     */
    where?: escrowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrows to fetch.
     */
    orderBy?: escrowsOrderByWithRelationInput | escrowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escrows.
     */
    cursor?: escrowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escrows.
     */
    distinct?: EscrowsScalarFieldEnum | EscrowsScalarFieldEnum[]
  }

  /**
   * escrows findMany
   */
  export type escrowsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * Filter, which escrows to fetch.
     */
    where?: escrowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrows to fetch.
     */
    orderBy?: escrowsOrderByWithRelationInput | escrowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing escrows.
     */
    cursor?: escrowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrows.
     */
    skip?: number
    distinct?: EscrowsScalarFieldEnum | EscrowsScalarFieldEnum[]
  }

  /**
   * escrows create
   */
  export type escrowsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * The data needed to create a escrows.
     */
    data: XOR<escrowsCreateInput, escrowsUncheckedCreateInput>
  }

  /**
   * escrows createMany
   */
  export type escrowsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many escrows.
     */
    data: escrowsCreateManyInput | escrowsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * escrows createManyAndReturn
   */
  export type escrowsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * The data used to create many escrows.
     */
    data: escrowsCreateManyInput | escrowsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * escrows update
   */
  export type escrowsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * The data needed to update a escrows.
     */
    data: XOR<escrowsUpdateInput, escrowsUncheckedUpdateInput>
    /**
     * Choose, which escrows to update.
     */
    where: escrowsWhereUniqueInput
  }

  /**
   * escrows updateMany
   */
  export type escrowsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update escrows.
     */
    data: XOR<escrowsUpdateManyMutationInput, escrowsUncheckedUpdateManyInput>
    /**
     * Filter which escrows to update
     */
    where?: escrowsWhereInput
    /**
     * Limit how many escrows to update.
     */
    limit?: number
  }

  /**
   * escrows updateManyAndReturn
   */
  export type escrowsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * The data used to update escrows.
     */
    data: XOR<escrowsUpdateManyMutationInput, escrowsUncheckedUpdateManyInput>
    /**
     * Filter which escrows to update
     */
    where?: escrowsWhereInput
    /**
     * Limit how many escrows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * escrows upsert
   */
  export type escrowsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * The filter to search for the escrows to update in case it exists.
     */
    where: escrowsWhereUniqueInput
    /**
     * In case the escrows found by the `where` argument doesn't exist, create a new escrows with this data.
     */
    create: XOR<escrowsCreateInput, escrowsUncheckedCreateInput>
    /**
     * In case the escrows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<escrowsUpdateInput, escrowsUncheckedUpdateInput>
  }

  /**
   * escrows delete
   */
  export type escrowsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    /**
     * Filter which escrows to delete.
     */
    where: escrowsWhereUniqueInput
  }

  /**
   * escrows deleteMany
   */
  export type escrowsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escrows to delete
     */
    where?: escrowsWhereInput
    /**
     * Limit how many escrows to delete.
     */
    limit?: number
  }

  /**
   * escrows without action
   */
  export type escrowsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
  }


  /**
   * Model escrow_records
   */

  export type AggregateEscrow_records = {
    _count: Escrow_recordsCountAggregateOutputType | null
    _avg: Escrow_recordsAvgAggregateOutputType | null
    _sum: Escrow_recordsSumAggregateOutputType | null
    _min: Escrow_recordsMinAggregateOutputType | null
    _max: Escrow_recordsMaxAggregateOutputType | null
  }

  export type Escrow_recordsAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type Escrow_recordsSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type Escrow_recordsMinAggregateOutputType = {
    id: string | null
    external_ref: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    released_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Escrow_recordsMaxAggregateOutputType = {
    id: string | null
    external_ref: string | null
    amount: Decimal | null
    currency: string | null
    status: string | null
    released_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Escrow_recordsCountAggregateOutputType = {
    id: number
    external_ref: number
    amount: number
    currency: number
    status: number
    released_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Escrow_recordsAvgAggregateInputType = {
    amount?: true
  }

  export type Escrow_recordsSumAggregateInputType = {
    amount?: true
  }

  export type Escrow_recordsMinAggregateInputType = {
    id?: true
    external_ref?: true
    amount?: true
    currency?: true
    status?: true
    released_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Escrow_recordsMaxAggregateInputType = {
    id?: true
    external_ref?: true
    amount?: true
    currency?: true
    status?: true
    released_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Escrow_recordsCountAggregateInputType = {
    id?: true
    external_ref?: true
    amount?: true
    currency?: true
    status?: true
    released_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Escrow_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escrow_records to aggregate.
     */
    where?: escrow_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_records to fetch.
     */
    orderBy?: escrow_recordsOrderByWithRelationInput | escrow_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: escrow_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned escrow_records
    **/
    _count?: true | Escrow_recordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Escrow_recordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Escrow_recordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Escrow_recordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Escrow_recordsMaxAggregateInputType
  }

  export type GetEscrow_recordsAggregateType<T extends Escrow_recordsAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrow_records]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrow_records[P]>
      : GetScalarType<T[P], AggregateEscrow_records[P]>
  }




  export type escrow_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escrow_recordsWhereInput
    orderBy?: escrow_recordsOrderByWithAggregationInput | escrow_recordsOrderByWithAggregationInput[]
    by: Escrow_recordsScalarFieldEnum[] | Escrow_recordsScalarFieldEnum
    having?: escrow_recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Escrow_recordsCountAggregateInputType | true
    _avg?: Escrow_recordsAvgAggregateInputType
    _sum?: Escrow_recordsSumAggregateInputType
    _min?: Escrow_recordsMinAggregateInputType
    _max?: Escrow_recordsMaxAggregateInputType
  }

  export type Escrow_recordsGroupByOutputType = {
    id: string
    external_ref: string | null
    amount: Decimal
    currency: string
    status: string
    released_at: Date | null
    created_at: Date
    updated_at: Date
    _count: Escrow_recordsCountAggregateOutputType | null
    _avg: Escrow_recordsAvgAggregateOutputType | null
    _sum: Escrow_recordsSumAggregateOutputType | null
    _min: Escrow_recordsMinAggregateOutputType | null
    _max: Escrow_recordsMaxAggregateOutputType | null
  }

  type GetEscrow_recordsGroupByPayload<T extends escrow_recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Escrow_recordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Escrow_recordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Escrow_recordsGroupByOutputType[P]>
            : GetScalarType<T[P], Escrow_recordsGroupByOutputType[P]>
        }
      >
    >


  export type escrow_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    external_ref?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    ledger_entries?: boolean | escrow_records$ledger_entriesArgs<ExtArgs>
    _count?: boolean | Escrow_recordsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrow_records"]>

  export type escrow_recordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    external_ref?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["escrow_records"]>

  export type escrow_recordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    external_ref?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["escrow_records"]>

  export type escrow_recordsSelectScalar = {
    id?: boolean
    external_ref?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    released_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type escrow_recordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "external_ref" | "amount" | "currency" | "status" | "released_at" | "created_at" | "updated_at", ExtArgs["result"]["escrow_records"]>
  export type escrow_recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ledger_entries?: boolean | escrow_records$ledger_entriesArgs<ExtArgs>
    _count?: boolean | Escrow_recordsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type escrow_recordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type escrow_recordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $escrow_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "escrow_records"
    objects: {
      ledger_entries: Prisma.$escrow_ledgerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      external_ref: string | null
      amount: Prisma.Decimal
      currency: string
      status: string
      released_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["escrow_records"]>
    composites: {}
  }

  type escrow_recordsGetPayload<S extends boolean | null | undefined | escrow_recordsDefaultArgs> = $Result.GetResult<Prisma.$escrow_recordsPayload, S>

  type escrow_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<escrow_recordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Escrow_recordsCountAggregateInputType | true
    }

  export interface escrow_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['escrow_records'], meta: { name: 'escrow_records' } }
    /**
     * Find zero or one Escrow_records that matches the filter.
     * @param {escrow_recordsFindUniqueArgs} args - Arguments to find a Escrow_records
     * @example
     * // Get one Escrow_records
     * const escrow_records = await prisma.escrow_records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends escrow_recordsFindUniqueArgs>(args: SelectSubset<T, escrow_recordsFindUniqueArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Escrow_records that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {escrow_recordsFindUniqueOrThrowArgs} args - Arguments to find a Escrow_records
     * @example
     * // Get one Escrow_records
     * const escrow_records = await prisma.escrow_records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends escrow_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, escrow_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escrow_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_recordsFindFirstArgs} args - Arguments to find a Escrow_records
     * @example
     * // Get one Escrow_records
     * const escrow_records = await prisma.escrow_records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends escrow_recordsFindFirstArgs>(args?: SelectSubset<T, escrow_recordsFindFirstArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escrow_records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_recordsFindFirstOrThrowArgs} args - Arguments to find a Escrow_records
     * @example
     * // Get one Escrow_records
     * const escrow_records = await prisma.escrow_records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends escrow_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, escrow_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Escrow_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escrow_records
     * const escrow_records = await prisma.escrow_records.findMany()
     * 
     * // Get first 10 Escrow_records
     * const escrow_records = await prisma.escrow_records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrow_recordsWithIdOnly = await prisma.escrow_records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends escrow_recordsFindManyArgs>(args?: SelectSubset<T, escrow_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Escrow_records.
     * @param {escrow_recordsCreateArgs} args - Arguments to create a Escrow_records.
     * @example
     * // Create one Escrow_records
     * const Escrow_records = await prisma.escrow_records.create({
     *   data: {
     *     // ... data to create a Escrow_records
     *   }
     * })
     * 
     */
    create<T extends escrow_recordsCreateArgs>(args: SelectSubset<T, escrow_recordsCreateArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Escrow_records.
     * @param {escrow_recordsCreateManyArgs} args - Arguments to create many Escrow_records.
     * @example
     * // Create many Escrow_records
     * const escrow_records = await prisma.escrow_records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends escrow_recordsCreateManyArgs>(args?: SelectSubset<T, escrow_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escrow_records and returns the data saved in the database.
     * @param {escrow_recordsCreateManyAndReturnArgs} args - Arguments to create many Escrow_records.
     * @example
     * // Create many Escrow_records
     * const escrow_records = await prisma.escrow_records.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escrow_records and only return the `id`
     * const escrow_recordsWithIdOnly = await prisma.escrow_records.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends escrow_recordsCreateManyAndReturnArgs>(args?: SelectSubset<T, escrow_recordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Escrow_records.
     * @param {escrow_recordsDeleteArgs} args - Arguments to delete one Escrow_records.
     * @example
     * // Delete one Escrow_records
     * const Escrow_records = await prisma.escrow_records.delete({
     *   where: {
     *     // ... filter to delete one Escrow_records
     *   }
     * })
     * 
     */
    delete<T extends escrow_recordsDeleteArgs>(args: SelectSubset<T, escrow_recordsDeleteArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Escrow_records.
     * @param {escrow_recordsUpdateArgs} args - Arguments to update one Escrow_records.
     * @example
     * // Update one Escrow_records
     * const escrow_records = await prisma.escrow_records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends escrow_recordsUpdateArgs>(args: SelectSubset<T, escrow_recordsUpdateArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Escrow_records.
     * @param {escrow_recordsDeleteManyArgs} args - Arguments to filter Escrow_records to delete.
     * @example
     * // Delete a few Escrow_records
     * const { count } = await prisma.escrow_records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends escrow_recordsDeleteManyArgs>(args?: SelectSubset<T, escrow_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrow_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escrow_records
     * const escrow_records = await prisma.escrow_records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends escrow_recordsUpdateManyArgs>(args: SelectSubset<T, escrow_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrow_records and returns the data updated in the database.
     * @param {escrow_recordsUpdateManyAndReturnArgs} args - Arguments to update many Escrow_records.
     * @example
     * // Update many Escrow_records
     * const escrow_records = await prisma.escrow_records.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Escrow_records and only return the `id`
     * const escrow_recordsWithIdOnly = await prisma.escrow_records.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends escrow_recordsUpdateManyAndReturnArgs>(args: SelectSubset<T, escrow_recordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Escrow_records.
     * @param {escrow_recordsUpsertArgs} args - Arguments to update or create a Escrow_records.
     * @example
     * // Update or create a Escrow_records
     * const escrow_records = await prisma.escrow_records.upsert({
     *   create: {
     *     // ... data to create a Escrow_records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escrow_records we want to update
     *   }
     * })
     */
    upsert<T extends escrow_recordsUpsertArgs>(args: SelectSubset<T, escrow_recordsUpsertArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Escrow_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_recordsCountArgs} args - Arguments to filter Escrow_records to count.
     * @example
     * // Count the number of Escrow_records
     * const count = await prisma.escrow_records.count({
     *   where: {
     *     // ... the filter for the Escrow_records we want to count
     *   }
     * })
    **/
    count<T extends escrow_recordsCountArgs>(
      args?: Subset<T, escrow_recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Escrow_recordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escrow_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Escrow_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Escrow_recordsAggregateArgs>(args: Subset<T, Escrow_recordsAggregateArgs>): Prisma.PrismaPromise<GetEscrow_recordsAggregateType<T>>

    /**
     * Group by Escrow_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends escrow_recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: escrow_recordsGroupByArgs['orderBy'] }
        : { orderBy?: escrow_recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, escrow_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrow_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the escrow_records model
   */
  readonly fields: escrow_recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for escrow_records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__escrow_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ledger_entries<T extends escrow_records$ledger_entriesArgs<ExtArgs> = {}>(args?: Subset<T, escrow_records$ledger_entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the escrow_records model
   */
  interface escrow_recordsFieldRefs {
    readonly id: FieldRef<"escrow_records", 'String'>
    readonly external_ref: FieldRef<"escrow_records", 'String'>
    readonly amount: FieldRef<"escrow_records", 'Decimal'>
    readonly currency: FieldRef<"escrow_records", 'String'>
    readonly status: FieldRef<"escrow_records", 'String'>
    readonly released_at: FieldRef<"escrow_records", 'DateTime'>
    readonly created_at: FieldRef<"escrow_records", 'DateTime'>
    readonly updated_at: FieldRef<"escrow_records", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * escrow_records findUnique
   */
  export type escrow_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * Filter, which escrow_records to fetch.
     */
    where: escrow_recordsWhereUniqueInput
  }

  /**
   * escrow_records findUniqueOrThrow
   */
  export type escrow_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * Filter, which escrow_records to fetch.
     */
    where: escrow_recordsWhereUniqueInput
  }

  /**
   * escrow_records findFirst
   */
  export type escrow_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * Filter, which escrow_records to fetch.
     */
    where?: escrow_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_records to fetch.
     */
    orderBy?: escrow_recordsOrderByWithRelationInput | escrow_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escrow_records.
     */
    cursor?: escrow_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escrow_records.
     */
    distinct?: Escrow_recordsScalarFieldEnum | Escrow_recordsScalarFieldEnum[]
  }

  /**
   * escrow_records findFirstOrThrow
   */
  export type escrow_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * Filter, which escrow_records to fetch.
     */
    where?: escrow_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_records to fetch.
     */
    orderBy?: escrow_recordsOrderByWithRelationInput | escrow_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escrow_records.
     */
    cursor?: escrow_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escrow_records.
     */
    distinct?: Escrow_recordsScalarFieldEnum | Escrow_recordsScalarFieldEnum[]
  }

  /**
   * escrow_records findMany
   */
  export type escrow_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * Filter, which escrow_records to fetch.
     */
    where?: escrow_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_records to fetch.
     */
    orderBy?: escrow_recordsOrderByWithRelationInput | escrow_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing escrow_records.
     */
    cursor?: escrow_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_records.
     */
    skip?: number
    distinct?: Escrow_recordsScalarFieldEnum | Escrow_recordsScalarFieldEnum[]
  }

  /**
   * escrow_records create
   */
  export type escrow_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * The data needed to create a escrow_records.
     */
    data: XOR<escrow_recordsCreateInput, escrow_recordsUncheckedCreateInput>
  }

  /**
   * escrow_records createMany
   */
  export type escrow_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many escrow_records.
     */
    data: escrow_recordsCreateManyInput | escrow_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * escrow_records createManyAndReturn
   */
  export type escrow_recordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * The data used to create many escrow_records.
     */
    data: escrow_recordsCreateManyInput | escrow_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * escrow_records update
   */
  export type escrow_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * The data needed to update a escrow_records.
     */
    data: XOR<escrow_recordsUpdateInput, escrow_recordsUncheckedUpdateInput>
    /**
     * Choose, which escrow_records to update.
     */
    where: escrow_recordsWhereUniqueInput
  }

  /**
   * escrow_records updateMany
   */
  export type escrow_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update escrow_records.
     */
    data: XOR<escrow_recordsUpdateManyMutationInput, escrow_recordsUncheckedUpdateManyInput>
    /**
     * Filter which escrow_records to update
     */
    where?: escrow_recordsWhereInput
    /**
     * Limit how many escrow_records to update.
     */
    limit?: number
  }

  /**
   * escrow_records updateManyAndReturn
   */
  export type escrow_recordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * The data used to update escrow_records.
     */
    data: XOR<escrow_recordsUpdateManyMutationInput, escrow_recordsUncheckedUpdateManyInput>
    /**
     * Filter which escrow_records to update
     */
    where?: escrow_recordsWhereInput
    /**
     * Limit how many escrow_records to update.
     */
    limit?: number
  }

  /**
   * escrow_records upsert
   */
  export type escrow_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * The filter to search for the escrow_records to update in case it exists.
     */
    where: escrow_recordsWhereUniqueInput
    /**
     * In case the escrow_records found by the `where` argument doesn't exist, create a new escrow_records with this data.
     */
    create: XOR<escrow_recordsCreateInput, escrow_recordsUncheckedCreateInput>
    /**
     * In case the escrow_records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<escrow_recordsUpdateInput, escrow_recordsUncheckedUpdateInput>
  }

  /**
   * escrow_records delete
   */
  export type escrow_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
    /**
     * Filter which escrow_records to delete.
     */
    where: escrow_recordsWhereUniqueInput
  }

  /**
   * escrow_records deleteMany
   */
  export type escrow_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escrow_records to delete
     */
    where?: escrow_recordsWhereInput
    /**
     * Limit how many escrow_records to delete.
     */
    limit?: number
  }

  /**
   * escrow_records.ledger_entries
   */
  export type escrow_records$ledger_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    where?: escrow_ledgerWhereInput
    orderBy?: escrow_ledgerOrderByWithRelationInput | escrow_ledgerOrderByWithRelationInput[]
    cursor?: escrow_ledgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Escrow_ledgerScalarFieldEnum | Escrow_ledgerScalarFieldEnum[]
  }

  /**
   * escrow_records without action
   */
  export type escrow_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_records
     */
    select?: escrow_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_records
     */
    omit?: escrow_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_recordsInclude<ExtArgs> | null
  }


  /**
   * Model escrow_ledger
   */

  export type AggregateEscrow_ledger = {
    _count: Escrow_ledgerCountAggregateOutputType | null
    _avg: Escrow_ledgerAvgAggregateOutputType | null
    _sum: Escrow_ledgerSumAggregateOutputType | null
    _min: Escrow_ledgerMinAggregateOutputType | null
    _max: Escrow_ledgerMaxAggregateOutputType | null
  }

  export type Escrow_ledgerAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type Escrow_ledgerSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type Escrow_ledgerMinAggregateOutputType = {
    id: string | null
    escrow_id: string | null
    action: string | null
    amount: Decimal | null
    note: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Escrow_ledgerMaxAggregateOutputType = {
    id: string | null
    escrow_id: string | null
    action: string | null
    amount: Decimal | null
    note: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Escrow_ledgerCountAggregateOutputType = {
    id: number
    escrow_id: number
    action: number
    amount: number
    note: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Escrow_ledgerAvgAggregateInputType = {
    amount?: true
  }

  export type Escrow_ledgerSumAggregateInputType = {
    amount?: true
  }

  export type Escrow_ledgerMinAggregateInputType = {
    id?: true
    escrow_id?: true
    action?: true
    amount?: true
    note?: true
    created_at?: true
    updated_at?: true
  }

  export type Escrow_ledgerMaxAggregateInputType = {
    id?: true
    escrow_id?: true
    action?: true
    amount?: true
    note?: true
    created_at?: true
    updated_at?: true
  }

  export type Escrow_ledgerCountAggregateInputType = {
    id?: true
    escrow_id?: true
    action?: true
    amount?: true
    note?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Escrow_ledgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escrow_ledger to aggregate.
     */
    where?: escrow_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_ledgers to fetch.
     */
    orderBy?: escrow_ledgerOrderByWithRelationInput | escrow_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: escrow_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned escrow_ledgers
    **/
    _count?: true | Escrow_ledgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Escrow_ledgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Escrow_ledgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Escrow_ledgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Escrow_ledgerMaxAggregateInputType
  }

  export type GetEscrow_ledgerAggregateType<T extends Escrow_ledgerAggregateArgs> = {
        [P in keyof T & keyof AggregateEscrow_ledger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscrow_ledger[P]>
      : GetScalarType<T[P], AggregateEscrow_ledger[P]>
  }




  export type escrow_ledgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escrow_ledgerWhereInput
    orderBy?: escrow_ledgerOrderByWithAggregationInput | escrow_ledgerOrderByWithAggregationInput[]
    by: Escrow_ledgerScalarFieldEnum[] | Escrow_ledgerScalarFieldEnum
    having?: escrow_ledgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Escrow_ledgerCountAggregateInputType | true
    _avg?: Escrow_ledgerAvgAggregateInputType
    _sum?: Escrow_ledgerSumAggregateInputType
    _min?: Escrow_ledgerMinAggregateInputType
    _max?: Escrow_ledgerMaxAggregateInputType
  }

  export type Escrow_ledgerGroupByOutputType = {
    id: string
    escrow_id: string
    action: string
    amount: Decimal
    note: string | null
    created_at: Date
    updated_at: Date
    _count: Escrow_ledgerCountAggregateOutputType | null
    _avg: Escrow_ledgerAvgAggregateOutputType | null
    _sum: Escrow_ledgerSumAggregateOutputType | null
    _min: Escrow_ledgerMinAggregateOutputType | null
    _max: Escrow_ledgerMaxAggregateOutputType | null
  }

  type GetEscrow_ledgerGroupByPayload<T extends escrow_ledgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Escrow_ledgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Escrow_ledgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Escrow_ledgerGroupByOutputType[P]>
            : GetScalarType<T[P], Escrow_ledgerGroupByOutputType[P]>
        }
      >
    >


  export type escrow_ledgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrow_id?: boolean
    action?: boolean
    amount?: boolean
    note?: boolean
    created_at?: boolean
    updated_at?: boolean
    escrow_records?: boolean | escrow_recordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrow_ledger"]>

  export type escrow_ledgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrow_id?: boolean
    action?: boolean
    amount?: boolean
    note?: boolean
    created_at?: boolean
    updated_at?: boolean
    escrow_records?: boolean | escrow_recordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrow_ledger"]>

  export type escrow_ledgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    escrow_id?: boolean
    action?: boolean
    amount?: boolean
    note?: boolean
    created_at?: boolean
    updated_at?: boolean
    escrow_records?: boolean | escrow_recordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escrow_ledger"]>

  export type escrow_ledgerSelectScalar = {
    id?: boolean
    escrow_id?: boolean
    action?: boolean
    amount?: boolean
    note?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type escrow_ledgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "escrow_id" | "action" | "amount" | "note" | "created_at" | "updated_at", ExtArgs["result"]["escrow_ledger"]>
  export type escrow_ledgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escrow_records?: boolean | escrow_recordsDefaultArgs<ExtArgs>
  }
  export type escrow_ledgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escrow_records?: boolean | escrow_recordsDefaultArgs<ExtArgs>
  }
  export type escrow_ledgerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escrow_records?: boolean | escrow_recordsDefaultArgs<ExtArgs>
  }

  export type $escrow_ledgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "escrow_ledger"
    objects: {
      escrow_records: Prisma.$escrow_recordsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      escrow_id: string
      action: string
      amount: Prisma.Decimal
      note: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["escrow_ledger"]>
    composites: {}
  }

  type escrow_ledgerGetPayload<S extends boolean | null | undefined | escrow_ledgerDefaultArgs> = $Result.GetResult<Prisma.$escrow_ledgerPayload, S>

  type escrow_ledgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<escrow_ledgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Escrow_ledgerCountAggregateInputType | true
    }

  export interface escrow_ledgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['escrow_ledger'], meta: { name: 'escrow_ledger' } }
    /**
     * Find zero or one Escrow_ledger that matches the filter.
     * @param {escrow_ledgerFindUniqueArgs} args - Arguments to find a Escrow_ledger
     * @example
     * // Get one Escrow_ledger
     * const escrow_ledger = await prisma.escrow_ledger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends escrow_ledgerFindUniqueArgs>(args: SelectSubset<T, escrow_ledgerFindUniqueArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Escrow_ledger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {escrow_ledgerFindUniqueOrThrowArgs} args - Arguments to find a Escrow_ledger
     * @example
     * // Get one Escrow_ledger
     * const escrow_ledger = await prisma.escrow_ledger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends escrow_ledgerFindUniqueOrThrowArgs>(args: SelectSubset<T, escrow_ledgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escrow_ledger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_ledgerFindFirstArgs} args - Arguments to find a Escrow_ledger
     * @example
     * // Get one Escrow_ledger
     * const escrow_ledger = await prisma.escrow_ledger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends escrow_ledgerFindFirstArgs>(args?: SelectSubset<T, escrow_ledgerFindFirstArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escrow_ledger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_ledgerFindFirstOrThrowArgs} args - Arguments to find a Escrow_ledger
     * @example
     * // Get one Escrow_ledger
     * const escrow_ledger = await prisma.escrow_ledger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends escrow_ledgerFindFirstOrThrowArgs>(args?: SelectSubset<T, escrow_ledgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Escrow_ledgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_ledgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escrow_ledgers
     * const escrow_ledgers = await prisma.escrow_ledger.findMany()
     * 
     * // Get first 10 Escrow_ledgers
     * const escrow_ledgers = await prisma.escrow_ledger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escrow_ledgerWithIdOnly = await prisma.escrow_ledger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends escrow_ledgerFindManyArgs>(args?: SelectSubset<T, escrow_ledgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Escrow_ledger.
     * @param {escrow_ledgerCreateArgs} args - Arguments to create a Escrow_ledger.
     * @example
     * // Create one Escrow_ledger
     * const Escrow_ledger = await prisma.escrow_ledger.create({
     *   data: {
     *     // ... data to create a Escrow_ledger
     *   }
     * })
     * 
     */
    create<T extends escrow_ledgerCreateArgs>(args: SelectSubset<T, escrow_ledgerCreateArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Escrow_ledgers.
     * @param {escrow_ledgerCreateManyArgs} args - Arguments to create many Escrow_ledgers.
     * @example
     * // Create many Escrow_ledgers
     * const escrow_ledger = await prisma.escrow_ledger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends escrow_ledgerCreateManyArgs>(args?: SelectSubset<T, escrow_ledgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escrow_ledgers and returns the data saved in the database.
     * @param {escrow_ledgerCreateManyAndReturnArgs} args - Arguments to create many Escrow_ledgers.
     * @example
     * // Create many Escrow_ledgers
     * const escrow_ledger = await prisma.escrow_ledger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escrow_ledgers and only return the `id`
     * const escrow_ledgerWithIdOnly = await prisma.escrow_ledger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends escrow_ledgerCreateManyAndReturnArgs>(args?: SelectSubset<T, escrow_ledgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Escrow_ledger.
     * @param {escrow_ledgerDeleteArgs} args - Arguments to delete one Escrow_ledger.
     * @example
     * // Delete one Escrow_ledger
     * const Escrow_ledger = await prisma.escrow_ledger.delete({
     *   where: {
     *     // ... filter to delete one Escrow_ledger
     *   }
     * })
     * 
     */
    delete<T extends escrow_ledgerDeleteArgs>(args: SelectSubset<T, escrow_ledgerDeleteArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Escrow_ledger.
     * @param {escrow_ledgerUpdateArgs} args - Arguments to update one Escrow_ledger.
     * @example
     * // Update one Escrow_ledger
     * const escrow_ledger = await prisma.escrow_ledger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends escrow_ledgerUpdateArgs>(args: SelectSubset<T, escrow_ledgerUpdateArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Escrow_ledgers.
     * @param {escrow_ledgerDeleteManyArgs} args - Arguments to filter Escrow_ledgers to delete.
     * @example
     * // Delete a few Escrow_ledgers
     * const { count } = await prisma.escrow_ledger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends escrow_ledgerDeleteManyArgs>(args?: SelectSubset<T, escrow_ledgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrow_ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_ledgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escrow_ledgers
     * const escrow_ledger = await prisma.escrow_ledger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends escrow_ledgerUpdateManyArgs>(args: SelectSubset<T, escrow_ledgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escrow_ledgers and returns the data updated in the database.
     * @param {escrow_ledgerUpdateManyAndReturnArgs} args - Arguments to update many Escrow_ledgers.
     * @example
     * // Update many Escrow_ledgers
     * const escrow_ledger = await prisma.escrow_ledger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Escrow_ledgers and only return the `id`
     * const escrow_ledgerWithIdOnly = await prisma.escrow_ledger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends escrow_ledgerUpdateManyAndReturnArgs>(args: SelectSubset<T, escrow_ledgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Escrow_ledger.
     * @param {escrow_ledgerUpsertArgs} args - Arguments to update or create a Escrow_ledger.
     * @example
     * // Update or create a Escrow_ledger
     * const escrow_ledger = await prisma.escrow_ledger.upsert({
     *   create: {
     *     // ... data to create a Escrow_ledger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escrow_ledger we want to update
     *   }
     * })
     */
    upsert<T extends escrow_ledgerUpsertArgs>(args: SelectSubset<T, escrow_ledgerUpsertArgs<ExtArgs>>): Prisma__escrow_ledgerClient<$Result.GetResult<Prisma.$escrow_ledgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Escrow_ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_ledgerCountArgs} args - Arguments to filter Escrow_ledgers to count.
     * @example
     * // Count the number of Escrow_ledgers
     * const count = await prisma.escrow_ledger.count({
     *   where: {
     *     // ... the filter for the Escrow_ledgers we want to count
     *   }
     * })
    **/
    count<T extends escrow_ledgerCountArgs>(
      args?: Subset<T, escrow_ledgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Escrow_ledgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escrow_ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Escrow_ledgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Escrow_ledgerAggregateArgs>(args: Subset<T, Escrow_ledgerAggregateArgs>): Prisma.PrismaPromise<GetEscrow_ledgerAggregateType<T>>

    /**
     * Group by Escrow_ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escrow_ledgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends escrow_ledgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: escrow_ledgerGroupByArgs['orderBy'] }
        : { orderBy?: escrow_ledgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, escrow_ledgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscrow_ledgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the escrow_ledger model
   */
  readonly fields: escrow_ledgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for escrow_ledger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__escrow_ledgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    escrow_records<T extends escrow_recordsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, escrow_recordsDefaultArgs<ExtArgs>>): Prisma__escrow_recordsClient<$Result.GetResult<Prisma.$escrow_recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the escrow_ledger model
   */
  interface escrow_ledgerFieldRefs {
    readonly id: FieldRef<"escrow_ledger", 'String'>
    readonly escrow_id: FieldRef<"escrow_ledger", 'String'>
    readonly action: FieldRef<"escrow_ledger", 'String'>
    readonly amount: FieldRef<"escrow_ledger", 'Decimal'>
    readonly note: FieldRef<"escrow_ledger", 'String'>
    readonly created_at: FieldRef<"escrow_ledger", 'DateTime'>
    readonly updated_at: FieldRef<"escrow_ledger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * escrow_ledger findUnique
   */
  export type escrow_ledgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which escrow_ledger to fetch.
     */
    where: escrow_ledgerWhereUniqueInput
  }

  /**
   * escrow_ledger findUniqueOrThrow
   */
  export type escrow_ledgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which escrow_ledger to fetch.
     */
    where: escrow_ledgerWhereUniqueInput
  }

  /**
   * escrow_ledger findFirst
   */
  export type escrow_ledgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which escrow_ledger to fetch.
     */
    where?: escrow_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_ledgers to fetch.
     */
    orderBy?: escrow_ledgerOrderByWithRelationInput | escrow_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escrow_ledgers.
     */
    cursor?: escrow_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escrow_ledgers.
     */
    distinct?: Escrow_ledgerScalarFieldEnum | Escrow_ledgerScalarFieldEnum[]
  }

  /**
   * escrow_ledger findFirstOrThrow
   */
  export type escrow_ledgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which escrow_ledger to fetch.
     */
    where?: escrow_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_ledgers to fetch.
     */
    orderBy?: escrow_ledgerOrderByWithRelationInput | escrow_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escrow_ledgers.
     */
    cursor?: escrow_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escrow_ledgers.
     */
    distinct?: Escrow_ledgerScalarFieldEnum | Escrow_ledgerScalarFieldEnum[]
  }

  /**
   * escrow_ledger findMany
   */
  export type escrow_ledgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * Filter, which escrow_ledgers to fetch.
     */
    where?: escrow_ledgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escrow_ledgers to fetch.
     */
    orderBy?: escrow_ledgerOrderByWithRelationInput | escrow_ledgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing escrow_ledgers.
     */
    cursor?: escrow_ledgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escrow_ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escrow_ledgers.
     */
    skip?: number
    distinct?: Escrow_ledgerScalarFieldEnum | Escrow_ledgerScalarFieldEnum[]
  }

  /**
   * escrow_ledger create
   */
  export type escrow_ledgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * The data needed to create a escrow_ledger.
     */
    data: XOR<escrow_ledgerCreateInput, escrow_ledgerUncheckedCreateInput>
  }

  /**
   * escrow_ledger createMany
   */
  export type escrow_ledgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many escrow_ledgers.
     */
    data: escrow_ledgerCreateManyInput | escrow_ledgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * escrow_ledger createManyAndReturn
   */
  export type escrow_ledgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * The data used to create many escrow_ledgers.
     */
    data: escrow_ledgerCreateManyInput | escrow_ledgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * escrow_ledger update
   */
  export type escrow_ledgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * The data needed to update a escrow_ledger.
     */
    data: XOR<escrow_ledgerUpdateInput, escrow_ledgerUncheckedUpdateInput>
    /**
     * Choose, which escrow_ledger to update.
     */
    where: escrow_ledgerWhereUniqueInput
  }

  /**
   * escrow_ledger updateMany
   */
  export type escrow_ledgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update escrow_ledgers.
     */
    data: XOR<escrow_ledgerUpdateManyMutationInput, escrow_ledgerUncheckedUpdateManyInput>
    /**
     * Filter which escrow_ledgers to update
     */
    where?: escrow_ledgerWhereInput
    /**
     * Limit how many escrow_ledgers to update.
     */
    limit?: number
  }

  /**
   * escrow_ledger updateManyAndReturn
   */
  export type escrow_ledgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * The data used to update escrow_ledgers.
     */
    data: XOR<escrow_ledgerUpdateManyMutationInput, escrow_ledgerUncheckedUpdateManyInput>
    /**
     * Filter which escrow_ledgers to update
     */
    where?: escrow_ledgerWhereInput
    /**
     * Limit how many escrow_ledgers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * escrow_ledger upsert
   */
  export type escrow_ledgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * The filter to search for the escrow_ledger to update in case it exists.
     */
    where: escrow_ledgerWhereUniqueInput
    /**
     * In case the escrow_ledger found by the `where` argument doesn't exist, create a new escrow_ledger with this data.
     */
    create: XOR<escrow_ledgerCreateInput, escrow_ledgerUncheckedCreateInput>
    /**
     * In case the escrow_ledger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<escrow_ledgerUpdateInput, escrow_ledgerUncheckedUpdateInput>
  }

  /**
   * escrow_ledger delete
   */
  export type escrow_ledgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
    /**
     * Filter which escrow_ledger to delete.
     */
    where: escrow_ledgerWhereUniqueInput
  }

  /**
   * escrow_ledger deleteMany
   */
  export type escrow_ledgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escrow_ledgers to delete
     */
    where?: escrow_ledgerWhereInput
    /**
     * Limit how many escrow_ledgers to delete.
     */
    limit?: number
  }

  /**
   * escrow_ledger without action
   */
  export type escrow_ledgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrow_ledger
     */
    select?: escrow_ledgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrow_ledger
     */
    omit?: escrow_ledgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrow_ledgerInclude<ExtArgs> | null
  }


  /**
   * Model provider_transactions
   */

  export type AggregateProvider_transactions = {
    _count: Provider_transactionsCountAggregateOutputType | null
    _avg: Provider_transactionsAvgAggregateOutputType | null
    _sum: Provider_transactionsSumAggregateOutputType | null
    _min: Provider_transactionsMinAggregateOutputType | null
    _max: Provider_transactionsMaxAggregateOutputType | null
  }

  export type Provider_transactionsAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type Provider_transactionsSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type Provider_transactionsMinAggregateOutputType = {
    id: string | null
    provider: string | null
    provider_tx_id: string | null
    status: string | null
    amount: Decimal | null
    currency: string | null
    escrow_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Provider_transactionsMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    provider_tx_id: string | null
    status: string | null
    amount: Decimal | null
    currency: string | null
    escrow_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Provider_transactionsCountAggregateOutputType = {
    id: number
    provider: number
    provider_tx_id: number
    status: number
    amount: number
    currency: number
    payload: number
    escrow_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Provider_transactionsAvgAggregateInputType = {
    amount?: true
  }

  export type Provider_transactionsSumAggregateInputType = {
    amount?: true
  }

  export type Provider_transactionsMinAggregateInputType = {
    id?: true
    provider?: true
    provider_tx_id?: true
    status?: true
    amount?: true
    currency?: true
    escrow_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Provider_transactionsMaxAggregateInputType = {
    id?: true
    provider?: true
    provider_tx_id?: true
    status?: true
    amount?: true
    currency?: true
    escrow_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Provider_transactionsCountAggregateInputType = {
    id?: true
    provider?: true
    provider_tx_id?: true
    status?: true
    amount?: true
    currency?: true
    payload?: true
    escrow_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Provider_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_transactions to aggregate.
     */
    where?: provider_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_transactions to fetch.
     */
    orderBy?: provider_transactionsOrderByWithRelationInput | provider_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_transactions
    **/
    _count?: true | Provider_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Provider_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Provider_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_transactionsMaxAggregateInputType
  }

  export type GetProvider_transactionsAggregateType<T extends Provider_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_transactions[P]>
      : GetScalarType<T[P], AggregateProvider_transactions[P]>
  }




  export type provider_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_transactionsWhereInput
    orderBy?: provider_transactionsOrderByWithAggregationInput | provider_transactionsOrderByWithAggregationInput[]
    by: Provider_transactionsScalarFieldEnum[] | Provider_transactionsScalarFieldEnum
    having?: provider_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_transactionsCountAggregateInputType | true
    _avg?: Provider_transactionsAvgAggregateInputType
    _sum?: Provider_transactionsSumAggregateInputType
    _min?: Provider_transactionsMinAggregateInputType
    _max?: Provider_transactionsMaxAggregateInputType
  }

  export type Provider_transactionsGroupByOutputType = {
    id: string
    provider: string
    provider_tx_id: string
    status: string
    amount: Decimal
    currency: string
    payload: JsonValue | null
    escrow_id: string | null
    created_at: Date
    updated_at: Date
    _count: Provider_transactionsCountAggregateOutputType | null
    _avg: Provider_transactionsAvgAggregateOutputType | null
    _sum: Provider_transactionsSumAggregateOutputType | null
    _min: Provider_transactionsMinAggregateOutputType | null
    _max: Provider_transactionsMaxAggregateOutputType | null
  }

  type GetProvider_transactionsGroupByPayload<T extends provider_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type provider_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    provider_tx_id?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    payload?: boolean
    escrow_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    logs?: boolean | provider_transactions$logsArgs<ExtArgs>
    _count?: boolean | Provider_transactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider_transactions"]>

  export type provider_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    provider_tx_id?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    payload?: boolean
    escrow_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["provider_transactions"]>

  export type provider_transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    provider_tx_id?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    payload?: boolean
    escrow_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["provider_transactions"]>

  export type provider_transactionsSelectScalar = {
    id?: boolean
    provider?: boolean
    provider_tx_id?: boolean
    status?: boolean
    amount?: boolean
    currency?: boolean
    payload?: boolean
    escrow_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type provider_transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "provider_tx_id" | "status" | "amount" | "currency" | "payload" | "escrow_id" | "created_at" | "updated_at", ExtArgs["result"]["provider_transactions"]>
  export type provider_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | provider_transactions$logsArgs<ExtArgs>
    _count?: boolean | Provider_transactionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type provider_transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type provider_transactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $provider_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_transactions"
    objects: {
      logs: Prisma.$transaction_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      provider_tx_id: string
      status: string
      amount: Prisma.Decimal
      currency: string
      payload: Prisma.JsonValue | null
      escrow_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["provider_transactions"]>
    composites: {}
  }

  type provider_transactionsGetPayload<S extends boolean | null | undefined | provider_transactionsDefaultArgs> = $Result.GetResult<Prisma.$provider_transactionsPayload, S>

  type provider_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<provider_transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Provider_transactionsCountAggregateInputType | true
    }

  export interface provider_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider_transactions'], meta: { name: 'provider_transactions' } }
    /**
     * Find zero or one Provider_transactions that matches the filter.
     * @param {provider_transactionsFindUniqueArgs} args - Arguments to find a Provider_transactions
     * @example
     * // Get one Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_transactionsFindUniqueArgs>(args: SelectSubset<T, provider_transactionsFindUniqueArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider_transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Provider_transactions
     * @example
     * // Get one Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, provider_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_transactionsFindFirstArgs} args - Arguments to find a Provider_transactions
     * @example
     * // Get one Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_transactionsFindFirstArgs>(args?: SelectSubset<T, provider_transactionsFindFirstArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_transactionsFindFirstOrThrowArgs} args - Arguments to find a Provider_transactions
     * @example
     * // Get one Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, provider_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provider_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.findMany()
     * 
     * // Get first 10 Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_transactionsWithIdOnly = await prisma.provider_transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends provider_transactionsFindManyArgs>(args?: SelectSubset<T, provider_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider_transactions.
     * @param {provider_transactionsCreateArgs} args - Arguments to create a Provider_transactions.
     * @example
     * // Create one Provider_transactions
     * const Provider_transactions = await prisma.provider_transactions.create({
     *   data: {
     *     // ... data to create a Provider_transactions
     *   }
     * })
     * 
     */
    create<T extends provider_transactionsCreateArgs>(args: SelectSubset<T, provider_transactionsCreateArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provider_transactions.
     * @param {provider_transactionsCreateManyArgs} args - Arguments to create many Provider_transactions.
     * @example
     * // Create many Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provider_transactionsCreateManyArgs>(args?: SelectSubset<T, provider_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provider_transactions and returns the data saved in the database.
     * @param {provider_transactionsCreateManyAndReturnArgs} args - Arguments to create many Provider_transactions.
     * @example
     * // Create many Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provider_transactions and only return the `id`
     * const provider_transactionsWithIdOnly = await prisma.provider_transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends provider_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, provider_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider_transactions.
     * @param {provider_transactionsDeleteArgs} args - Arguments to delete one Provider_transactions.
     * @example
     * // Delete one Provider_transactions
     * const Provider_transactions = await prisma.provider_transactions.delete({
     *   where: {
     *     // ... filter to delete one Provider_transactions
     *   }
     * })
     * 
     */
    delete<T extends provider_transactionsDeleteArgs>(args: SelectSubset<T, provider_transactionsDeleteArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider_transactions.
     * @param {provider_transactionsUpdateArgs} args - Arguments to update one Provider_transactions.
     * @example
     * // Update one Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provider_transactionsUpdateArgs>(args: SelectSubset<T, provider_transactionsUpdateArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provider_transactions.
     * @param {provider_transactionsDeleteManyArgs} args - Arguments to filter Provider_transactions to delete.
     * @example
     * // Delete a few Provider_transactions
     * const { count } = await prisma.provider_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provider_transactionsDeleteManyArgs>(args?: SelectSubset<T, provider_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provider_transactionsUpdateManyArgs>(args: SelectSubset<T, provider_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_transactions and returns the data updated in the database.
     * @param {provider_transactionsUpdateManyAndReturnArgs} args - Arguments to update many Provider_transactions.
     * @example
     * // Update many Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provider_transactions and only return the `id`
     * const provider_transactionsWithIdOnly = await prisma.provider_transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends provider_transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, provider_transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider_transactions.
     * @param {provider_transactionsUpsertArgs} args - Arguments to update or create a Provider_transactions.
     * @example
     * // Update or create a Provider_transactions
     * const provider_transactions = await prisma.provider_transactions.upsert({
     *   create: {
     *     // ... data to create a Provider_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_transactions we want to update
     *   }
     * })
     */
    upsert<T extends provider_transactionsUpsertArgs>(args: SelectSubset<T, provider_transactionsUpsertArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provider_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_transactionsCountArgs} args - Arguments to filter Provider_transactions to count.
     * @example
     * // Count the number of Provider_transactions
     * const count = await prisma.provider_transactions.count({
     *   where: {
     *     // ... the filter for the Provider_transactions we want to count
     *   }
     * })
    **/
    count<T extends provider_transactionsCountArgs>(
      args?: Subset<T, provider_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_transactionsAggregateArgs>(args: Subset<T, Provider_transactionsAggregateArgs>): Prisma.PrismaPromise<GetProvider_transactionsAggregateType<T>>

    /**
     * Group by Provider_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provider_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: provider_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provider_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider_transactions model
   */
  readonly fields: provider_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends provider_transactions$logsArgs<ExtArgs> = {}>(args?: Subset<T, provider_transactions$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provider_transactions model
   */
  interface provider_transactionsFieldRefs {
    readonly id: FieldRef<"provider_transactions", 'String'>
    readonly provider: FieldRef<"provider_transactions", 'String'>
    readonly provider_tx_id: FieldRef<"provider_transactions", 'String'>
    readonly status: FieldRef<"provider_transactions", 'String'>
    readonly amount: FieldRef<"provider_transactions", 'Decimal'>
    readonly currency: FieldRef<"provider_transactions", 'String'>
    readonly payload: FieldRef<"provider_transactions", 'Json'>
    readonly escrow_id: FieldRef<"provider_transactions", 'String'>
    readonly created_at: FieldRef<"provider_transactions", 'DateTime'>
    readonly updated_at: FieldRef<"provider_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * provider_transactions findUnique
   */
  export type provider_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which provider_transactions to fetch.
     */
    where: provider_transactionsWhereUniqueInput
  }

  /**
   * provider_transactions findUniqueOrThrow
   */
  export type provider_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which provider_transactions to fetch.
     */
    where: provider_transactionsWhereUniqueInput
  }

  /**
   * provider_transactions findFirst
   */
  export type provider_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which provider_transactions to fetch.
     */
    where?: provider_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_transactions to fetch.
     */
    orderBy?: provider_transactionsOrderByWithRelationInput | provider_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_transactions.
     */
    cursor?: provider_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_transactions.
     */
    distinct?: Provider_transactionsScalarFieldEnum | Provider_transactionsScalarFieldEnum[]
  }

  /**
   * provider_transactions findFirstOrThrow
   */
  export type provider_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which provider_transactions to fetch.
     */
    where?: provider_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_transactions to fetch.
     */
    orderBy?: provider_transactionsOrderByWithRelationInput | provider_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_transactions.
     */
    cursor?: provider_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_transactions.
     */
    distinct?: Provider_transactionsScalarFieldEnum | Provider_transactionsScalarFieldEnum[]
  }

  /**
   * provider_transactions findMany
   */
  export type provider_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which provider_transactions to fetch.
     */
    where?: provider_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_transactions to fetch.
     */
    orderBy?: provider_transactionsOrderByWithRelationInput | provider_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_transactions.
     */
    cursor?: provider_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_transactions.
     */
    skip?: number
    distinct?: Provider_transactionsScalarFieldEnum | Provider_transactionsScalarFieldEnum[]
  }

  /**
   * provider_transactions create
   */
  export type provider_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a provider_transactions.
     */
    data: XOR<provider_transactionsCreateInput, provider_transactionsUncheckedCreateInput>
  }

  /**
   * provider_transactions createMany
   */
  export type provider_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provider_transactions.
     */
    data: provider_transactionsCreateManyInput | provider_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_transactions createManyAndReturn
   */
  export type provider_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * The data used to create many provider_transactions.
     */
    data: provider_transactionsCreateManyInput | provider_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_transactions update
   */
  export type provider_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a provider_transactions.
     */
    data: XOR<provider_transactionsUpdateInput, provider_transactionsUncheckedUpdateInput>
    /**
     * Choose, which provider_transactions to update.
     */
    where: provider_transactionsWhereUniqueInput
  }

  /**
   * provider_transactions updateMany
   */
  export type provider_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provider_transactions.
     */
    data: XOR<provider_transactionsUpdateManyMutationInput, provider_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which provider_transactions to update
     */
    where?: provider_transactionsWhereInput
    /**
     * Limit how many provider_transactions to update.
     */
    limit?: number
  }

  /**
   * provider_transactions updateManyAndReturn
   */
  export type provider_transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * The data used to update provider_transactions.
     */
    data: XOR<provider_transactionsUpdateManyMutationInput, provider_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which provider_transactions to update
     */
    where?: provider_transactionsWhereInput
    /**
     * Limit how many provider_transactions to update.
     */
    limit?: number
  }

  /**
   * provider_transactions upsert
   */
  export type provider_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the provider_transactions to update in case it exists.
     */
    where: provider_transactionsWhereUniqueInput
    /**
     * In case the provider_transactions found by the `where` argument doesn't exist, create a new provider_transactions with this data.
     */
    create: XOR<provider_transactionsCreateInput, provider_transactionsUncheckedCreateInput>
    /**
     * In case the provider_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_transactionsUpdateInput, provider_transactionsUncheckedUpdateInput>
  }

  /**
   * provider_transactions delete
   */
  export type provider_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
    /**
     * Filter which provider_transactions to delete.
     */
    where: provider_transactionsWhereUniqueInput
  }

  /**
   * provider_transactions deleteMany
   */
  export type provider_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_transactions to delete
     */
    where?: provider_transactionsWhereInput
    /**
     * Limit how many provider_transactions to delete.
     */
    limit?: number
  }

  /**
   * provider_transactions.logs
   */
  export type provider_transactions$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    where?: transaction_logsWhereInput
    orderBy?: transaction_logsOrderByWithRelationInput | transaction_logsOrderByWithRelationInput[]
    cursor?: transaction_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Transaction_logsScalarFieldEnum | Transaction_logsScalarFieldEnum[]
  }

  /**
   * provider_transactions without action
   */
  export type provider_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_transactions
     */
    select?: provider_transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_transactions
     */
    omit?: provider_transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_transactionsInclude<ExtArgs> | null
  }


  /**
   * Model transaction_logs
   */

  export type AggregateTransaction_logs = {
    _count: Transaction_logsCountAggregateOutputType | null
    _min: Transaction_logsMinAggregateOutputType | null
    _max: Transaction_logsMaxAggregateOutputType | null
  }

  export type Transaction_logsMinAggregateOutputType = {
    id: string | null
    provider_transaction_id: string | null
    action: string | null
    previous_status: string | null
    new_status: string | null
    note: string | null
    created_at: Date | null
  }

  export type Transaction_logsMaxAggregateOutputType = {
    id: string | null
    provider_transaction_id: string | null
    action: string | null
    previous_status: string | null
    new_status: string | null
    note: string | null
    created_at: Date | null
  }

  export type Transaction_logsCountAggregateOutputType = {
    id: number
    provider_transaction_id: number
    action: number
    previous_status: number
    new_status: number
    note: number
    created_at: number
    _all: number
  }


  export type Transaction_logsMinAggregateInputType = {
    id?: true
    provider_transaction_id?: true
    action?: true
    previous_status?: true
    new_status?: true
    note?: true
    created_at?: true
  }

  export type Transaction_logsMaxAggregateInputType = {
    id?: true
    provider_transaction_id?: true
    action?: true
    previous_status?: true
    new_status?: true
    note?: true
    created_at?: true
  }

  export type Transaction_logsCountAggregateInputType = {
    id?: true
    provider_transaction_id?: true
    action?: true
    previous_status?: true
    new_status?: true
    note?: true
    created_at?: true
    _all?: true
  }

  export type Transaction_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_logs to aggregate.
     */
    where?: transaction_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_logs to fetch.
     */
    orderBy?: transaction_logsOrderByWithRelationInput | transaction_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaction_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaction_logs
    **/
    _count?: true | Transaction_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Transaction_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Transaction_logsMaxAggregateInputType
  }

  export type GetTransaction_logsAggregateType<T extends Transaction_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction_logs[P]>
      : GetScalarType<T[P], AggregateTransaction_logs[P]>
  }




  export type transaction_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaction_logsWhereInput
    orderBy?: transaction_logsOrderByWithAggregationInput | transaction_logsOrderByWithAggregationInput[]
    by: Transaction_logsScalarFieldEnum[] | Transaction_logsScalarFieldEnum
    having?: transaction_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Transaction_logsCountAggregateInputType | true
    _min?: Transaction_logsMinAggregateInputType
    _max?: Transaction_logsMaxAggregateInputType
  }

  export type Transaction_logsGroupByOutputType = {
    id: string
    provider_transaction_id: string
    action: string
    previous_status: string | null
    new_status: string
    note: string | null
    created_at: Date
    _count: Transaction_logsCountAggregateOutputType | null
    _min: Transaction_logsMinAggregateOutputType | null
    _max: Transaction_logsMaxAggregateOutputType | null
  }

  type GetTransaction_logsGroupByPayload<T extends transaction_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Transaction_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Transaction_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Transaction_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Transaction_logsGroupByOutputType[P]>
        }
      >
    >


  export type transaction_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_transaction_id?: boolean
    action?: boolean
    previous_status?: boolean
    new_status?: boolean
    note?: boolean
    created_at?: boolean
    provider_transactions?: boolean | provider_transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction_logs"]>

  export type transaction_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_transaction_id?: boolean
    action?: boolean
    previous_status?: boolean
    new_status?: boolean
    note?: boolean
    created_at?: boolean
    provider_transactions?: boolean | provider_transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction_logs"]>

  export type transaction_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_transaction_id?: boolean
    action?: boolean
    previous_status?: boolean
    new_status?: boolean
    note?: boolean
    created_at?: boolean
    provider_transactions?: boolean | provider_transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction_logs"]>

  export type transaction_logsSelectScalar = {
    id?: boolean
    provider_transaction_id?: boolean
    action?: boolean
    previous_status?: boolean
    new_status?: boolean
    note?: boolean
    created_at?: boolean
  }

  export type transaction_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider_transaction_id" | "action" | "previous_status" | "new_status" | "note" | "created_at", ExtArgs["result"]["transaction_logs"]>
  export type transaction_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_transactions?: boolean | provider_transactionsDefaultArgs<ExtArgs>
  }
  export type transaction_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_transactions?: boolean | provider_transactionsDefaultArgs<ExtArgs>
  }
  export type transaction_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_transactions?: boolean | provider_transactionsDefaultArgs<ExtArgs>
  }

  export type $transaction_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction_logs"
    objects: {
      provider_transactions: Prisma.$provider_transactionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider_transaction_id: string
      action: string
      previous_status: string | null
      new_status: string
      note: string | null
      created_at: Date
    }, ExtArgs["result"]["transaction_logs"]>
    composites: {}
  }

  type transaction_logsGetPayload<S extends boolean | null | undefined | transaction_logsDefaultArgs> = $Result.GetResult<Prisma.$transaction_logsPayload, S>

  type transaction_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transaction_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Transaction_logsCountAggregateInputType | true
    }

  export interface transaction_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction_logs'], meta: { name: 'transaction_logs' } }
    /**
     * Find zero or one Transaction_logs that matches the filter.
     * @param {transaction_logsFindUniqueArgs} args - Arguments to find a Transaction_logs
     * @example
     * // Get one Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaction_logsFindUniqueArgs>(args: SelectSubset<T, transaction_logsFindUniqueArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transaction_logsFindUniqueOrThrowArgs} args - Arguments to find a Transaction_logs
     * @example
     * // Get one Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaction_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, transaction_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_logsFindFirstArgs} args - Arguments to find a Transaction_logs
     * @example
     * // Get one Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaction_logsFindFirstArgs>(args?: SelectSubset<T, transaction_logsFindFirstArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_logsFindFirstOrThrowArgs} args - Arguments to find a Transaction_logs
     * @example
     * // Get one Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaction_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, transaction_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transaction_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.findMany()
     * 
     * // Get first 10 Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaction_logsWithIdOnly = await prisma.transaction_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaction_logsFindManyArgs>(args?: SelectSubset<T, transaction_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction_logs.
     * @param {transaction_logsCreateArgs} args - Arguments to create a Transaction_logs.
     * @example
     * // Create one Transaction_logs
     * const Transaction_logs = await prisma.transaction_logs.create({
     *   data: {
     *     // ... data to create a Transaction_logs
     *   }
     * })
     * 
     */
    create<T extends transaction_logsCreateArgs>(args: SelectSubset<T, transaction_logsCreateArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transaction_logs.
     * @param {transaction_logsCreateManyArgs} args - Arguments to create many Transaction_logs.
     * @example
     * // Create many Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaction_logsCreateManyArgs>(args?: SelectSubset<T, transaction_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transaction_logs and returns the data saved in the database.
     * @param {transaction_logsCreateManyAndReturnArgs} args - Arguments to create many Transaction_logs.
     * @example
     * // Create many Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transaction_logs and only return the `id`
     * const transaction_logsWithIdOnly = await prisma.transaction_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transaction_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, transaction_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction_logs.
     * @param {transaction_logsDeleteArgs} args - Arguments to delete one Transaction_logs.
     * @example
     * // Delete one Transaction_logs
     * const Transaction_logs = await prisma.transaction_logs.delete({
     *   where: {
     *     // ... filter to delete one Transaction_logs
     *   }
     * })
     * 
     */
    delete<T extends transaction_logsDeleteArgs>(args: SelectSubset<T, transaction_logsDeleteArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction_logs.
     * @param {transaction_logsUpdateArgs} args - Arguments to update one Transaction_logs.
     * @example
     * // Update one Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaction_logsUpdateArgs>(args: SelectSubset<T, transaction_logsUpdateArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transaction_logs.
     * @param {transaction_logsDeleteManyArgs} args - Arguments to filter Transaction_logs to delete.
     * @example
     * // Delete a few Transaction_logs
     * const { count } = await prisma.transaction_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaction_logsDeleteManyArgs>(args?: SelectSubset<T, transaction_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaction_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaction_logsUpdateManyArgs>(args: SelectSubset<T, transaction_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaction_logs and returns the data updated in the database.
     * @param {transaction_logsUpdateManyAndReturnArgs} args - Arguments to update many Transaction_logs.
     * @example
     * // Update many Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transaction_logs and only return the `id`
     * const transaction_logsWithIdOnly = await prisma.transaction_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transaction_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, transaction_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction_logs.
     * @param {transaction_logsUpsertArgs} args - Arguments to update or create a Transaction_logs.
     * @example
     * // Update or create a Transaction_logs
     * const transaction_logs = await prisma.transaction_logs.upsert({
     *   create: {
     *     // ... data to create a Transaction_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction_logs we want to update
     *   }
     * })
     */
    upsert<T extends transaction_logsUpsertArgs>(args: SelectSubset<T, transaction_logsUpsertArgs<ExtArgs>>): Prisma__transaction_logsClient<$Result.GetResult<Prisma.$transaction_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transaction_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_logsCountArgs} args - Arguments to filter Transaction_logs to count.
     * @example
     * // Count the number of Transaction_logs
     * const count = await prisma.transaction_logs.count({
     *   where: {
     *     // ... the filter for the Transaction_logs we want to count
     *   }
     * })
    **/
    count<T extends transaction_logsCountArgs>(
      args?: Subset<T, transaction_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Transaction_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Transaction_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Transaction_logsAggregateArgs>(args: Subset<T, Transaction_logsAggregateArgs>): Prisma.PrismaPromise<GetTransaction_logsAggregateType<T>>

    /**
     * Group by Transaction_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaction_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaction_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaction_logsGroupByArgs['orderBy'] }
        : { orderBy?: transaction_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaction_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaction_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction_logs model
   */
  readonly fields: transaction_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaction_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_transactions<T extends provider_transactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, provider_transactionsDefaultArgs<ExtArgs>>): Prisma__provider_transactionsClient<$Result.GetResult<Prisma.$provider_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction_logs model
   */
  interface transaction_logsFieldRefs {
    readonly id: FieldRef<"transaction_logs", 'String'>
    readonly provider_transaction_id: FieldRef<"transaction_logs", 'String'>
    readonly action: FieldRef<"transaction_logs", 'String'>
    readonly previous_status: FieldRef<"transaction_logs", 'String'>
    readonly new_status: FieldRef<"transaction_logs", 'String'>
    readonly note: FieldRef<"transaction_logs", 'String'>
    readonly created_at: FieldRef<"transaction_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaction_logs findUnique
   */
  export type transaction_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * Filter, which transaction_logs to fetch.
     */
    where: transaction_logsWhereUniqueInput
  }

  /**
   * transaction_logs findUniqueOrThrow
   */
  export type transaction_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * Filter, which transaction_logs to fetch.
     */
    where: transaction_logsWhereUniqueInput
  }

  /**
   * transaction_logs findFirst
   */
  export type transaction_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * Filter, which transaction_logs to fetch.
     */
    where?: transaction_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_logs to fetch.
     */
    orderBy?: transaction_logsOrderByWithRelationInput | transaction_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_logs.
     */
    cursor?: transaction_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_logs.
     */
    distinct?: Transaction_logsScalarFieldEnum | Transaction_logsScalarFieldEnum[]
  }

  /**
   * transaction_logs findFirstOrThrow
   */
  export type transaction_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * Filter, which transaction_logs to fetch.
     */
    where?: transaction_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_logs to fetch.
     */
    orderBy?: transaction_logsOrderByWithRelationInput | transaction_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaction_logs.
     */
    cursor?: transaction_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaction_logs.
     */
    distinct?: Transaction_logsScalarFieldEnum | Transaction_logsScalarFieldEnum[]
  }

  /**
   * transaction_logs findMany
   */
  export type transaction_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * Filter, which transaction_logs to fetch.
     */
    where?: transaction_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaction_logs to fetch.
     */
    orderBy?: transaction_logsOrderByWithRelationInput | transaction_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaction_logs.
     */
    cursor?: transaction_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaction_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaction_logs.
     */
    skip?: number
    distinct?: Transaction_logsScalarFieldEnum | Transaction_logsScalarFieldEnum[]
  }

  /**
   * transaction_logs create
   */
  export type transaction_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction_logs.
     */
    data: XOR<transaction_logsCreateInput, transaction_logsUncheckedCreateInput>
  }

  /**
   * transaction_logs createMany
   */
  export type transaction_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaction_logs.
     */
    data: transaction_logsCreateManyInput | transaction_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction_logs createManyAndReturn
   */
  export type transaction_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * The data used to create many transaction_logs.
     */
    data: transaction_logsCreateManyInput | transaction_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction_logs update
   */
  export type transaction_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction_logs.
     */
    data: XOR<transaction_logsUpdateInput, transaction_logsUncheckedUpdateInput>
    /**
     * Choose, which transaction_logs to update.
     */
    where: transaction_logsWhereUniqueInput
  }

  /**
   * transaction_logs updateMany
   */
  export type transaction_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaction_logs.
     */
    data: XOR<transaction_logsUpdateManyMutationInput, transaction_logsUncheckedUpdateManyInput>
    /**
     * Filter which transaction_logs to update
     */
    where?: transaction_logsWhereInput
    /**
     * Limit how many transaction_logs to update.
     */
    limit?: number
  }

  /**
   * transaction_logs updateManyAndReturn
   */
  export type transaction_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * The data used to update transaction_logs.
     */
    data: XOR<transaction_logsUpdateManyMutationInput, transaction_logsUncheckedUpdateManyInput>
    /**
     * Filter which transaction_logs to update
     */
    where?: transaction_logsWhereInput
    /**
     * Limit how many transaction_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction_logs upsert
   */
  export type transaction_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction_logs to update in case it exists.
     */
    where: transaction_logsWhereUniqueInput
    /**
     * In case the transaction_logs found by the `where` argument doesn't exist, create a new transaction_logs with this data.
     */
    create: XOR<transaction_logsCreateInput, transaction_logsUncheckedCreateInput>
    /**
     * In case the transaction_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaction_logsUpdateInput, transaction_logsUncheckedUpdateInput>
  }

  /**
   * transaction_logs delete
   */
  export type transaction_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
    /**
     * Filter which transaction_logs to delete.
     */
    where: transaction_logsWhereUniqueInput
  }

  /**
   * transaction_logs deleteMany
   */
  export type transaction_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction_logs to delete
     */
    where?: transaction_logsWhereInput
    /**
     * Limit how many transaction_logs to delete.
     */
    limit?: number
  }

  /**
   * transaction_logs without action
   */
  export type transaction_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction_logs
     */
    select?: transaction_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction_logs
     */
    omit?: transaction_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaction_logsInclude<ExtArgs> | null
  }


  /**
   * Model feedbacks
   */

  export type AggregateFeedbacks = {
    _count: FeedbacksCountAggregateOutputType | null
    _avg: FeedbacksAvgAggregateOutputType | null
    _sum: FeedbacksSumAggregateOutputType | null
    _min: FeedbacksMinAggregateOutputType | null
    _max: FeedbacksMaxAggregateOutputType | null
  }

  export type FeedbacksAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbacksSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbacksMinAggregateOutputType = {
    id: string | null
    job_id: string | null
    from_user_id: string | null
    to_user_id: string | null
    reviewee_type: $Enums.FeedbackType | null
    rating: number | null
    comments: string | null
    is_public: boolean | null
    company_response: string | null
    responded_at: Date | null
    flagged_inappropriate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbacksMaxAggregateOutputType = {
    id: string | null
    job_id: string | null
    from_user_id: string | null
    to_user_id: string | null
    reviewee_type: $Enums.FeedbackType | null
    rating: number | null
    comments: string | null
    is_public: boolean | null
    company_response: string | null
    responded_at: Date | null
    flagged_inappropriate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedbacksCountAggregateOutputType = {
    id: number
    job_id: number
    from_user_id: number
    to_user_id: number
    reviewee_type: number
    rating: number
    tags: number
    comments: number
    is_public: number
    company_response: number
    responded_at: number
    flagged_inappropriate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedbacksAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbacksSumAggregateInputType = {
    rating?: true
  }

  export type FeedbacksMinAggregateInputType = {
    id?: true
    job_id?: true
    from_user_id?: true
    to_user_id?: true
    reviewee_type?: true
    rating?: true
    comments?: true
    is_public?: true
    company_response?: true
    responded_at?: true
    flagged_inappropriate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbacksMaxAggregateInputType = {
    id?: true
    job_id?: true
    from_user_id?: true
    to_user_id?: true
    reviewee_type?: true
    rating?: true
    comments?: true
    is_public?: true
    company_response?: true
    responded_at?: true
    flagged_inappropriate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedbacksCountAggregateInputType = {
    id?: true
    job_id?: true
    from_user_id?: true
    to_user_id?: true
    reviewee_type?: true
    rating?: true
    tags?: true
    comments?: true
    is_public?: true
    company_response?: true
    responded_at?: true
    flagged_inappropriate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedbacksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbacks to aggregate.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feedbacks
    **/
    _count?: true | FeedbacksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbacksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbacksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbacksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbacksMaxAggregateInputType
  }

  export type GetFeedbacksAggregateType<T extends FeedbacksAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbacks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbacks[P]>
      : GetScalarType<T[P], AggregateFeedbacks[P]>
  }




  export type feedbacksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbacksWhereInput
    orderBy?: feedbacksOrderByWithAggregationInput | feedbacksOrderByWithAggregationInput[]
    by: FeedbacksScalarFieldEnum[] | FeedbacksScalarFieldEnum
    having?: feedbacksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbacksCountAggregateInputType | true
    _avg?: FeedbacksAvgAggregateInputType
    _sum?: FeedbacksSumAggregateInputType
    _min?: FeedbacksMinAggregateInputType
    _max?: FeedbacksMaxAggregateInputType
  }

  export type FeedbacksGroupByOutputType = {
    id: string
    job_id: string
    from_user_id: string
    to_user_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags: JsonValue | null
    comments: string | null
    is_public: boolean
    company_response: string | null
    responded_at: Date | null
    flagged_inappropriate: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeedbacksCountAggregateOutputType | null
    _avg: FeedbacksAvgAggregateOutputType | null
    _sum: FeedbacksSumAggregateOutputType | null
    _min: FeedbacksMinAggregateOutputType | null
    _max: FeedbacksMaxAggregateOutputType | null
  }

  type GetFeedbacksGroupByPayload<T extends feedbacksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbacksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbacksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbacksGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbacksGroupByOutputType[P]>
        }
      >
    >


  export type feedbacksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    reviewee_type?: boolean
    rating?: boolean
    tags?: boolean
    comments?: boolean
    is_public?: boolean
    company_response?: boolean
    responded_at?: boolean
    flagged_inappropriate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_feedbacks_to_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_feedbacks_from_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbacks"]>

  export type feedbacksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    reviewee_type?: boolean
    rating?: boolean
    tags?: boolean
    comments?: boolean
    is_public?: boolean
    company_response?: boolean
    responded_at?: boolean
    flagged_inappropriate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_feedbacks_to_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_feedbacks_from_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbacks"]>

  export type feedbacksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    reviewee_type?: boolean
    rating?: boolean
    tags?: boolean
    comments?: boolean
    is_public?: boolean
    company_response?: boolean
    responded_at?: boolean
    flagged_inappropriate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users_feedbacks_to_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_feedbacks_from_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbacks"]>

  export type feedbacksSelectScalar = {
    id?: boolean
    job_id?: boolean
    from_user_id?: boolean
    to_user_id?: boolean
    reviewee_type?: boolean
    rating?: boolean
    tags?: boolean
    comments?: boolean
    is_public?: boolean
    company_response?: boolean
    responded_at?: boolean
    flagged_inappropriate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type feedbacksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "from_user_id" | "to_user_id" | "reviewee_type" | "rating" | "tags" | "comments" | "is_public" | "company_response" | "responded_at" | "flagged_inappropriate" | "createdAt" | "updatedAt", ExtArgs["result"]["feedbacks"]>
  export type feedbacksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_feedbacks_to_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_feedbacks_from_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type feedbacksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_feedbacks_to_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_feedbacks_from_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type feedbacksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_feedbacks_to_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_feedbacks_from_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $feedbacksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feedbacks"
    objects: {
      users_feedbacks_to_user_idTousers: Prisma.$usersPayload<ExtArgs>
      users_feedbacks_from_user_idTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_id: string
      from_user_id: string
      to_user_id: string
      reviewee_type: $Enums.FeedbackType
      rating: number
      tags: Prisma.JsonValue | null
      comments: string | null
      is_public: boolean
      company_response: string | null
      responded_at: Date | null
      flagged_inappropriate: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedbacks"]>
    composites: {}
  }

  type feedbacksGetPayload<S extends boolean | null | undefined | feedbacksDefaultArgs> = $Result.GetResult<Prisma.$feedbacksPayload, S>

  type feedbacksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<feedbacksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbacksCountAggregateInputType | true
    }

  export interface feedbacksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feedbacks'], meta: { name: 'feedbacks' } }
    /**
     * Find zero or one Feedbacks that matches the filter.
     * @param {feedbacksFindUniqueArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feedbacksFindUniqueArgs>(args: SelectSubset<T, feedbacksFindUniqueArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedbacks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {feedbacksFindUniqueOrThrowArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feedbacksFindUniqueOrThrowArgs>(args: SelectSubset<T, feedbacksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksFindFirstArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feedbacksFindFirstArgs>(args?: SelectSubset<T, feedbacksFindFirstArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedbacks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksFindFirstOrThrowArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feedbacksFindFirstOrThrowArgs>(args?: SelectSubset<T, feedbacksFindFirstOrThrowArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedbacks.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedbacks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbacksWithIdOnly = await prisma.feedbacks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends feedbacksFindManyArgs>(args?: SelectSubset<T, feedbacksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedbacks.
     * @param {feedbacksCreateArgs} args - Arguments to create a Feedbacks.
     * @example
     * // Create one Feedbacks
     * const Feedbacks = await prisma.feedbacks.create({
     *   data: {
     *     // ... data to create a Feedbacks
     *   }
     * })
     * 
     */
    create<T extends feedbacksCreateArgs>(args: SelectSubset<T, feedbacksCreateArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {feedbacksCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedbacks = await prisma.feedbacks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feedbacksCreateManyArgs>(args?: SelectSubset<T, feedbacksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {feedbacksCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedbacks = await prisma.feedbacks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbacksWithIdOnly = await prisma.feedbacks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends feedbacksCreateManyAndReturnArgs>(args?: SelectSubset<T, feedbacksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedbacks.
     * @param {feedbacksDeleteArgs} args - Arguments to delete one Feedbacks.
     * @example
     * // Delete one Feedbacks
     * const Feedbacks = await prisma.feedbacks.delete({
     *   where: {
     *     // ... filter to delete one Feedbacks
     *   }
     * })
     * 
     */
    delete<T extends feedbacksDeleteArgs>(args: SelectSubset<T, feedbacksDeleteArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedbacks.
     * @param {feedbacksUpdateArgs} args - Arguments to update one Feedbacks.
     * @example
     * // Update one Feedbacks
     * const feedbacks = await prisma.feedbacks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feedbacksUpdateArgs>(args: SelectSubset<T, feedbacksUpdateArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {feedbacksDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedbacks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feedbacksDeleteManyArgs>(args?: SelectSubset<T, feedbacksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedbacks = await prisma.feedbacks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feedbacksUpdateManyArgs>(args: SelectSubset<T, feedbacksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {feedbacksUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedbacks = await prisma.feedbacks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbacksWithIdOnly = await prisma.feedbacks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends feedbacksUpdateManyAndReturnArgs>(args: SelectSubset<T, feedbacksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedbacks.
     * @param {feedbacksUpsertArgs} args - Arguments to update or create a Feedbacks.
     * @example
     * // Update or create a Feedbacks
     * const feedbacks = await prisma.feedbacks.upsert({
     *   create: {
     *     // ... data to create a Feedbacks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedbacks we want to update
     *   }
     * })
     */
    upsert<T extends feedbacksUpsertArgs>(args: SelectSubset<T, feedbacksUpsertArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedbacks.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends feedbacksCountArgs>(
      args?: Subset<T, feedbacksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbacksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbacksAggregateArgs>(args: Subset<T, FeedbacksAggregateArgs>): Prisma.PrismaPromise<GetFeedbacksAggregateType<T>>

    /**
     * Group by Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feedbacksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feedbacksGroupByArgs['orderBy'] }
        : { orderBy?: feedbacksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feedbacksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbacksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feedbacks model
   */
  readonly fields: feedbacksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feedbacks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feedbacksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_feedbacks_to_user_idTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_feedbacks_from_user_idTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feedbacks model
   */
  interface feedbacksFieldRefs {
    readonly id: FieldRef<"feedbacks", 'String'>
    readonly job_id: FieldRef<"feedbacks", 'String'>
    readonly from_user_id: FieldRef<"feedbacks", 'String'>
    readonly to_user_id: FieldRef<"feedbacks", 'String'>
    readonly reviewee_type: FieldRef<"feedbacks", 'FeedbackType'>
    readonly rating: FieldRef<"feedbacks", 'Int'>
    readonly tags: FieldRef<"feedbacks", 'Json'>
    readonly comments: FieldRef<"feedbacks", 'String'>
    readonly is_public: FieldRef<"feedbacks", 'Boolean'>
    readonly company_response: FieldRef<"feedbacks", 'String'>
    readonly responded_at: FieldRef<"feedbacks", 'DateTime'>
    readonly flagged_inappropriate: FieldRef<"feedbacks", 'Boolean'>
    readonly createdAt: FieldRef<"feedbacks", 'DateTime'>
    readonly updatedAt: FieldRef<"feedbacks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * feedbacks findUnique
   */
  export type feedbacksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks findUniqueOrThrow
   */
  export type feedbacksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks findFirst
   */
  export type feedbacksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * feedbacks findFirstOrThrow
   */
  export type feedbacksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * feedbacks findMany
   */
  export type feedbacksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feedbacks.
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * feedbacks create
   */
  export type feedbacksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * The data needed to create a feedbacks.
     */
    data: XOR<feedbacksCreateInput, feedbacksUncheckedCreateInput>
  }

  /**
   * feedbacks createMany
   */
  export type feedbacksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feedbacks.
     */
    data: feedbacksCreateManyInput | feedbacksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feedbacks createManyAndReturn
   */
  export type feedbacksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * The data used to create many feedbacks.
     */
    data: feedbacksCreateManyInput | feedbacksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * feedbacks update
   */
  export type feedbacksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * The data needed to update a feedbacks.
     */
    data: XOR<feedbacksUpdateInput, feedbacksUncheckedUpdateInput>
    /**
     * Choose, which feedbacks to update.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks updateMany
   */
  export type feedbacksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feedbacks.
     */
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyInput>
    /**
     * Filter which feedbacks to update
     */
    where?: feedbacksWhereInput
    /**
     * Limit how many feedbacks to update.
     */
    limit?: number
  }

  /**
   * feedbacks updateManyAndReturn
   */
  export type feedbacksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * The data used to update feedbacks.
     */
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyInput>
    /**
     * Filter which feedbacks to update
     */
    where?: feedbacksWhereInput
    /**
     * Limit how many feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * feedbacks upsert
   */
  export type feedbacksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * The filter to search for the feedbacks to update in case it exists.
     */
    where: feedbacksWhereUniqueInput
    /**
     * In case the feedbacks found by the `where` argument doesn't exist, create a new feedbacks with this data.
     */
    create: XOR<feedbacksCreateInput, feedbacksUncheckedCreateInput>
    /**
     * In case the feedbacks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feedbacksUpdateInput, feedbacksUncheckedUpdateInput>
  }

  /**
   * feedbacks delete
   */
  export type feedbacksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter which feedbacks to delete.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks deleteMany
   */
  export type feedbacksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbacks to delete
     */
    where?: feedbacksWhereInput
    /**
     * Limit how many feedbacks to delete.
     */
    limit?: number
  }

  /**
   * feedbacks without action
   */
  export type feedbacksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
  }


  /**
   * Model health_records
   */

  export type AggregateHealth_records = {
    _count: Health_recordsCountAggregateOutputType | null
    _min: Health_recordsMinAggregateOutputType | null
    _max: Health_recordsMaxAggregateOutputType | null
  }

  export type Health_recordsMinAggregateOutputType = {
    id: string | null
    patient_id: string | null
    record_type: $Enums.HealthRecordType | null
    title: string | null
    description: string | null
    file_url: string | null
    uploaded_by: string | null
    valid_from: Date | null
    valid_until: Date | null
    is_archived: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Health_recordsMaxAggregateOutputType = {
    id: string | null
    patient_id: string | null
    record_type: $Enums.HealthRecordType | null
    title: string | null
    description: string | null
    file_url: string | null
    uploaded_by: string | null
    valid_from: Date | null
    valid_until: Date | null
    is_archived: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Health_recordsCountAggregateOutputType = {
    id: number
    patient_id: number
    record_type: number
    title: number
    description: number
    file_url: number
    metadata: number
    uploaded_by: number
    valid_from: number
    valid_until: number
    is_archived: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Health_recordsMinAggregateInputType = {
    id?: true
    patient_id?: true
    record_type?: true
    title?: true
    description?: true
    file_url?: true
    uploaded_by?: true
    valid_from?: true
    valid_until?: true
    is_archived?: true
    created_at?: true
    updated_at?: true
  }

  export type Health_recordsMaxAggregateInputType = {
    id?: true
    patient_id?: true
    record_type?: true
    title?: true
    description?: true
    file_url?: true
    uploaded_by?: true
    valid_from?: true
    valid_until?: true
    is_archived?: true
    created_at?: true
    updated_at?: true
  }

  export type Health_recordsCountAggregateInputType = {
    id?: true
    patient_id?: true
    record_type?: true
    title?: true
    description?: true
    file_url?: true
    metadata?: true
    uploaded_by?: true
    valid_from?: true
    valid_until?: true
    is_archived?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Health_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which health_records to aggregate.
     */
    where?: health_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_records to fetch.
     */
    orderBy?: health_recordsOrderByWithRelationInput | health_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: health_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned health_records
    **/
    _count?: true | Health_recordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Health_recordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Health_recordsMaxAggregateInputType
  }

  export type GetHealth_recordsAggregateType<T extends Health_recordsAggregateArgs> = {
        [P in keyof T & keyof AggregateHealth_records]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealth_records[P]>
      : GetScalarType<T[P], AggregateHealth_records[P]>
  }




  export type health_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: health_recordsWhereInput
    orderBy?: health_recordsOrderByWithAggregationInput | health_recordsOrderByWithAggregationInput[]
    by: Health_recordsScalarFieldEnum[] | Health_recordsScalarFieldEnum
    having?: health_recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Health_recordsCountAggregateInputType | true
    _min?: Health_recordsMinAggregateInputType
    _max?: Health_recordsMaxAggregateInputType
  }

  export type Health_recordsGroupByOutputType = {
    id: string
    patient_id: string
    record_type: $Enums.HealthRecordType
    title: string
    description: string | null
    file_url: string | null
    metadata: JsonValue | null
    uploaded_by: string | null
    valid_from: Date | null
    valid_until: Date | null
    is_archived: boolean
    created_at: Date
    updated_at: Date
    _count: Health_recordsCountAggregateOutputType | null
    _min: Health_recordsMinAggregateOutputType | null
    _max: Health_recordsMaxAggregateOutputType | null
  }

  type GetHealth_recordsGroupByPayload<T extends health_recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Health_recordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Health_recordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Health_recordsGroupByOutputType[P]>
            : GetScalarType<T[P], Health_recordsGroupByOutputType[P]>
        }
      >
    >


  export type health_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    record_type?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    metadata?: boolean
    uploaded_by?: boolean
    valid_from?: boolean
    valid_until?: boolean
    is_archived?: boolean
    created_at?: boolean
    updated_at?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["health_records"]>

  export type health_recordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    record_type?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    metadata?: boolean
    uploaded_by?: boolean
    valid_from?: boolean
    valid_until?: boolean
    is_archived?: boolean
    created_at?: boolean
    updated_at?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["health_records"]>

  export type health_recordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    record_type?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    metadata?: boolean
    uploaded_by?: boolean
    valid_from?: boolean
    valid_until?: boolean
    is_archived?: boolean
    created_at?: boolean
    updated_at?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["health_records"]>

  export type health_recordsSelectScalar = {
    id?: boolean
    patient_id?: boolean
    record_type?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    metadata?: boolean
    uploaded_by?: boolean
    valid_from?: boolean
    valid_until?: boolean
    is_archived?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type health_recordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "record_type" | "title" | "description" | "file_url" | "metadata" | "uploaded_by" | "valid_from" | "valid_until" | "is_archived" | "created_at" | "updated_at", ExtArgs["result"]["health_records"]>
  export type health_recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type health_recordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type health_recordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }

  export type $health_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "health_records"
    objects: {
      patients: Prisma.$patientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patient_id: string
      record_type: $Enums.HealthRecordType
      title: string
      description: string | null
      file_url: string | null
      metadata: Prisma.JsonValue | null
      uploaded_by: string | null
      valid_from: Date | null
      valid_until: Date | null
      is_archived: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["health_records"]>
    composites: {}
  }

  type health_recordsGetPayload<S extends boolean | null | undefined | health_recordsDefaultArgs> = $Result.GetResult<Prisma.$health_recordsPayload, S>

  type health_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<health_recordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Health_recordsCountAggregateInputType | true
    }

  export interface health_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['health_records'], meta: { name: 'health_records' } }
    /**
     * Find zero or one Health_records that matches the filter.
     * @param {health_recordsFindUniqueArgs} args - Arguments to find a Health_records
     * @example
     * // Get one Health_records
     * const health_records = await prisma.health_records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends health_recordsFindUniqueArgs>(args: SelectSubset<T, health_recordsFindUniqueArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Health_records that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {health_recordsFindUniqueOrThrowArgs} args - Arguments to find a Health_records
     * @example
     * // Get one Health_records
     * const health_records = await prisma.health_records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends health_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, health_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Health_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_recordsFindFirstArgs} args - Arguments to find a Health_records
     * @example
     * // Get one Health_records
     * const health_records = await prisma.health_records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends health_recordsFindFirstArgs>(args?: SelectSubset<T, health_recordsFindFirstArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Health_records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_recordsFindFirstOrThrowArgs} args - Arguments to find a Health_records
     * @example
     * // Get one Health_records
     * const health_records = await prisma.health_records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends health_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, health_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Health_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Health_records
     * const health_records = await prisma.health_records.findMany()
     * 
     * // Get first 10 Health_records
     * const health_records = await prisma.health_records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const health_recordsWithIdOnly = await prisma.health_records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends health_recordsFindManyArgs>(args?: SelectSubset<T, health_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Health_records.
     * @param {health_recordsCreateArgs} args - Arguments to create a Health_records.
     * @example
     * // Create one Health_records
     * const Health_records = await prisma.health_records.create({
     *   data: {
     *     // ... data to create a Health_records
     *   }
     * })
     * 
     */
    create<T extends health_recordsCreateArgs>(args: SelectSubset<T, health_recordsCreateArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Health_records.
     * @param {health_recordsCreateManyArgs} args - Arguments to create many Health_records.
     * @example
     * // Create many Health_records
     * const health_records = await prisma.health_records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends health_recordsCreateManyArgs>(args?: SelectSubset<T, health_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Health_records and returns the data saved in the database.
     * @param {health_recordsCreateManyAndReturnArgs} args - Arguments to create many Health_records.
     * @example
     * // Create many Health_records
     * const health_records = await prisma.health_records.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Health_records and only return the `id`
     * const health_recordsWithIdOnly = await prisma.health_records.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends health_recordsCreateManyAndReturnArgs>(args?: SelectSubset<T, health_recordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Health_records.
     * @param {health_recordsDeleteArgs} args - Arguments to delete one Health_records.
     * @example
     * // Delete one Health_records
     * const Health_records = await prisma.health_records.delete({
     *   where: {
     *     // ... filter to delete one Health_records
     *   }
     * })
     * 
     */
    delete<T extends health_recordsDeleteArgs>(args: SelectSubset<T, health_recordsDeleteArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Health_records.
     * @param {health_recordsUpdateArgs} args - Arguments to update one Health_records.
     * @example
     * // Update one Health_records
     * const health_records = await prisma.health_records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends health_recordsUpdateArgs>(args: SelectSubset<T, health_recordsUpdateArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Health_records.
     * @param {health_recordsDeleteManyArgs} args - Arguments to filter Health_records to delete.
     * @example
     * // Delete a few Health_records
     * const { count } = await prisma.health_records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends health_recordsDeleteManyArgs>(args?: SelectSubset<T, health_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Health_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Health_records
     * const health_records = await prisma.health_records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends health_recordsUpdateManyArgs>(args: SelectSubset<T, health_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Health_records and returns the data updated in the database.
     * @param {health_recordsUpdateManyAndReturnArgs} args - Arguments to update many Health_records.
     * @example
     * // Update many Health_records
     * const health_records = await prisma.health_records.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Health_records and only return the `id`
     * const health_recordsWithIdOnly = await prisma.health_records.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends health_recordsUpdateManyAndReturnArgs>(args: SelectSubset<T, health_recordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Health_records.
     * @param {health_recordsUpsertArgs} args - Arguments to update or create a Health_records.
     * @example
     * // Update or create a Health_records
     * const health_records = await prisma.health_records.upsert({
     *   create: {
     *     // ... data to create a Health_records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Health_records we want to update
     *   }
     * })
     */
    upsert<T extends health_recordsUpsertArgs>(args: SelectSubset<T, health_recordsUpsertArgs<ExtArgs>>): Prisma__health_recordsClient<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Health_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_recordsCountArgs} args - Arguments to filter Health_records to count.
     * @example
     * // Count the number of Health_records
     * const count = await prisma.health_records.count({
     *   where: {
     *     // ... the filter for the Health_records we want to count
     *   }
     * })
    **/
    count<T extends health_recordsCountArgs>(
      args?: Subset<T, health_recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Health_recordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Health_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Health_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Health_recordsAggregateArgs>(args: Subset<T, Health_recordsAggregateArgs>): Prisma.PrismaPromise<GetHealth_recordsAggregateType<T>>

    /**
     * Group by Health_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {health_recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends health_recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: health_recordsGroupByArgs['orderBy'] }
        : { orderBy?: health_recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, health_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealth_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the health_records model
   */
  readonly fields: health_recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for health_records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__health_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends patientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientsDefaultArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the health_records model
   */
  interface health_recordsFieldRefs {
    readonly id: FieldRef<"health_records", 'String'>
    readonly patient_id: FieldRef<"health_records", 'String'>
    readonly record_type: FieldRef<"health_records", 'HealthRecordType'>
    readonly title: FieldRef<"health_records", 'String'>
    readonly description: FieldRef<"health_records", 'String'>
    readonly file_url: FieldRef<"health_records", 'String'>
    readonly metadata: FieldRef<"health_records", 'Json'>
    readonly uploaded_by: FieldRef<"health_records", 'String'>
    readonly valid_from: FieldRef<"health_records", 'DateTime'>
    readonly valid_until: FieldRef<"health_records", 'DateTime'>
    readonly is_archived: FieldRef<"health_records", 'Boolean'>
    readonly created_at: FieldRef<"health_records", 'DateTime'>
    readonly updated_at: FieldRef<"health_records", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * health_records findUnique
   */
  export type health_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * Filter, which health_records to fetch.
     */
    where: health_recordsWhereUniqueInput
  }

  /**
   * health_records findUniqueOrThrow
   */
  export type health_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * Filter, which health_records to fetch.
     */
    where: health_recordsWhereUniqueInput
  }

  /**
   * health_records findFirst
   */
  export type health_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * Filter, which health_records to fetch.
     */
    where?: health_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_records to fetch.
     */
    orderBy?: health_recordsOrderByWithRelationInput | health_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for health_records.
     */
    cursor?: health_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of health_records.
     */
    distinct?: Health_recordsScalarFieldEnum | Health_recordsScalarFieldEnum[]
  }

  /**
   * health_records findFirstOrThrow
   */
  export type health_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * Filter, which health_records to fetch.
     */
    where?: health_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_records to fetch.
     */
    orderBy?: health_recordsOrderByWithRelationInput | health_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for health_records.
     */
    cursor?: health_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of health_records.
     */
    distinct?: Health_recordsScalarFieldEnum | Health_recordsScalarFieldEnum[]
  }

  /**
   * health_records findMany
   */
  export type health_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * Filter, which health_records to fetch.
     */
    where?: health_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of health_records to fetch.
     */
    orderBy?: health_recordsOrderByWithRelationInput | health_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing health_records.
     */
    cursor?: health_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` health_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` health_records.
     */
    skip?: number
    distinct?: Health_recordsScalarFieldEnum | Health_recordsScalarFieldEnum[]
  }

  /**
   * health_records create
   */
  export type health_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * The data needed to create a health_records.
     */
    data: XOR<health_recordsCreateInput, health_recordsUncheckedCreateInput>
  }

  /**
   * health_records createMany
   */
  export type health_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many health_records.
     */
    data: health_recordsCreateManyInput | health_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * health_records createManyAndReturn
   */
  export type health_recordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * The data used to create many health_records.
     */
    data: health_recordsCreateManyInput | health_recordsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * health_records update
   */
  export type health_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * The data needed to update a health_records.
     */
    data: XOR<health_recordsUpdateInput, health_recordsUncheckedUpdateInput>
    /**
     * Choose, which health_records to update.
     */
    where: health_recordsWhereUniqueInput
  }

  /**
   * health_records updateMany
   */
  export type health_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update health_records.
     */
    data: XOR<health_recordsUpdateManyMutationInput, health_recordsUncheckedUpdateManyInput>
    /**
     * Filter which health_records to update
     */
    where?: health_recordsWhereInput
    /**
     * Limit how many health_records to update.
     */
    limit?: number
  }

  /**
   * health_records updateManyAndReturn
   */
  export type health_recordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * The data used to update health_records.
     */
    data: XOR<health_recordsUpdateManyMutationInput, health_recordsUncheckedUpdateManyInput>
    /**
     * Filter which health_records to update
     */
    where?: health_recordsWhereInput
    /**
     * Limit how many health_records to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * health_records upsert
   */
  export type health_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * The filter to search for the health_records to update in case it exists.
     */
    where: health_recordsWhereUniqueInput
    /**
     * In case the health_records found by the `where` argument doesn't exist, create a new health_records with this data.
     */
    create: XOR<health_recordsCreateInput, health_recordsUncheckedCreateInput>
    /**
     * In case the health_records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<health_recordsUpdateInput, health_recordsUncheckedUpdateInput>
  }

  /**
   * health_records delete
   */
  export type health_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    /**
     * Filter which health_records to delete.
     */
    where: health_recordsWhereUniqueInput
  }

  /**
   * health_records deleteMany
   */
  export type health_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which health_records to delete
     */
    where?: health_recordsWhereInput
    /**
     * Limit how many health_records to delete.
     */
    limit?: number
  }

  /**
   * health_records without action
   */
  export type health_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
  }


  /**
   * Model job_applications
   */

  export type AggregateJob_applications = {
    _count: Job_applicationsCountAggregateOutputType | null
    _min: Job_applicationsMinAggregateOutputType | null
    _max: Job_applicationsMaxAggregateOutputType | null
  }

  export type Job_applicationsMinAggregateOutputType = {
    id: string | null
    marketplace_job_id: string | null
    caregiver_id: string | null
    coverLetter: string | null
    status: string | null
    reviewed_by: string | null
    reviewed_at: Date | null
    review_notes: string | null
    created_at: Date | null
  }

  export type Job_applicationsMaxAggregateOutputType = {
    id: string | null
    marketplace_job_id: string | null
    caregiver_id: string | null
    coverLetter: string | null
    status: string | null
    reviewed_by: string | null
    reviewed_at: Date | null
    review_notes: string | null
    created_at: Date | null
  }

  export type Job_applicationsCountAggregateOutputType = {
    id: number
    marketplace_job_id: number
    caregiver_id: number
    coverLetter: number
    status: number
    reviewed_by: number
    reviewed_at: number
    review_notes: number
    created_at: number
    _all: number
  }


  export type Job_applicationsMinAggregateInputType = {
    id?: true
    marketplace_job_id?: true
    caregiver_id?: true
    coverLetter?: true
    status?: true
    reviewed_by?: true
    reviewed_at?: true
    review_notes?: true
    created_at?: true
  }

  export type Job_applicationsMaxAggregateInputType = {
    id?: true
    marketplace_job_id?: true
    caregiver_id?: true
    coverLetter?: true
    status?: true
    reviewed_by?: true
    reviewed_at?: true
    review_notes?: true
    created_at?: true
  }

  export type Job_applicationsCountAggregateInputType = {
    id?: true
    marketplace_job_id?: true
    caregiver_id?: true
    coverLetter?: true
    status?: true
    reviewed_by?: true
    reviewed_at?: true
    review_notes?: true
    created_at?: true
    _all?: true
  }

  export type Job_applicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_applications to aggregate.
     */
    where?: job_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_applications to fetch.
     */
    orderBy?: job_applicationsOrderByWithRelationInput | job_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_applications
    **/
    _count?: true | Job_applicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_applicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_applicationsMaxAggregateInputType
  }

  export type GetJob_applicationsAggregateType<T extends Job_applicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_applications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_applications[P]>
      : GetScalarType<T[P], AggregateJob_applications[P]>
  }




  export type job_applicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_applicationsWhereInput
    orderBy?: job_applicationsOrderByWithAggregationInput | job_applicationsOrderByWithAggregationInput[]
    by: Job_applicationsScalarFieldEnum[] | Job_applicationsScalarFieldEnum
    having?: job_applicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_applicationsCountAggregateInputType | true
    _min?: Job_applicationsMinAggregateInputType
    _max?: Job_applicationsMaxAggregateInputType
  }

  export type Job_applicationsGroupByOutputType = {
    id: string
    marketplace_job_id: string
    caregiver_id: string
    coverLetter: string | null
    status: string
    reviewed_by: string | null
    reviewed_at: Date | null
    review_notes: string | null
    created_at: Date
    _count: Job_applicationsCountAggregateOutputType | null
    _min: Job_applicationsMinAggregateOutputType | null
    _max: Job_applicationsMaxAggregateOutputType | null
  }

  type GetJob_applicationsGroupByPayload<T extends job_applicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_applicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_applicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_applicationsGroupByOutputType[P]>
            : GetScalarType<T[P], Job_applicationsGroupByOutputType[P]>
        }
      >
    >


  export type job_applicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketplace_job_id?: boolean
    caregiver_id?: boolean
    coverLetter?: boolean
    status?: boolean
    reviewed_by?: boolean
    reviewed_at?: boolean
    review_notes?: boolean
    created_at?: boolean
    users?: boolean | job_applications$usersArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    marketplace_jobs?: boolean | marketplace_jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_applications"]>

  export type job_applicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketplace_job_id?: boolean
    caregiver_id?: boolean
    coverLetter?: boolean
    status?: boolean
    reviewed_by?: boolean
    reviewed_at?: boolean
    review_notes?: boolean
    created_at?: boolean
    users?: boolean | job_applications$usersArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    marketplace_jobs?: boolean | marketplace_jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_applications"]>

  export type job_applicationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketplace_job_id?: boolean
    caregiver_id?: boolean
    coverLetter?: boolean
    status?: boolean
    reviewed_by?: boolean
    reviewed_at?: boolean
    review_notes?: boolean
    created_at?: boolean
    users?: boolean | job_applications$usersArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    marketplace_jobs?: boolean | marketplace_jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job_applications"]>

  export type job_applicationsSelectScalar = {
    id?: boolean
    marketplace_job_id?: boolean
    caregiver_id?: boolean
    coverLetter?: boolean
    status?: boolean
    reviewed_by?: boolean
    reviewed_at?: boolean
    review_notes?: boolean
    created_at?: boolean
  }

  export type job_applicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketplace_job_id" | "caregiver_id" | "coverLetter" | "status" | "reviewed_by" | "reviewed_at" | "review_notes" | "created_at", ExtArgs["result"]["job_applications"]>
  export type job_applicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | job_applications$usersArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    marketplace_jobs?: boolean | marketplace_jobsDefaultArgs<ExtArgs>
  }
  export type job_applicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | job_applications$usersArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    marketplace_jobs?: boolean | marketplace_jobsDefaultArgs<ExtArgs>
  }
  export type job_applicationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | job_applications$usersArgs<ExtArgs>
    caregivers?: boolean | caregiversDefaultArgs<ExtArgs>
    marketplace_jobs?: boolean | marketplace_jobsDefaultArgs<ExtArgs>
  }

  export type $job_applicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_applications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      caregivers: Prisma.$caregiversPayload<ExtArgs>
      marketplace_jobs: Prisma.$marketplace_jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      marketplace_job_id: string
      caregiver_id: string
      coverLetter: string | null
      status: string
      reviewed_by: string | null
      reviewed_at: Date | null
      review_notes: string | null
      created_at: Date
    }, ExtArgs["result"]["job_applications"]>
    composites: {}
  }

  type job_applicationsGetPayload<S extends boolean | null | undefined | job_applicationsDefaultArgs> = $Result.GetResult<Prisma.$job_applicationsPayload, S>

  type job_applicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_applicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_applicationsCountAggregateInputType | true
    }

  export interface job_applicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_applications'], meta: { name: 'job_applications' } }
    /**
     * Find zero or one Job_applications that matches the filter.
     * @param {job_applicationsFindUniqueArgs} args - Arguments to find a Job_applications
     * @example
     * // Get one Job_applications
     * const job_applications = await prisma.job_applications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_applicationsFindUniqueArgs>(args: SelectSubset<T, job_applicationsFindUniqueArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_applications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_applicationsFindUniqueOrThrowArgs} args - Arguments to find a Job_applications
     * @example
     * // Get one Job_applications
     * const job_applications = await prisma.job_applications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_applicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, job_applicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_applicationsFindFirstArgs} args - Arguments to find a Job_applications
     * @example
     * // Get one Job_applications
     * const job_applications = await prisma.job_applications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_applicationsFindFirstArgs>(args?: SelectSubset<T, job_applicationsFindFirstArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_applications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_applicationsFindFirstOrThrowArgs} args - Arguments to find a Job_applications
     * @example
     * // Get one Job_applications
     * const job_applications = await prisma.job_applications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_applicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, job_applicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_applicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_applications
     * const job_applications = await prisma.job_applications.findMany()
     * 
     * // Get first 10 Job_applications
     * const job_applications = await prisma.job_applications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_applicationsWithIdOnly = await prisma.job_applications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_applicationsFindManyArgs>(args?: SelectSubset<T, job_applicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_applications.
     * @param {job_applicationsCreateArgs} args - Arguments to create a Job_applications.
     * @example
     * // Create one Job_applications
     * const Job_applications = await prisma.job_applications.create({
     *   data: {
     *     // ... data to create a Job_applications
     *   }
     * })
     * 
     */
    create<T extends job_applicationsCreateArgs>(args: SelectSubset<T, job_applicationsCreateArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_applications.
     * @param {job_applicationsCreateManyArgs} args - Arguments to create many Job_applications.
     * @example
     * // Create many Job_applications
     * const job_applications = await prisma.job_applications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_applicationsCreateManyArgs>(args?: SelectSubset<T, job_applicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Job_applications and returns the data saved in the database.
     * @param {job_applicationsCreateManyAndReturnArgs} args - Arguments to create many Job_applications.
     * @example
     * // Create many Job_applications
     * const job_applications = await prisma.job_applications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Job_applications and only return the `id`
     * const job_applicationsWithIdOnly = await prisma.job_applications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends job_applicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, job_applicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job_applications.
     * @param {job_applicationsDeleteArgs} args - Arguments to delete one Job_applications.
     * @example
     * // Delete one Job_applications
     * const Job_applications = await prisma.job_applications.delete({
     *   where: {
     *     // ... filter to delete one Job_applications
     *   }
     * })
     * 
     */
    delete<T extends job_applicationsDeleteArgs>(args: SelectSubset<T, job_applicationsDeleteArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_applications.
     * @param {job_applicationsUpdateArgs} args - Arguments to update one Job_applications.
     * @example
     * // Update one Job_applications
     * const job_applications = await prisma.job_applications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_applicationsUpdateArgs>(args: SelectSubset<T, job_applicationsUpdateArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_applications.
     * @param {job_applicationsDeleteManyArgs} args - Arguments to filter Job_applications to delete.
     * @example
     * // Delete a few Job_applications
     * const { count } = await prisma.job_applications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_applicationsDeleteManyArgs>(args?: SelectSubset<T, job_applicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_applicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_applications
     * const job_applications = await prisma.job_applications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_applicationsUpdateManyArgs>(args: SelectSubset<T, job_applicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_applications and returns the data updated in the database.
     * @param {job_applicationsUpdateManyAndReturnArgs} args - Arguments to update many Job_applications.
     * @example
     * // Update many Job_applications
     * const job_applications = await prisma.job_applications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Job_applications and only return the `id`
     * const job_applicationsWithIdOnly = await prisma.job_applications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends job_applicationsUpdateManyAndReturnArgs>(args: SelectSubset<T, job_applicationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job_applications.
     * @param {job_applicationsUpsertArgs} args - Arguments to update or create a Job_applications.
     * @example
     * // Update or create a Job_applications
     * const job_applications = await prisma.job_applications.upsert({
     *   create: {
     *     // ... data to create a Job_applications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_applications we want to update
     *   }
     * })
     */
    upsert<T extends job_applicationsUpsertArgs>(args: SelectSubset<T, job_applicationsUpsertArgs<ExtArgs>>): Prisma__job_applicationsClient<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_applicationsCountArgs} args - Arguments to filter Job_applications to count.
     * @example
     * // Count the number of Job_applications
     * const count = await prisma.job_applications.count({
     *   where: {
     *     // ... the filter for the Job_applications we want to count
     *   }
     * })
    **/
    count<T extends job_applicationsCountArgs>(
      args?: Subset<T, job_applicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_applicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_applicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_applicationsAggregateArgs>(args: Subset<T, Job_applicationsAggregateArgs>): Prisma.PrismaPromise<GetJob_applicationsAggregateType<T>>

    /**
     * Group by Job_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_applicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_applicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_applicationsGroupByArgs['orderBy'] }
        : { orderBy?: job_applicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_applicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_applicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_applications model
   */
  readonly fields: job_applicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_applications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_applicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends job_applications$usersArgs<ExtArgs> = {}>(args?: Subset<T, job_applications$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    caregivers<T extends caregiversDefaultArgs<ExtArgs> = {}>(args?: Subset<T, caregiversDefaultArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marketplace_jobs<T extends marketplace_jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, marketplace_jobsDefaultArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_applications model
   */
  interface job_applicationsFieldRefs {
    readonly id: FieldRef<"job_applications", 'String'>
    readonly marketplace_job_id: FieldRef<"job_applications", 'String'>
    readonly caregiver_id: FieldRef<"job_applications", 'String'>
    readonly coverLetter: FieldRef<"job_applications", 'String'>
    readonly status: FieldRef<"job_applications", 'String'>
    readonly reviewed_by: FieldRef<"job_applications", 'String'>
    readonly reviewed_at: FieldRef<"job_applications", 'DateTime'>
    readonly review_notes: FieldRef<"job_applications", 'String'>
    readonly created_at: FieldRef<"job_applications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * job_applications findUnique
   */
  export type job_applicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which job_applications to fetch.
     */
    where: job_applicationsWhereUniqueInput
  }

  /**
   * job_applications findUniqueOrThrow
   */
  export type job_applicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which job_applications to fetch.
     */
    where: job_applicationsWhereUniqueInput
  }

  /**
   * job_applications findFirst
   */
  export type job_applicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which job_applications to fetch.
     */
    where?: job_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_applications to fetch.
     */
    orderBy?: job_applicationsOrderByWithRelationInput | job_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_applications.
     */
    cursor?: job_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_applications.
     */
    distinct?: Job_applicationsScalarFieldEnum | Job_applicationsScalarFieldEnum[]
  }

  /**
   * job_applications findFirstOrThrow
   */
  export type job_applicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which job_applications to fetch.
     */
    where?: job_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_applications to fetch.
     */
    orderBy?: job_applicationsOrderByWithRelationInput | job_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_applications.
     */
    cursor?: job_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_applications.
     */
    distinct?: Job_applicationsScalarFieldEnum | Job_applicationsScalarFieldEnum[]
  }

  /**
   * job_applications findMany
   */
  export type job_applicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which job_applications to fetch.
     */
    where?: job_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_applications to fetch.
     */
    orderBy?: job_applicationsOrderByWithRelationInput | job_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_applications.
     */
    cursor?: job_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_applications.
     */
    skip?: number
    distinct?: Job_applicationsScalarFieldEnum | Job_applicationsScalarFieldEnum[]
  }

  /**
   * job_applications create
   */
  export type job_applicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a job_applications.
     */
    data: XOR<job_applicationsCreateInput, job_applicationsUncheckedCreateInput>
  }

  /**
   * job_applications createMany
   */
  export type job_applicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_applications.
     */
    data: job_applicationsCreateManyInput | job_applicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_applications createManyAndReturn
   */
  export type job_applicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * The data used to create many job_applications.
     */
    data: job_applicationsCreateManyInput | job_applicationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_applications update
   */
  export type job_applicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a job_applications.
     */
    data: XOR<job_applicationsUpdateInput, job_applicationsUncheckedUpdateInput>
    /**
     * Choose, which job_applications to update.
     */
    where: job_applicationsWhereUniqueInput
  }

  /**
   * job_applications updateMany
   */
  export type job_applicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_applications.
     */
    data: XOR<job_applicationsUpdateManyMutationInput, job_applicationsUncheckedUpdateManyInput>
    /**
     * Filter which job_applications to update
     */
    where?: job_applicationsWhereInput
    /**
     * Limit how many job_applications to update.
     */
    limit?: number
  }

  /**
   * job_applications updateManyAndReturn
   */
  export type job_applicationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * The data used to update job_applications.
     */
    data: XOR<job_applicationsUpdateManyMutationInput, job_applicationsUncheckedUpdateManyInput>
    /**
     * Filter which job_applications to update
     */
    where?: job_applicationsWhereInput
    /**
     * Limit how many job_applications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * job_applications upsert
   */
  export type job_applicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the job_applications to update in case it exists.
     */
    where: job_applicationsWhereUniqueInput
    /**
     * In case the job_applications found by the `where` argument doesn't exist, create a new job_applications with this data.
     */
    create: XOR<job_applicationsCreateInput, job_applicationsUncheckedCreateInput>
    /**
     * In case the job_applications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_applicationsUpdateInput, job_applicationsUncheckedUpdateInput>
  }

  /**
   * job_applications delete
   */
  export type job_applicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    /**
     * Filter which job_applications to delete.
     */
    where: job_applicationsWhereUniqueInput
  }

  /**
   * job_applications deleteMany
   */
  export type job_applicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_applications to delete
     */
    where?: job_applicationsWhereInput
    /**
     * Limit how many job_applications to delete.
     */
    limit?: number
  }

  /**
   * job_applications.users
   */
  export type job_applications$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * job_applications without action
   */
  export type job_applicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
  }


  /**
   * Model jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    total_price: Decimal | null
    commission_amount: Decimal | null
    payout_amount: Decimal | null
  }

  export type JobsSumAggregateOutputType = {
    total_price: Decimal | null
    commission_amount: Decimal | null
    payout_amount: Decimal | null
  }

  export type JobsMinAggregateOutputType = {
    id: string | null
    package_id: string | null
    patient_id: string | null
    company_id: string | null
    guardian_id: string | null
    start_date: Date | null
    end_date: Date | null
    status: $Enums.JobStatus | null
    total_price: Decimal | null
    commission_amount: Decimal | null
    payout_amount: Decimal | null
    special_instructions: string | null
    completion_notes: string | null
    cancelled_reason: string | null
    cancelled_at: Date | null
    cancelled_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type JobsMaxAggregateOutputType = {
    id: string | null
    package_id: string | null
    patient_id: string | null
    company_id: string | null
    guardian_id: string | null
    start_date: Date | null
    end_date: Date | null
    status: $Enums.JobStatus | null
    total_price: Decimal | null
    commission_amount: Decimal | null
    payout_amount: Decimal | null
    special_instructions: string | null
    completion_notes: string | null
    cancelled_reason: string | null
    cancelled_at: Date | null
    cancelled_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type JobsCountAggregateOutputType = {
    id: number
    package_id: number
    patient_id: number
    company_id: number
    guardian_id: number
    start_date: number
    end_date: number
    status: number
    total_price: number
    commission_amount: number
    payout_amount: number
    special_instructions: number
    completion_notes: number
    cancelled_reason: number
    cancelled_at: number
    cancelled_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    total_price?: true
    commission_amount?: true
    payout_amount?: true
  }

  export type JobsSumAggregateInputType = {
    total_price?: true
    commission_amount?: true
    payout_amount?: true
  }

  export type JobsMinAggregateInputType = {
    id?: true
    package_id?: true
    patient_id?: true
    company_id?: true
    guardian_id?: true
    start_date?: true
    end_date?: true
    status?: true
    total_price?: true
    commission_amount?: true
    payout_amount?: true
    special_instructions?: true
    completion_notes?: true
    cancelled_reason?: true
    cancelled_at?: true
    cancelled_by?: true
    created_at?: true
    updated_at?: true
  }

  export type JobsMaxAggregateInputType = {
    id?: true
    package_id?: true
    patient_id?: true
    company_id?: true
    guardian_id?: true
    start_date?: true
    end_date?: true
    status?: true
    total_price?: true
    commission_amount?: true
    payout_amount?: true
    special_instructions?: true
    completion_notes?: true
    cancelled_reason?: true
    cancelled_at?: true
    cancelled_by?: true
    created_at?: true
    updated_at?: true
  }

  export type JobsCountAggregateInputType = {
    id?: true
    package_id?: true
    patient_id?: true
    company_id?: true
    guardian_id?: true
    start_date?: true
    end_date?: true
    status?: true
    total_price?: true
    commission_amount?: true
    payout_amount?: true
    special_instructions?: true
    completion_notes?: true
    cancelled_reason?: true
    cancelled_at?: true
    cancelled_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to aggregate.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithAggregationInput | jobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    id: string
    package_id: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date
    end_date: Date
    status: $Enums.JobStatus
    total_price: Decimal
    commission_amount: Decimal
    payout_amount: Decimal
    special_instructions: string | null
    completion_notes: string | null
    cancelled_reason: string | null
    cancelled_at: Date | null
    cancelled_by: string | null
    created_at: Date
    updated_at: Date
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    package_id?: boolean
    patient_id?: boolean
    company_id?: boolean
    guardian_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    total_price?: boolean
    commission_amount?: boolean
    payout_amount?: boolean
    special_instructions?: boolean
    completion_notes?: boolean
    cancelled_reason?: boolean
    cancelled_at?: boolean
    cancelled_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    assignments?: boolean | jobs$assignmentsArgs<ExtArgs>
    care_logs?: boolean | jobs$care_logsArgs<ExtArgs>
    disputes?: boolean | jobs$disputesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
    payments?: boolean | jobs$paymentsArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    package_id?: boolean
    patient_id?: boolean
    company_id?: boolean
    guardian_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    total_price?: boolean
    commission_amount?: boolean
    payout_amount?: boolean
    special_instructions?: boolean
    completion_notes?: boolean
    cancelled_reason?: boolean
    cancelled_at?: boolean
    cancelled_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    package_id?: boolean
    patient_id?: boolean
    company_id?: boolean
    guardian_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    total_price?: boolean
    commission_amount?: boolean
    payout_amount?: boolean
    special_instructions?: boolean
    completion_notes?: boolean
    cancelled_reason?: boolean
    cancelled_at?: boolean
    cancelled_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectScalar = {
    id?: boolean
    package_id?: boolean
    patient_id?: boolean
    company_id?: boolean
    guardian_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    total_price?: boolean
    commission_amount?: boolean
    payout_amount?: boolean
    special_instructions?: boolean
    completion_notes?: boolean
    cancelled_reason?: boolean
    cancelled_at?: boolean
    cancelled_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "package_id" | "patient_id" | "company_id" | "guardian_id" | "start_date" | "end_date" | "status" | "total_price" | "commission_amount" | "payout_amount" | "special_instructions" | "completion_notes" | "cancelled_reason" | "cancelled_at" | "cancelled_by" | "created_at" | "updated_at", ExtArgs["result"]["jobs"]>
  export type jobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | jobs$assignmentsArgs<ExtArgs>
    care_logs?: boolean | jobs$care_logsArgs<ExtArgs>
    disputes?: boolean | jobs$disputesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
    payments?: boolean | jobs$paymentsArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type jobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }
  export type jobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    packages?: boolean | packagesDefaultArgs<ExtArgs>
  }

  export type $jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobs"
    objects: {
      assignments: Prisma.$assignmentsPayload<ExtArgs>[]
      care_logs: Prisma.$care_logsPayload<ExtArgs>[]
      disputes: Prisma.$disputesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      companies: Prisma.$companiesPayload<ExtArgs>
      patients: Prisma.$patientsPayload<ExtArgs>
      packages: Prisma.$packagesPayload<ExtArgs>
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      package_id: string
      patient_id: string
      company_id: string
      guardian_id: string
      start_date: Date
      end_date: Date
      status: $Enums.JobStatus
      total_price: Prisma.Decimal
      commission_amount: Prisma.Decimal
      payout_amount: Prisma.Decimal
      special_instructions: string | null
      completion_notes: string | null
      cancelled_reason: string | null
      cancelled_at: Date | null
      cancelled_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type jobsGetPayload<S extends boolean | null | undefined | jobsDefaultArgs> = $Result.GetResult<Prisma.$jobsPayload, S>

  type jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobs'], meta: { name: 'jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {jobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobsFindUniqueArgs>(args: SelectSubset<T, jobsFindUniqueArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobsFindFirstArgs>(args?: SelectSubset<T, jobsFindFirstArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobsFindManyArgs>(args?: SelectSubset<T, jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobs.
     * @param {jobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends jobsCreateArgs>(args: SelectSubset<T, jobsCreateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {jobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobsCreateManyArgs>(args?: SelectSubset<T, jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {jobsCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Jobs.
     * @param {jobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends jobsDeleteArgs>(args: SelectSubset<T, jobsDeleteArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobs.
     * @param {jobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobsUpdateArgs>(args: SelectSubset<T, jobsUpdateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {jobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobsDeleteManyArgs>(args?: SelectSubset<T, jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobsUpdateManyArgs>(args: SelectSubset<T, jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {jobsUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends jobsUpdateManyAndReturnArgs>(args: SelectSubset<T, jobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Jobs.
     * @param {jobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends jobsUpsertArgs>(args: SelectSubset<T, jobsUpsertArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobsCountArgs>(
      args?: Subset<T, jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobsGroupByArgs['orderBy'] }
        : { orderBy?: jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobs model
   */
  readonly fields: jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends jobs$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    care_logs<T extends jobs$care_logsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$care_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputes<T extends jobs$disputesArgs<ExtArgs> = {}>(args?: Subset<T, jobs$disputesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patients<T extends patientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientsDefaultArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    packages<T extends packagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, packagesDefaultArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends jobs$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobs model
   */
  interface jobsFieldRefs {
    readonly id: FieldRef<"jobs", 'String'>
    readonly package_id: FieldRef<"jobs", 'String'>
    readonly patient_id: FieldRef<"jobs", 'String'>
    readonly company_id: FieldRef<"jobs", 'String'>
    readonly guardian_id: FieldRef<"jobs", 'String'>
    readonly start_date: FieldRef<"jobs", 'DateTime'>
    readonly end_date: FieldRef<"jobs", 'DateTime'>
    readonly status: FieldRef<"jobs", 'JobStatus'>
    readonly total_price: FieldRef<"jobs", 'Decimal'>
    readonly commission_amount: FieldRef<"jobs", 'Decimal'>
    readonly payout_amount: FieldRef<"jobs", 'Decimal'>
    readonly special_instructions: FieldRef<"jobs", 'String'>
    readonly completion_notes: FieldRef<"jobs", 'String'>
    readonly cancelled_reason: FieldRef<"jobs", 'String'>
    readonly cancelled_at: FieldRef<"jobs", 'DateTime'>
    readonly cancelled_by: FieldRef<"jobs", 'String'>
    readonly created_at: FieldRef<"jobs", 'DateTime'>
    readonly updated_at: FieldRef<"jobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * jobs findUnique
   */
  export type jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findUniqueOrThrow
   */
  export type jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findFirst
   */
  export type jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findFirstOrThrow
   */
  export type jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findMany
   */
  export type jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs create
   */
  export type jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The data needed to create a jobs.
     */
    data: XOR<jobsCreateInput, jobsUncheckedCreateInput>
  }

  /**
   * jobs createMany
   */
  export type jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobs createManyAndReturn
   */
  export type jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobs update
   */
  export type jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The data needed to update a jobs.
     */
    data: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
    /**
     * Choose, which jobs to update.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs updateMany
   */
  export type jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
  }

  /**
   * jobs updateManyAndReturn
   */
  export type jobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobs upsert
   */
  export type jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The filter to search for the jobs to update in case it exists.
     */
    where: jobsWhereUniqueInput
    /**
     * In case the jobs found by the `where` argument doesn't exist, create a new jobs with this data.
     */
    create: XOR<jobsCreateInput, jobsUncheckedCreateInput>
    /**
     * In case the jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
  }

  /**
   * jobs delete
   */
  export type jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter which jobs to delete.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs deleteMany
   */
  export type jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to delete.
     */
    limit?: number
  }

  /**
   * jobs.assignments
   */
  export type jobs$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    where?: assignmentsWhereInput
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    cursor?: assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * jobs.care_logs
   */
  export type jobs$care_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    where?: care_logsWhereInput
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    cursor?: care_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Care_logsScalarFieldEnum | Care_logsScalarFieldEnum[]
  }

  /**
   * jobs.disputes
   */
  export type jobs$disputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    where?: disputesWhereInput
    orderBy?: disputesOrderByWithRelationInput | disputesOrderByWithRelationInput[]
    cursor?: disputesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputesScalarFieldEnum | DisputesScalarFieldEnum[]
  }

  /**
   * jobs.payments
   */
  export type jobs$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * jobs without action
   */
  export type jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
  }


  /**
   * Model marketplace_jobs
   */

  export type AggregateMarketplace_jobs = {
    _count: Marketplace_jobsCountAggregateOutputType | null
    _avg: Marketplace_jobsAvgAggregateOutputType | null
    _sum: Marketplace_jobsSumAggregateOutputType | null
    _min: Marketplace_jobsMinAggregateOutputType | null
    _max: Marketplace_jobsMaxAggregateOutputType | null
  }

  export type Marketplace_jobsAvgAggregateOutputType = {
    duration_days: number | null
    hours_per_day: number | null
    offered_rate: Decimal | null
    applications_count: number | null
  }

  export type Marketplace_jobsSumAggregateOutputType = {
    duration_days: number | null
    hours_per_day: number | null
    offered_rate: Decimal | null
    applications_count: number | null
  }

  export type Marketplace_jobsMinAggregateOutputType = {
    id: string | null
    company_id: string | null
    title: string | null
    description: string | null
    location: string | null
    start_date: Date | null
    duration_days: number | null
    hours_per_day: number | null
    offered_rate: Decimal | null
    status: string | null
    applications_count: number | null
    filled_by: string | null
    filled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Marketplace_jobsMaxAggregateOutputType = {
    id: string | null
    company_id: string | null
    title: string | null
    description: string | null
    location: string | null
    start_date: Date | null
    duration_days: number | null
    hours_per_day: number | null
    offered_rate: Decimal | null
    status: string | null
    applications_count: number | null
    filled_by: string | null
    filled_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Marketplace_jobsCountAggregateOutputType = {
    id: number
    company_id: number
    title: number
    description: number
    location: number
    required_skills: number
    start_date: number
    duration_days: number
    hours_per_day: number
    offered_rate: number
    status: number
    applications_count: number
    filled_by: number
    filled_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Marketplace_jobsAvgAggregateInputType = {
    duration_days?: true
    hours_per_day?: true
    offered_rate?: true
    applications_count?: true
  }

  export type Marketplace_jobsSumAggregateInputType = {
    duration_days?: true
    hours_per_day?: true
    offered_rate?: true
    applications_count?: true
  }

  export type Marketplace_jobsMinAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    description?: true
    location?: true
    start_date?: true
    duration_days?: true
    hours_per_day?: true
    offered_rate?: true
    status?: true
    applications_count?: true
    filled_by?: true
    filled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Marketplace_jobsMaxAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    description?: true
    location?: true
    start_date?: true
    duration_days?: true
    hours_per_day?: true
    offered_rate?: true
    status?: true
    applications_count?: true
    filled_by?: true
    filled_at?: true
    created_at?: true
    updated_at?: true
  }

  export type Marketplace_jobsCountAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    description?: true
    location?: true
    required_skills?: true
    start_date?: true
    duration_days?: true
    hours_per_day?: true
    offered_rate?: true
    status?: true
    applications_count?: true
    filled_by?: true
    filled_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Marketplace_jobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marketplace_jobs to aggregate.
     */
    where?: marketplace_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketplace_jobs to fetch.
     */
    orderBy?: marketplace_jobsOrderByWithRelationInput | marketplace_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marketplace_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketplace_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketplace_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned marketplace_jobs
    **/
    _count?: true | Marketplace_jobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Marketplace_jobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Marketplace_jobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Marketplace_jobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Marketplace_jobsMaxAggregateInputType
  }

  export type GetMarketplace_jobsAggregateType<T extends Marketplace_jobsAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplace_jobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplace_jobs[P]>
      : GetScalarType<T[P], AggregateMarketplace_jobs[P]>
  }




  export type marketplace_jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marketplace_jobsWhereInput
    orderBy?: marketplace_jobsOrderByWithAggregationInput | marketplace_jobsOrderByWithAggregationInput[]
    by: Marketplace_jobsScalarFieldEnum[] | Marketplace_jobsScalarFieldEnum
    having?: marketplace_jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Marketplace_jobsCountAggregateInputType | true
    _avg?: Marketplace_jobsAvgAggregateInputType
    _sum?: Marketplace_jobsSumAggregateInputType
    _min?: Marketplace_jobsMinAggregateInputType
    _max?: Marketplace_jobsMaxAggregateInputType
  }

  export type Marketplace_jobsGroupByOutputType = {
    id: string
    company_id: string
    title: string
    description: string
    location: string
    required_skills: JsonValue
    start_date: Date
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal
    status: string
    applications_count: number
    filled_by: string | null
    filled_at: Date | null
    created_at: Date
    updated_at: Date
    _count: Marketplace_jobsCountAggregateOutputType | null
    _avg: Marketplace_jobsAvgAggregateOutputType | null
    _sum: Marketplace_jobsSumAggregateOutputType | null
    _min: Marketplace_jobsMinAggregateOutputType | null
    _max: Marketplace_jobsMaxAggregateOutputType | null
  }

  type GetMarketplace_jobsGroupByPayload<T extends marketplace_jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Marketplace_jobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Marketplace_jobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Marketplace_jobsGroupByOutputType[P]>
            : GetScalarType<T[P], Marketplace_jobsGroupByOutputType[P]>
        }
      >
    >


  export type marketplace_jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    required_skills?: boolean
    start_date?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    offered_rate?: boolean
    status?: boolean
    applications_count?: boolean
    filled_by?: boolean
    filled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    job_applications?: boolean | marketplace_jobs$job_applicationsArgs<ExtArgs>
    caregivers?: boolean | marketplace_jobs$caregiversArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    _count?: boolean | Marketplace_jobsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplace_jobs"]>

  export type marketplace_jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    required_skills?: boolean
    start_date?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    offered_rate?: boolean
    status?: boolean
    applications_count?: boolean
    filled_by?: boolean
    filled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    caregivers?: boolean | marketplace_jobs$caregiversArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplace_jobs"]>

  export type marketplace_jobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    required_skills?: boolean
    start_date?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    offered_rate?: boolean
    status?: boolean
    applications_count?: boolean
    filled_by?: boolean
    filled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    caregivers?: boolean | marketplace_jobs$caregiversArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplace_jobs"]>

  export type marketplace_jobsSelectScalar = {
    id?: boolean
    company_id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    required_skills?: boolean
    start_date?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    offered_rate?: boolean
    status?: boolean
    applications_count?: boolean
    filled_by?: boolean
    filled_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type marketplace_jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "title" | "description" | "location" | "required_skills" | "start_date" | "duration_days" | "hours_per_day" | "offered_rate" | "status" | "applications_count" | "filled_by" | "filled_at" | "created_at" | "updated_at", ExtArgs["result"]["marketplace_jobs"]>
  export type marketplace_jobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job_applications?: boolean | marketplace_jobs$job_applicationsArgs<ExtArgs>
    caregivers?: boolean | marketplace_jobs$caregiversArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    _count?: boolean | Marketplace_jobsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type marketplace_jobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers?: boolean | marketplace_jobs$caregiversArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type marketplace_jobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caregivers?: boolean | marketplace_jobs$caregiversArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $marketplace_jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "marketplace_jobs"
    objects: {
      job_applications: Prisma.$job_applicationsPayload<ExtArgs>[]
      caregivers: Prisma.$caregiversPayload<ExtArgs> | null
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company_id: string
      title: string
      description: string
      location: string
      required_skills: Prisma.JsonValue
      start_date: Date
      duration_days: number
      hours_per_day: number
      offered_rate: Prisma.Decimal
      status: string
      applications_count: number
      filled_by: string | null
      filled_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["marketplace_jobs"]>
    composites: {}
  }

  type marketplace_jobsGetPayload<S extends boolean | null | undefined | marketplace_jobsDefaultArgs> = $Result.GetResult<Prisma.$marketplace_jobsPayload, S>

  type marketplace_jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<marketplace_jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Marketplace_jobsCountAggregateInputType | true
    }

  export interface marketplace_jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['marketplace_jobs'], meta: { name: 'marketplace_jobs' } }
    /**
     * Find zero or one Marketplace_jobs that matches the filter.
     * @param {marketplace_jobsFindUniqueArgs} args - Arguments to find a Marketplace_jobs
     * @example
     * // Get one Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends marketplace_jobsFindUniqueArgs>(args: SelectSubset<T, marketplace_jobsFindUniqueArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Marketplace_jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {marketplace_jobsFindUniqueOrThrowArgs} args - Arguments to find a Marketplace_jobs
     * @example
     * // Get one Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends marketplace_jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, marketplace_jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marketplace_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketplace_jobsFindFirstArgs} args - Arguments to find a Marketplace_jobs
     * @example
     * // Get one Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends marketplace_jobsFindFirstArgs>(args?: SelectSubset<T, marketplace_jobsFindFirstArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marketplace_jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketplace_jobsFindFirstOrThrowArgs} args - Arguments to find a Marketplace_jobs
     * @example
     * // Get one Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends marketplace_jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, marketplace_jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marketplace_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketplace_jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.findMany()
     * 
     * // Get first 10 Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplace_jobsWithIdOnly = await prisma.marketplace_jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends marketplace_jobsFindManyArgs>(args?: SelectSubset<T, marketplace_jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Marketplace_jobs.
     * @param {marketplace_jobsCreateArgs} args - Arguments to create a Marketplace_jobs.
     * @example
     * // Create one Marketplace_jobs
     * const Marketplace_jobs = await prisma.marketplace_jobs.create({
     *   data: {
     *     // ... data to create a Marketplace_jobs
     *   }
     * })
     * 
     */
    create<T extends marketplace_jobsCreateArgs>(args: SelectSubset<T, marketplace_jobsCreateArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Marketplace_jobs.
     * @param {marketplace_jobsCreateManyArgs} args - Arguments to create many Marketplace_jobs.
     * @example
     * // Create many Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends marketplace_jobsCreateManyArgs>(args?: SelectSubset<T, marketplace_jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Marketplace_jobs and returns the data saved in the database.
     * @param {marketplace_jobsCreateManyAndReturnArgs} args - Arguments to create many Marketplace_jobs.
     * @example
     * // Create many Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Marketplace_jobs and only return the `id`
     * const marketplace_jobsWithIdOnly = await prisma.marketplace_jobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends marketplace_jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, marketplace_jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Marketplace_jobs.
     * @param {marketplace_jobsDeleteArgs} args - Arguments to delete one Marketplace_jobs.
     * @example
     * // Delete one Marketplace_jobs
     * const Marketplace_jobs = await prisma.marketplace_jobs.delete({
     *   where: {
     *     // ... filter to delete one Marketplace_jobs
     *   }
     * })
     * 
     */
    delete<T extends marketplace_jobsDeleteArgs>(args: SelectSubset<T, marketplace_jobsDeleteArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Marketplace_jobs.
     * @param {marketplace_jobsUpdateArgs} args - Arguments to update one Marketplace_jobs.
     * @example
     * // Update one Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends marketplace_jobsUpdateArgs>(args: SelectSubset<T, marketplace_jobsUpdateArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Marketplace_jobs.
     * @param {marketplace_jobsDeleteManyArgs} args - Arguments to filter Marketplace_jobs to delete.
     * @example
     * // Delete a few Marketplace_jobs
     * const { count } = await prisma.marketplace_jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends marketplace_jobsDeleteManyArgs>(args?: SelectSubset<T, marketplace_jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marketplace_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketplace_jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends marketplace_jobsUpdateManyArgs>(args: SelectSubset<T, marketplace_jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marketplace_jobs and returns the data updated in the database.
     * @param {marketplace_jobsUpdateManyAndReturnArgs} args - Arguments to update many Marketplace_jobs.
     * @example
     * // Update many Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Marketplace_jobs and only return the `id`
     * const marketplace_jobsWithIdOnly = await prisma.marketplace_jobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends marketplace_jobsUpdateManyAndReturnArgs>(args: SelectSubset<T, marketplace_jobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Marketplace_jobs.
     * @param {marketplace_jobsUpsertArgs} args - Arguments to update or create a Marketplace_jobs.
     * @example
     * // Update or create a Marketplace_jobs
     * const marketplace_jobs = await prisma.marketplace_jobs.upsert({
     *   create: {
     *     // ... data to create a Marketplace_jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marketplace_jobs we want to update
     *   }
     * })
     */
    upsert<T extends marketplace_jobsUpsertArgs>(args: SelectSubset<T, marketplace_jobsUpsertArgs<ExtArgs>>): Prisma__marketplace_jobsClient<$Result.GetResult<Prisma.$marketplace_jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Marketplace_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketplace_jobsCountArgs} args - Arguments to filter Marketplace_jobs to count.
     * @example
     * // Count the number of Marketplace_jobs
     * const count = await prisma.marketplace_jobs.count({
     *   where: {
     *     // ... the filter for the Marketplace_jobs we want to count
     *   }
     * })
    **/
    count<T extends marketplace_jobsCountArgs>(
      args?: Subset<T, marketplace_jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Marketplace_jobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marketplace_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Marketplace_jobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Marketplace_jobsAggregateArgs>(args: Subset<T, Marketplace_jobsAggregateArgs>): Prisma.PrismaPromise<GetMarketplace_jobsAggregateType<T>>

    /**
     * Group by Marketplace_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketplace_jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends marketplace_jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: marketplace_jobsGroupByArgs['orderBy'] }
        : { orderBy?: marketplace_jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, marketplace_jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplace_jobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the marketplace_jobs model
   */
  readonly fields: marketplace_jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for marketplace_jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__marketplace_jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job_applications<T extends marketplace_jobs$job_applicationsArgs<ExtArgs> = {}>(args?: Subset<T, marketplace_jobs$job_applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    caregivers<T extends marketplace_jobs$caregiversArgs<ExtArgs> = {}>(args?: Subset<T, marketplace_jobs$caregiversArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the marketplace_jobs model
   */
  interface marketplace_jobsFieldRefs {
    readonly id: FieldRef<"marketplace_jobs", 'String'>
    readonly company_id: FieldRef<"marketplace_jobs", 'String'>
    readonly title: FieldRef<"marketplace_jobs", 'String'>
    readonly description: FieldRef<"marketplace_jobs", 'String'>
    readonly location: FieldRef<"marketplace_jobs", 'String'>
    readonly required_skills: FieldRef<"marketplace_jobs", 'Json'>
    readonly start_date: FieldRef<"marketplace_jobs", 'DateTime'>
    readonly duration_days: FieldRef<"marketplace_jobs", 'Int'>
    readonly hours_per_day: FieldRef<"marketplace_jobs", 'Int'>
    readonly offered_rate: FieldRef<"marketplace_jobs", 'Decimal'>
    readonly status: FieldRef<"marketplace_jobs", 'String'>
    readonly applications_count: FieldRef<"marketplace_jobs", 'Int'>
    readonly filled_by: FieldRef<"marketplace_jobs", 'String'>
    readonly filled_at: FieldRef<"marketplace_jobs", 'DateTime'>
    readonly created_at: FieldRef<"marketplace_jobs", 'DateTime'>
    readonly updated_at: FieldRef<"marketplace_jobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * marketplace_jobs findUnique
   */
  export type marketplace_jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * Filter, which marketplace_jobs to fetch.
     */
    where: marketplace_jobsWhereUniqueInput
  }

  /**
   * marketplace_jobs findUniqueOrThrow
   */
  export type marketplace_jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * Filter, which marketplace_jobs to fetch.
     */
    where: marketplace_jobsWhereUniqueInput
  }

  /**
   * marketplace_jobs findFirst
   */
  export type marketplace_jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * Filter, which marketplace_jobs to fetch.
     */
    where?: marketplace_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketplace_jobs to fetch.
     */
    orderBy?: marketplace_jobsOrderByWithRelationInput | marketplace_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marketplace_jobs.
     */
    cursor?: marketplace_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketplace_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketplace_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marketplace_jobs.
     */
    distinct?: Marketplace_jobsScalarFieldEnum | Marketplace_jobsScalarFieldEnum[]
  }

  /**
   * marketplace_jobs findFirstOrThrow
   */
  export type marketplace_jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * Filter, which marketplace_jobs to fetch.
     */
    where?: marketplace_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketplace_jobs to fetch.
     */
    orderBy?: marketplace_jobsOrderByWithRelationInput | marketplace_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marketplace_jobs.
     */
    cursor?: marketplace_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketplace_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketplace_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marketplace_jobs.
     */
    distinct?: Marketplace_jobsScalarFieldEnum | Marketplace_jobsScalarFieldEnum[]
  }

  /**
   * marketplace_jobs findMany
   */
  export type marketplace_jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * Filter, which marketplace_jobs to fetch.
     */
    where?: marketplace_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketplace_jobs to fetch.
     */
    orderBy?: marketplace_jobsOrderByWithRelationInput | marketplace_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing marketplace_jobs.
     */
    cursor?: marketplace_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketplace_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketplace_jobs.
     */
    skip?: number
    distinct?: Marketplace_jobsScalarFieldEnum | Marketplace_jobsScalarFieldEnum[]
  }

  /**
   * marketplace_jobs create
   */
  export type marketplace_jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * The data needed to create a marketplace_jobs.
     */
    data: XOR<marketplace_jobsCreateInput, marketplace_jobsUncheckedCreateInput>
  }

  /**
   * marketplace_jobs createMany
   */
  export type marketplace_jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many marketplace_jobs.
     */
    data: marketplace_jobsCreateManyInput | marketplace_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marketplace_jobs createManyAndReturn
   */
  export type marketplace_jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * The data used to create many marketplace_jobs.
     */
    data: marketplace_jobsCreateManyInput | marketplace_jobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * marketplace_jobs update
   */
  export type marketplace_jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * The data needed to update a marketplace_jobs.
     */
    data: XOR<marketplace_jobsUpdateInput, marketplace_jobsUncheckedUpdateInput>
    /**
     * Choose, which marketplace_jobs to update.
     */
    where: marketplace_jobsWhereUniqueInput
  }

  /**
   * marketplace_jobs updateMany
   */
  export type marketplace_jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update marketplace_jobs.
     */
    data: XOR<marketplace_jobsUpdateManyMutationInput, marketplace_jobsUncheckedUpdateManyInput>
    /**
     * Filter which marketplace_jobs to update
     */
    where?: marketplace_jobsWhereInput
    /**
     * Limit how many marketplace_jobs to update.
     */
    limit?: number
  }

  /**
   * marketplace_jobs updateManyAndReturn
   */
  export type marketplace_jobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * The data used to update marketplace_jobs.
     */
    data: XOR<marketplace_jobsUpdateManyMutationInput, marketplace_jobsUncheckedUpdateManyInput>
    /**
     * Filter which marketplace_jobs to update
     */
    where?: marketplace_jobsWhereInput
    /**
     * Limit how many marketplace_jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * marketplace_jobs upsert
   */
  export type marketplace_jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * The filter to search for the marketplace_jobs to update in case it exists.
     */
    where: marketplace_jobsWhereUniqueInput
    /**
     * In case the marketplace_jobs found by the `where` argument doesn't exist, create a new marketplace_jobs with this data.
     */
    create: XOR<marketplace_jobsCreateInput, marketplace_jobsUncheckedCreateInput>
    /**
     * In case the marketplace_jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marketplace_jobsUpdateInput, marketplace_jobsUncheckedUpdateInput>
  }

  /**
   * marketplace_jobs delete
   */
  export type marketplace_jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
    /**
     * Filter which marketplace_jobs to delete.
     */
    where: marketplace_jobsWhereUniqueInput
  }

  /**
   * marketplace_jobs deleteMany
   */
  export type marketplace_jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marketplace_jobs to delete
     */
    where?: marketplace_jobsWhereInput
    /**
     * Limit how many marketplace_jobs to delete.
     */
    limit?: number
  }

  /**
   * marketplace_jobs.job_applications
   */
  export type marketplace_jobs$job_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    where?: job_applicationsWhereInput
    orderBy?: job_applicationsOrderByWithRelationInput | job_applicationsOrderByWithRelationInput[]
    cursor?: job_applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_applicationsScalarFieldEnum | Job_applicationsScalarFieldEnum[]
  }

  /**
   * marketplace_jobs.caregivers
   */
  export type marketplace_jobs$caregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    where?: caregiversWhereInput
  }

  /**
   * marketplace_jobs without action
   */
  export type marketplace_jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marketplace_jobs
     */
    select?: marketplace_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marketplace_jobs
     */
    omit?: marketplace_jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marketplace_jobsInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    channel: string | null
    title: string | null
    body: string | null
    status: $Enums.NotificationStatus | null
    sent_at: Date | null
    delivered_at: Date | null
    read_at: Date | null
    error_message: string | null
    createdAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    channel: string | null
    title: string | null
    body: string | null
    status: $Enums.NotificationStatus | null
    sent_at: Date | null
    delivered_at: Date | null
    read_at: Date | null
    error_message: string | null
    createdAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    channel: number
    title: number
    body: number
    data: number
    status: number
    sent_at: number
    delivered_at: number
    read_at: number
    error_message: number
    createdAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    channel?: true
    title?: true
    body?: true
    status?: true
    sent_at?: true
    delivered_at?: true
    read_at?: true
    error_message?: true
    createdAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    channel?: true
    title?: true
    body?: true
    status?: true
    sent_at?: true
    delivered_at?: true
    read_at?: true
    error_message?: true
    createdAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    channel?: true
    title?: true
    body?: true
    data?: true
    status?: true
    sent_at?: true
    delivered_at?: true
    read_at?: true
    error_message?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    channel: string
    title: string | null
    body: string
    data: JsonValue | null
    status: $Enums.NotificationStatus
    sent_at: Date | null
    delivered_at: Date | null
    read_at: Date | null
    error_message: string | null
    createdAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    status?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    error_message?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    status?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    error_message?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    status?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    error_message?: boolean
    createdAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    channel?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    status?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    error_message?: boolean
    createdAt?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "channel" | "title" | "body" | "data" | "status" | "sent_at" | "delivered_at" | "read_at" | "error_message" | "createdAt", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      channel: string
      title: string | null
      body: string
      data: Prisma.JsonValue | null
      status: $Enums.NotificationStatus
      sent_at: Date | null
      delivered_at: Date | null
      read_at: Date | null
      error_message: string | null
      createdAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly userId: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'NotificationType'>
    readonly channel: FieldRef<"notifications", 'String'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly body: FieldRef<"notifications", 'String'>
    readonly data: FieldRef<"notifications", 'Json'>
    readonly status: FieldRef<"notifications", 'NotificationStatus'>
    readonly sent_at: FieldRef<"notifications", 'DateTime'>
    readonly delivered_at: FieldRef<"notifications", 'DateTime'>
    readonly read_at: FieldRef<"notifications", 'DateTime'>
    readonly error_message: FieldRef<"notifications", 'String'>
    readonly createdAt: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model packages
   */

  export type AggregatePackages = {
    _count: PackagesCountAggregateOutputType | null
    _avg: PackagesAvgAggregateOutputType | null
    _sum: PackagesSumAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  export type PackagesAvgAggregateOutputType = {
    price: Decimal | null
    duration_days: number | null
    hours_per_day: number | null
    caregiver_count: number | null
    min_advance_days: number | null
  }

  export type PackagesSumAggregateOutputType = {
    price: Decimal | null
    duration_days: number | null
    hours_per_day: number | null
    caregiver_count: number | null
    min_advance_days: number | null
  }

  export type PackagesMinAggregateOutputType = {
    id: string | null
    company_id: string | null
    name: string | null
    description: string | null
    category: $Enums.PackageCategory | null
    price: Decimal | null
    duration_days: number | null
    hours_per_day: number | null
    caregiver_count: number | null
    is_active: boolean | null
    min_advance_days: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PackagesMaxAggregateOutputType = {
    id: string | null
    company_id: string | null
    name: string | null
    description: string | null
    category: $Enums.PackageCategory | null
    price: Decimal | null
    duration_days: number | null
    hours_per_day: number | null
    caregiver_count: number | null
    is_active: boolean | null
    min_advance_days: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PackagesCountAggregateOutputType = {
    id: number
    company_id: number
    name: number
    description: number
    category: number
    price: number
    duration_days: number
    hours_per_day: number
    inclusions: number
    exclusions: number
    caregiver_count: number
    is_active: number
    min_advance_days: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PackagesAvgAggregateInputType = {
    price?: true
    duration_days?: true
    hours_per_day?: true
    caregiver_count?: true
    min_advance_days?: true
  }

  export type PackagesSumAggregateInputType = {
    price?: true
    duration_days?: true
    hours_per_day?: true
    caregiver_count?: true
    min_advance_days?: true
  }

  export type PackagesMinAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    description?: true
    category?: true
    price?: true
    duration_days?: true
    hours_per_day?: true
    caregiver_count?: true
    is_active?: true
    min_advance_days?: true
    created_at?: true
    updated_at?: true
  }

  export type PackagesMaxAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    description?: true
    category?: true
    price?: true
    duration_days?: true
    hours_per_day?: true
    caregiver_count?: true
    is_active?: true
    min_advance_days?: true
    created_at?: true
    updated_at?: true
  }

  export type PackagesCountAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    description?: true
    category?: true
    price?: true
    duration_days?: true
    hours_per_day?: true
    inclusions?: true
    exclusions?: true
    caregiver_count?: true
    is_active?: true
    min_advance_days?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PackagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which packages to aggregate.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned packages
    **/
    _count?: true | PackagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackagesMaxAggregateInputType
  }

  export type GetPackagesAggregateType<T extends PackagesAggregateArgs> = {
        [P in keyof T & keyof AggregatePackages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackages[P]>
      : GetScalarType<T[P], AggregatePackages[P]>
  }




  export type packagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: packagesWhereInput
    orderBy?: packagesOrderByWithAggregationInput | packagesOrderByWithAggregationInput[]
    by: PackagesScalarFieldEnum[] | PackagesScalarFieldEnum
    having?: packagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackagesCountAggregateInputType | true
    _avg?: PackagesAvgAggregateInputType
    _sum?: PackagesSumAggregateInputType
    _min?: PackagesMinAggregateInputType
    _max?: PackagesMaxAggregateInputType
  }

  export type PackagesGroupByOutputType = {
    id: string
    company_id: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal
    duration_days: number
    hours_per_day: number
    inclusions: JsonValue
    exclusions: JsonValue | null
    caregiver_count: number
    is_active: boolean
    min_advance_days: number
    created_at: Date
    updated_at: Date
    _count: PackagesCountAggregateOutputType | null
    _avg: PackagesAvgAggregateOutputType | null
    _sum: PackagesSumAggregateOutputType | null
    _min: PackagesMinAggregateOutputType | null
    _max: PackagesMaxAggregateOutputType | null
  }

  type GetPackagesGroupByPayload<T extends packagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackagesGroupByOutputType[P]>
            : GetScalarType<T[P], PackagesGroupByOutputType[P]>
        }
      >
    >


  export type packagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    inclusions?: boolean
    exclusions?: boolean
    caregiver_count?: boolean
    is_active?: boolean
    min_advance_days?: boolean
    created_at?: boolean
    updated_at?: boolean
    jobs?: boolean | packages$jobsArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    _count?: boolean | PackagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packages"]>

  export type packagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    inclusions?: boolean
    exclusions?: boolean
    caregiver_count?: boolean
    is_active?: boolean
    min_advance_days?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packages"]>

  export type packagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    inclusions?: boolean
    exclusions?: boolean
    caregiver_count?: boolean
    is_active?: boolean
    min_advance_days?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packages"]>

  export type packagesSelectScalar = {
    id?: boolean
    company_id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    duration_days?: boolean
    hours_per_day?: boolean
    inclusions?: boolean
    exclusions?: boolean
    caregiver_count?: boolean
    is_active?: boolean
    min_advance_days?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type packagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "name" | "description" | "category" | "price" | "duration_days" | "hours_per_day" | "inclusions" | "exclusions" | "caregiver_count" | "is_active" | "min_advance_days" | "created_at" | "updated_at", ExtArgs["result"]["packages"]>
  export type packagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | packages$jobsArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    _count?: boolean | PackagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type packagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type packagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $packagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "packages"
    objects: {
      jobs: Prisma.$jobsPayload<ExtArgs>[]
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company_id: string
      name: string
      description: string
      category: $Enums.PackageCategory
      price: Prisma.Decimal
      duration_days: number
      hours_per_day: number
      inclusions: Prisma.JsonValue
      exclusions: Prisma.JsonValue | null
      caregiver_count: number
      is_active: boolean
      min_advance_days: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["packages"]>
    composites: {}
  }

  type packagesGetPayload<S extends boolean | null | undefined | packagesDefaultArgs> = $Result.GetResult<Prisma.$packagesPayload, S>

  type packagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<packagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackagesCountAggregateInputType | true
    }

  export interface packagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['packages'], meta: { name: 'packages' } }
    /**
     * Find zero or one Packages that matches the filter.
     * @param {packagesFindUniqueArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends packagesFindUniqueArgs>(args: SelectSubset<T, packagesFindUniqueArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Packages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {packagesFindUniqueOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends packagesFindUniqueOrThrowArgs>(args: SelectSubset<T, packagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends packagesFindFirstArgs>(args?: SelectSubset<T, packagesFindFirstArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Packages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindFirstOrThrowArgs} args - Arguments to find a Packages
     * @example
     * // Get one Packages
     * const packages = await prisma.packages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends packagesFindFirstOrThrowArgs>(args?: SelectSubset<T, packagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.packages.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.packages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packagesWithIdOnly = await prisma.packages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends packagesFindManyArgs>(args?: SelectSubset<T, packagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Packages.
     * @param {packagesCreateArgs} args - Arguments to create a Packages.
     * @example
     * // Create one Packages
     * const Packages = await prisma.packages.create({
     *   data: {
     *     // ... data to create a Packages
     *   }
     * })
     * 
     */
    create<T extends packagesCreateArgs>(args: SelectSubset<T, packagesCreateArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {packagesCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const packages = await prisma.packages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends packagesCreateManyArgs>(args?: SelectSubset<T, packagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Packages and returns the data saved in the database.
     * @param {packagesCreateManyAndReturnArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const packages = await prisma.packages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Packages and only return the `id`
     * const packagesWithIdOnly = await prisma.packages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends packagesCreateManyAndReturnArgs>(args?: SelectSubset<T, packagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Packages.
     * @param {packagesDeleteArgs} args - Arguments to delete one Packages.
     * @example
     * // Delete one Packages
     * const Packages = await prisma.packages.delete({
     *   where: {
     *     // ... filter to delete one Packages
     *   }
     * })
     * 
     */
    delete<T extends packagesDeleteArgs>(args: SelectSubset<T, packagesDeleteArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Packages.
     * @param {packagesUpdateArgs} args - Arguments to update one Packages.
     * @example
     * // Update one Packages
     * const packages = await prisma.packages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends packagesUpdateArgs>(args: SelectSubset<T, packagesUpdateArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {packagesDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.packages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends packagesDeleteManyArgs>(args?: SelectSubset<T, packagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const packages = await prisma.packages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends packagesUpdateManyArgs>(args: SelectSubset<T, packagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages and returns the data updated in the database.
     * @param {packagesUpdateManyAndReturnArgs} args - Arguments to update many Packages.
     * @example
     * // Update many Packages
     * const packages = await prisma.packages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Packages and only return the `id`
     * const packagesWithIdOnly = await prisma.packages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends packagesUpdateManyAndReturnArgs>(args: SelectSubset<T, packagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Packages.
     * @param {packagesUpsertArgs} args - Arguments to update or create a Packages.
     * @example
     * // Update or create a Packages
     * const packages = await prisma.packages.upsert({
     *   create: {
     *     // ... data to create a Packages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Packages we want to update
     *   }
     * })
     */
    upsert<T extends packagesUpsertArgs>(args: SelectSubset<T, packagesUpsertArgs<ExtArgs>>): Prisma__packagesClient<$Result.GetResult<Prisma.$packagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.packages.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends packagesCountArgs>(
      args?: Subset<T, packagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackagesAggregateArgs>(args: Subset<T, PackagesAggregateArgs>): Prisma.PrismaPromise<GetPackagesAggregateType<T>>

    /**
     * Group by Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {packagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends packagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: packagesGroupByArgs['orderBy'] }
        : { orderBy?: packagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, packagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the packages model
   */
  readonly fields: packagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for packages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__packagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends packages$jobsArgs<ExtArgs> = {}>(args?: Subset<T, packages$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the packages model
   */
  interface packagesFieldRefs {
    readonly id: FieldRef<"packages", 'String'>
    readonly company_id: FieldRef<"packages", 'String'>
    readonly name: FieldRef<"packages", 'String'>
    readonly description: FieldRef<"packages", 'String'>
    readonly category: FieldRef<"packages", 'PackageCategory'>
    readonly price: FieldRef<"packages", 'Decimal'>
    readonly duration_days: FieldRef<"packages", 'Int'>
    readonly hours_per_day: FieldRef<"packages", 'Int'>
    readonly inclusions: FieldRef<"packages", 'Json'>
    readonly exclusions: FieldRef<"packages", 'Json'>
    readonly caregiver_count: FieldRef<"packages", 'Int'>
    readonly is_active: FieldRef<"packages", 'Boolean'>
    readonly min_advance_days: FieldRef<"packages", 'Int'>
    readonly created_at: FieldRef<"packages", 'DateTime'>
    readonly updated_at: FieldRef<"packages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * packages findUnique
   */
  export type packagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages findUniqueOrThrow
   */
  export type packagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages findFirst
   */
  export type packagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packages.
     */
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages findFirstOrThrow
   */
  export type packagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of packages.
     */
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages findMany
   */
  export type packagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter, which packages to fetch.
     */
    where?: packagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of packages to fetch.
     */
    orderBy?: packagesOrderByWithRelationInput | packagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing packages.
     */
    cursor?: packagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` packages.
     */
    skip?: number
    distinct?: PackagesScalarFieldEnum | PackagesScalarFieldEnum[]
  }

  /**
   * packages create
   */
  export type packagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * The data needed to create a packages.
     */
    data: XOR<packagesCreateInput, packagesUncheckedCreateInput>
  }

  /**
   * packages createMany
   */
  export type packagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many packages.
     */
    data: packagesCreateManyInput | packagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * packages createManyAndReturn
   */
  export type packagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * The data used to create many packages.
     */
    data: packagesCreateManyInput | packagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * packages update
   */
  export type packagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * The data needed to update a packages.
     */
    data: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
    /**
     * Choose, which packages to update.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages updateMany
   */
  export type packagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update packages.
     */
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyInput>
    /**
     * Filter which packages to update
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to update.
     */
    limit?: number
  }

  /**
   * packages updateManyAndReturn
   */
  export type packagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * The data used to update packages.
     */
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyInput>
    /**
     * Filter which packages to update
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * packages upsert
   */
  export type packagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * The filter to search for the packages to update in case it exists.
     */
    where: packagesWhereUniqueInput
    /**
     * In case the packages found by the `where` argument doesn't exist, create a new packages with this data.
     */
    create: XOR<packagesCreateInput, packagesUncheckedCreateInput>
    /**
     * In case the packages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<packagesUpdateInput, packagesUncheckedUpdateInput>
  }

  /**
   * packages delete
   */
  export type packagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
    /**
     * Filter which packages to delete.
     */
    where: packagesWhereUniqueInput
  }

  /**
   * packages deleteMany
   */
  export type packagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which packages to delete
     */
    where?: packagesWhereInput
    /**
     * Limit how many packages to delete.
     */
    limit?: number
  }

  /**
   * packages.jobs
   */
  export type packages$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    cursor?: jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * packages without action
   */
  export type packagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the packages
     */
    select?: packagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the packages
     */
    omit?: packagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: packagesInclude<ExtArgs> | null
  }


  /**
   * Model patients
   */

  export type AggregatePatients = {
    _count: PatientsCountAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  export type PatientsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    guardian_id: string | null
    name: string | null
    date_of_birth: Date | null
    gender: $Enums.Gender | null
    blood_group: string | null
    address: string | null
    emergency_contact_name: string | null
    emergency_contact_phone: string | null
    allergies: string | null
    mobility_level: $Enums.MobilityLevel | null
    cognitive_status: $Enums.CognitiveStatus | null
    photoUrl: string | null
    consent_data_sharing: boolean | null
    consent_marketing: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    guardian_id: string | null
    name: string | null
    date_of_birth: Date | null
    gender: $Enums.Gender | null
    blood_group: string | null
    address: string | null
    emergency_contact_name: string | null
    emergency_contact_phone: string | null
    allergies: string | null
    mobility_level: $Enums.MobilityLevel | null
    cognitive_status: $Enums.CognitiveStatus | null
    photoUrl: string | null
    consent_data_sharing: boolean | null
    consent_marketing: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientsCountAggregateOutputType = {
    id: number
    user_id: number
    guardian_id: number
    name: number
    date_of_birth: number
    gender: number
    blood_group: number
    address: number
    emergency_contact_name: number
    emergency_contact_phone: number
    primaryConditions: number
    allergies: number
    mobility_level: number
    cognitive_status: number
    photoUrl: number
    consent_data_sharing: number
    consent_marketing: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientsMinAggregateInputType = {
    id?: true
    user_id?: true
    guardian_id?: true
    name?: true
    date_of_birth?: true
    gender?: true
    blood_group?: true
    address?: true
    emergency_contact_name?: true
    emergency_contact_phone?: true
    allergies?: true
    mobility_level?: true
    cognitive_status?: true
    photoUrl?: true
    consent_data_sharing?: true
    consent_marketing?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientsMaxAggregateInputType = {
    id?: true
    user_id?: true
    guardian_id?: true
    name?: true
    date_of_birth?: true
    gender?: true
    blood_group?: true
    address?: true
    emergency_contact_name?: true
    emergency_contact_phone?: true
    allergies?: true
    mobility_level?: true
    cognitive_status?: true
    photoUrl?: true
    consent_data_sharing?: true
    consent_marketing?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientsCountAggregateInputType = {
    id?: true
    user_id?: true
    guardian_id?: true
    name?: true
    date_of_birth?: true
    gender?: true
    blood_group?: true
    address?: true
    emergency_contact_name?: true
    emergency_contact_phone?: true
    primaryConditions?: true
    allergies?: true
    mobility_level?: true
    cognitive_status?: true
    photoUrl?: true
    consent_data_sharing?: true
    consent_marketing?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to aggregate.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patients
    **/
    _count?: true | PatientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientsMaxAggregateInputType
  }

  export type GetPatientsAggregateType<T extends PatientsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatients[P]>
      : GetScalarType<T[P], AggregatePatients[P]>
  }




  export type patientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientsWhereInput
    orderBy?: patientsOrderByWithAggregationInput | patientsOrderByWithAggregationInput[]
    by: PatientsScalarFieldEnum[] | PatientsScalarFieldEnum
    having?: patientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientsCountAggregateInputType | true
    _min?: PatientsMinAggregateInputType
    _max?: PatientsMaxAggregateInputType
  }

  export type PatientsGroupByOutputType = {
    id: string
    user_id: string | null
    guardian_id: string
    name: string
    date_of_birth: Date
    gender: $Enums.Gender
    blood_group: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions: JsonValue | null
    allergies: string | null
    mobility_level: $Enums.MobilityLevel
    cognitive_status: $Enums.CognitiveStatus
    photoUrl: string | null
    consent_data_sharing: boolean
    consent_marketing: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PatientsCountAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  type GetPatientsGroupByPayload<T extends patientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientsGroupByOutputType[P]>
            : GetScalarType<T[P], PatientsGroupByOutputType[P]>
        }
      >
    >


  export type patientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    guardian_id?: boolean
    name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    blood_group?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_phone?: boolean
    primaryConditions?: boolean
    allergies?: boolean
    mobility_level?: boolean
    cognitive_status?: boolean
    photoUrl?: boolean
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    care_logs?: boolean | patients$care_logsArgs<ExtArgs>
    health_records?: boolean | patients$health_recordsArgs<ExtArgs>
    jobs?: boolean | patients$jobsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    guardian_id?: boolean
    name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    blood_group?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_phone?: boolean
    primaryConditions?: boolean
    allergies?: boolean
    mobility_level?: boolean
    cognitive_status?: boolean
    photoUrl?: boolean
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    guardian_id?: boolean
    name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    blood_group?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_phone?: boolean
    primaryConditions?: boolean
    allergies?: boolean
    mobility_level?: boolean
    cognitive_status?: boolean
    photoUrl?: boolean
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectScalar = {
    id?: boolean
    user_id?: boolean
    guardian_id?: boolean
    name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    blood_group?: boolean
    address?: boolean
    emergency_contact_name?: boolean
    emergency_contact_phone?: boolean
    primaryConditions?: boolean
    allergies?: boolean
    mobility_level?: boolean
    cognitive_status?: boolean
    photoUrl?: boolean
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type patientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "guardian_id" | "name" | "date_of_birth" | "gender" | "blood_group" | "address" | "emergency_contact_name" | "emergency_contact_phone" | "primaryConditions" | "allergies" | "mobility_level" | "cognitive_status" | "photoUrl" | "consent_data_sharing" | "consent_marketing" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["patients"]>
  export type patientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    care_logs?: boolean | patients$care_logsArgs<ExtArgs>
    health_records?: boolean | patients$health_recordsArgs<ExtArgs>
    jobs?: boolean | patients$jobsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type patientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type patientsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $patientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patients"
    objects: {
      care_logs: Prisma.$care_logsPayload<ExtArgs>[]
      health_records: Prisma.$health_recordsPayload<ExtArgs>[]
      jobs: Prisma.$jobsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      guardian_id: string
      name: string
      date_of_birth: Date
      gender: $Enums.Gender
      blood_group: string | null
      address: string
      emergency_contact_name: string
      emergency_contact_phone: string
      primaryConditions: Prisma.JsonValue | null
      allergies: string | null
      mobility_level: $Enums.MobilityLevel
      cognitive_status: $Enums.CognitiveStatus
      photoUrl: string | null
      consent_data_sharing: boolean
      consent_marketing: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patients"]>
    composites: {}
  }

  type patientsGetPayload<S extends boolean | null | undefined | patientsDefaultArgs> = $Result.GetResult<Prisma.$patientsPayload, S>

  type patientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientsCountAggregateInputType | true
    }

  export interface patientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patients'], meta: { name: 'patients' } }
    /**
     * Find zero or one Patients that matches the filter.
     * @param {patientsFindUniqueArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patientsFindUniqueArgs>(args: SelectSubset<T, patientsFindUniqueArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patientsFindUniqueOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patientsFindUniqueOrThrowArgs>(args: SelectSubset<T, patientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patientsFindFirstArgs>(args?: SelectSubset<T, patientsFindFirstArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patientsFindFirstOrThrowArgs>(args?: SelectSubset<T, patientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patients.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientsWithIdOnly = await prisma.patients.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends patientsFindManyArgs>(args?: SelectSubset<T, patientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patients.
     * @param {patientsCreateArgs} args - Arguments to create a Patients.
     * @example
     * // Create one Patients
     * const Patients = await prisma.patients.create({
     *   data: {
     *     // ... data to create a Patients
     *   }
     * })
     * 
     */
    create<T extends patientsCreateArgs>(args: SelectSubset<T, patientsCreateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {patientsCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patientsCreateManyArgs>(args?: SelectSubset<T, patientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {patientsCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientsWithIdOnly = await prisma.patients.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patientsCreateManyAndReturnArgs>(args?: SelectSubset<T, patientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patients.
     * @param {patientsDeleteArgs} args - Arguments to delete one Patients.
     * @example
     * // Delete one Patients
     * const Patients = await prisma.patients.delete({
     *   where: {
     *     // ... filter to delete one Patients
     *   }
     * })
     * 
     */
    delete<T extends patientsDeleteArgs>(args: SelectSubset<T, patientsDeleteArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patients.
     * @param {patientsUpdateArgs} args - Arguments to update one Patients.
     * @example
     * // Update one Patients
     * const patients = await prisma.patients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patientsUpdateArgs>(args: SelectSubset<T, patientsUpdateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {patientsDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patientsDeleteManyArgs>(args?: SelectSubset<T, patientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patientsUpdateManyArgs>(args: SelectSubset<T, patientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {patientsUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientsWithIdOnly = await prisma.patients.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patientsUpdateManyAndReturnArgs>(args: SelectSubset<T, patientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patients.
     * @param {patientsUpsertArgs} args - Arguments to update or create a Patients.
     * @example
     * // Update or create a Patients
     * const patients = await prisma.patients.upsert({
     *   create: {
     *     // ... data to create a Patients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patients we want to update
     *   }
     * })
     */
    upsert<T extends patientsUpsertArgs>(args: SelectSubset<T, patientsUpsertArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patients.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends patientsCountArgs>(
      args?: Subset<T, patientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientsAggregateArgs>(args: Subset<T, PatientsAggregateArgs>): Prisma.PrismaPromise<GetPatientsAggregateType<T>>

    /**
     * Group by Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patientsGroupByArgs['orderBy'] }
        : { orderBy?: patientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patients model
   */
  readonly fields: patientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    care_logs<T extends patients$care_logsArgs<ExtArgs> = {}>(args?: Subset<T, patients$care_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$care_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    health_records<T extends patients$health_recordsArgs<ExtArgs> = {}>(args?: Subset<T, patients$health_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$health_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends patients$jobsArgs<ExtArgs> = {}>(args?: Subset<T, patients$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patients model
   */
  interface patientsFieldRefs {
    readonly id: FieldRef<"patients", 'String'>
    readonly user_id: FieldRef<"patients", 'String'>
    readonly guardian_id: FieldRef<"patients", 'String'>
    readonly name: FieldRef<"patients", 'String'>
    readonly date_of_birth: FieldRef<"patients", 'DateTime'>
    readonly gender: FieldRef<"patients", 'Gender'>
    readonly blood_group: FieldRef<"patients", 'String'>
    readonly address: FieldRef<"patients", 'String'>
    readonly emergency_contact_name: FieldRef<"patients", 'String'>
    readonly emergency_contact_phone: FieldRef<"patients", 'String'>
    readonly primaryConditions: FieldRef<"patients", 'Json'>
    readonly allergies: FieldRef<"patients", 'String'>
    readonly mobility_level: FieldRef<"patients", 'MobilityLevel'>
    readonly cognitive_status: FieldRef<"patients", 'CognitiveStatus'>
    readonly photoUrl: FieldRef<"patients", 'String'>
    readonly consent_data_sharing: FieldRef<"patients", 'Boolean'>
    readonly consent_marketing: FieldRef<"patients", 'Boolean'>
    readonly deletedAt: FieldRef<"patients", 'DateTime'>
    readonly createdAt: FieldRef<"patients", 'DateTime'>
    readonly updatedAt: FieldRef<"patients", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patients findUnique
   */
  export type patientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findUniqueOrThrow
   */
  export type patientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findFirst
   */
  export type patientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findFirstOrThrow
   */
  export type patientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findMany
   */
  export type patientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients create
   */
  export type patientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The data needed to create a patients.
     */
    data: XOR<patientsCreateInput, patientsUncheckedCreateInput>
  }

  /**
   * patients createMany
   */
  export type patientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patients createManyAndReturn
   */
  export type patientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * patients update
   */
  export type patientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The data needed to update a patients.
     */
    data: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
    /**
     * Choose, which patients to update.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients updateMany
   */
  export type patientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
  }

  /**
   * patients updateManyAndReturn
   */
  export type patientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * patients upsert
   */
  export type patientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The filter to search for the patients to update in case it exists.
     */
    where: patientsWhereUniqueInput
    /**
     * In case the patients found by the `where` argument doesn't exist, create a new patients with this data.
     */
    create: XOR<patientsCreateInput, patientsUncheckedCreateInput>
    /**
     * In case the patients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
  }

  /**
   * patients delete
   */
  export type patientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter which patients to delete.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients deleteMany
   */
  export type patientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to delete
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to delete.
     */
    limit?: number
  }

  /**
   * patients.care_logs
   */
  export type patients$care_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the care_logs
     */
    select?: care_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the care_logs
     */
    omit?: care_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: care_logsInclude<ExtArgs> | null
    where?: care_logsWhereInput
    orderBy?: care_logsOrderByWithRelationInput | care_logsOrderByWithRelationInput[]
    cursor?: care_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Care_logsScalarFieldEnum | Care_logsScalarFieldEnum[]
  }

  /**
   * patients.health_records
   */
  export type patients$health_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the health_records
     */
    select?: health_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the health_records
     */
    omit?: health_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: health_recordsInclude<ExtArgs> | null
    where?: health_recordsWhereInput
    orderBy?: health_recordsOrderByWithRelationInput | health_recordsOrderByWithRelationInput[]
    cursor?: health_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Health_recordsScalarFieldEnum | Health_recordsScalarFieldEnum[]
  }

  /**
   * patients.jobs
   */
  export type patients$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    cursor?: jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * patients without action
   */
  export type patientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount: Decimal | null
    refund_amount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount: Decimal | null
    refund_amount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    job_id: string | null
    payer_id: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    transaction_id: string | null
    status: $Enums.PaymentStatus | null
    invoice_number: string | null
    invoice_url: string | null
    receipt_url: string | null
    paid_at: Date | null
    refund_amount: Decimal | null
    refund_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    job_id: string | null
    payer_id: string | null
    amount: Decimal | null
    method: $Enums.PaymentMethod | null
    transaction_id: string | null
    status: $Enums.PaymentStatus | null
    invoice_number: string | null
    invoice_url: string | null
    receipt_url: string | null
    paid_at: Date | null
    refund_amount: Decimal | null
    refund_reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    job_id: number
    payer_id: number
    amount: number
    method: number
    transaction_id: number
    status: number
    invoice_number: number
    invoice_url: number
    receipt_url: number
    paid_at: number
    refund_amount: number
    refund_reason: number
    gatewayResponse: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount?: true
    refund_amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount?: true
    refund_amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    job_id?: true
    payer_id?: true
    amount?: true
    method?: true
    transaction_id?: true
    status?: true
    invoice_number?: true
    invoice_url?: true
    receipt_url?: true
    paid_at?: true
    refund_amount?: true
    refund_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    job_id?: true
    payer_id?: true
    amount?: true
    method?: true
    transaction_id?: true
    status?: true
    invoice_number?: true
    invoice_url?: true
    receipt_url?: true
    paid_at?: true
    refund_amount?: true
    refund_reason?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    job_id?: true
    payer_id?: true
    amount?: true
    method?: true
    transaction_id?: true
    status?: true
    invoice_number?: true
    invoice_url?: true
    receipt_url?: true
    paid_at?: true
    refund_amount?: true
    refund_reason?: true
    gatewayResponse?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    job_id: string | null
    payer_id: string
    amount: Decimal
    method: $Enums.PaymentMethod
    transaction_id: string
    status: $Enums.PaymentStatus
    invoice_number: string
    invoice_url: string | null
    receipt_url: string | null
    paid_at: Date | null
    refund_amount: Decimal | null
    refund_reason: string | null
    gatewayResponse: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    payer_id?: boolean
    amount?: boolean
    method?: boolean
    transaction_id?: boolean
    status?: boolean
    invoice_number?: boolean
    invoice_url?: boolean
    receipt_url?: boolean
    paid_at?: boolean
    refund_amount?: boolean
    refund_reason?: boolean
    gatewayResponse?: boolean
    created_at?: boolean
    updated_at?: boolean
    escrows?: boolean | payments$escrowsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | payments$jobsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    payer_id?: boolean
    amount?: boolean
    method?: boolean
    transaction_id?: boolean
    status?: boolean
    invoice_number?: boolean
    invoice_url?: boolean
    receipt_url?: boolean
    paid_at?: boolean
    refund_amount?: boolean
    refund_reason?: boolean
    gatewayResponse?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | payments$jobsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_id?: boolean
    payer_id?: boolean
    amount?: boolean
    method?: boolean
    transaction_id?: boolean
    status?: boolean
    invoice_number?: boolean
    invoice_url?: boolean
    receipt_url?: boolean
    paid_at?: boolean
    refund_amount?: boolean
    refund_reason?: boolean
    gatewayResponse?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | payments$jobsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    job_id?: boolean
    payer_id?: boolean
    amount?: boolean
    method?: boolean
    transaction_id?: boolean
    status?: boolean
    invoice_number?: boolean
    invoice_url?: boolean
    receipt_url?: boolean
    paid_at?: boolean
    refund_amount?: boolean
    refund_reason?: boolean
    gatewayResponse?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_id" | "payer_id" | "amount" | "method" | "transaction_id" | "status" | "invoice_number" | "invoice_url" | "receipt_url" | "paid_at" | "refund_amount" | "refund_reason" | "gatewayResponse" | "created_at" | "updated_at", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escrows?: boolean | payments$escrowsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | payments$jobsArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | payments$jobsArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    jobs?: boolean | payments$jobsArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      escrows: Prisma.$escrowsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      jobs: Prisma.$jobsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_id: string | null
      payer_id: string
      amount: Prisma.Decimal
      method: $Enums.PaymentMethod
      transaction_id: string
      status: $Enums.PaymentStatus
      invoice_number: string
      invoice_url: string | null
      receipt_url: string | null
      paid_at: Date | null
      refund_amount: Prisma.Decimal | null
      refund_reason: string | null
      gatewayResponse: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    escrows<T extends payments$escrowsArgs<ExtArgs> = {}>(args?: Subset<T, payments$escrowsArgs<ExtArgs>>): Prisma__escrowsClient<$Result.GetResult<Prisma.$escrowsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends payments$jobsArgs<ExtArgs> = {}>(args?: Subset<T, payments$jobsArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'String'>
    readonly job_id: FieldRef<"payments", 'String'>
    readonly payer_id: FieldRef<"payments", 'String'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly method: FieldRef<"payments", 'PaymentMethod'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly status: FieldRef<"payments", 'PaymentStatus'>
    readonly invoice_number: FieldRef<"payments", 'String'>
    readonly invoice_url: FieldRef<"payments", 'String'>
    readonly receipt_url: FieldRef<"payments", 'String'>
    readonly paid_at: FieldRef<"payments", 'DateTime'>
    readonly refund_amount: FieldRef<"payments", 'Decimal'>
    readonly refund_reason: FieldRef<"payments", 'String'>
    readonly gatewayResponse: FieldRef<"payments", 'Json'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly updated_at: FieldRef<"payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.escrows
   */
  export type payments$escrowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escrows
     */
    select?: escrowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escrows
     */
    omit?: escrowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escrowsInclude<ExtArgs> | null
    where?: escrowsWhereInput
  }

  /**
   * payments.jobs
   */
  export type payments$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model scheduled_tasks
   */

  export type AggregateScheduled_tasks = {
    _count: Scheduled_tasksCountAggregateOutputType | null
    _min: Scheduled_tasksMinAggregateOutputType | null
    _max: Scheduled_tasksMaxAggregateOutputType | null
  }

  export type Scheduled_tasksMinAggregateOutputType = {
    id: string | null
    task_type: string | null
    job_id: string | null
    execute_at: Date | null
    createdAt: Date | null
    executedAt: Date | null
    status: string | null
  }

  export type Scheduled_tasksMaxAggregateOutputType = {
    id: string | null
    task_type: string | null
    job_id: string | null
    execute_at: Date | null
    createdAt: Date | null
    executedAt: Date | null
    status: string | null
  }

  export type Scheduled_tasksCountAggregateOutputType = {
    id: number
    task_type: number
    job_id: number
    execute_at: number
    payload: number
    createdAt: number
    executedAt: number
    status: number
    _all: number
  }


  export type Scheduled_tasksMinAggregateInputType = {
    id?: true
    task_type?: true
    job_id?: true
    execute_at?: true
    createdAt?: true
    executedAt?: true
    status?: true
  }

  export type Scheduled_tasksMaxAggregateInputType = {
    id?: true
    task_type?: true
    job_id?: true
    execute_at?: true
    createdAt?: true
    executedAt?: true
    status?: true
  }

  export type Scheduled_tasksCountAggregateInputType = {
    id?: true
    task_type?: true
    job_id?: true
    execute_at?: true
    payload?: true
    createdAt?: true
    executedAt?: true
    status?: true
    _all?: true
  }

  export type Scheduled_tasksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scheduled_tasks to aggregate.
     */
    where?: scheduled_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scheduled_tasks to fetch.
     */
    orderBy?: scheduled_tasksOrderByWithRelationInput | scheduled_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: scheduled_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scheduled_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scheduled_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned scheduled_tasks
    **/
    _count?: true | Scheduled_tasksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Scheduled_tasksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Scheduled_tasksMaxAggregateInputType
  }

  export type GetScheduled_tasksAggregateType<T extends Scheduled_tasksAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduled_tasks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduled_tasks[P]>
      : GetScalarType<T[P], AggregateScheduled_tasks[P]>
  }




  export type scheduled_tasksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scheduled_tasksWhereInput
    orderBy?: scheduled_tasksOrderByWithAggregationInput | scheduled_tasksOrderByWithAggregationInput[]
    by: Scheduled_tasksScalarFieldEnum[] | Scheduled_tasksScalarFieldEnum
    having?: scheduled_tasksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Scheduled_tasksCountAggregateInputType | true
    _min?: Scheduled_tasksMinAggregateInputType
    _max?: Scheduled_tasksMaxAggregateInputType
  }

  export type Scheduled_tasksGroupByOutputType = {
    id: string
    task_type: string
    job_id: string | null
    execute_at: Date
    payload: JsonValue | null
    createdAt: Date
    executedAt: Date | null
    status: string
    _count: Scheduled_tasksCountAggregateOutputType | null
    _min: Scheduled_tasksMinAggregateOutputType | null
    _max: Scheduled_tasksMaxAggregateOutputType | null
  }

  type GetScheduled_tasksGroupByPayload<T extends scheduled_tasksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Scheduled_tasksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Scheduled_tasksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Scheduled_tasksGroupByOutputType[P]>
            : GetScalarType<T[P], Scheduled_tasksGroupByOutputType[P]>
        }
      >
    >


  export type scheduled_tasksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_type?: boolean
    job_id?: boolean
    execute_at?: boolean
    payload?: boolean
    createdAt?: boolean
    executedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["scheduled_tasks"]>

  export type scheduled_tasksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_type?: boolean
    job_id?: boolean
    execute_at?: boolean
    payload?: boolean
    createdAt?: boolean
    executedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["scheduled_tasks"]>

  export type scheduled_tasksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_type?: boolean
    job_id?: boolean
    execute_at?: boolean
    payload?: boolean
    createdAt?: boolean
    executedAt?: boolean
    status?: boolean
  }, ExtArgs["result"]["scheduled_tasks"]>

  export type scheduled_tasksSelectScalar = {
    id?: boolean
    task_type?: boolean
    job_id?: boolean
    execute_at?: boolean
    payload?: boolean
    createdAt?: boolean
    executedAt?: boolean
    status?: boolean
  }

  export type scheduled_tasksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "task_type" | "job_id" | "execute_at" | "payload" | "createdAt" | "executedAt" | "status", ExtArgs["result"]["scheduled_tasks"]>

  export type $scheduled_tasksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "scheduled_tasks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      task_type: string
      job_id: string | null
      execute_at: Date
      payload: Prisma.JsonValue | null
      createdAt: Date
      executedAt: Date | null
      status: string
    }, ExtArgs["result"]["scheduled_tasks"]>
    composites: {}
  }

  type scheduled_tasksGetPayload<S extends boolean | null | undefined | scheduled_tasksDefaultArgs> = $Result.GetResult<Prisma.$scheduled_tasksPayload, S>

  type scheduled_tasksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<scheduled_tasksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Scheduled_tasksCountAggregateInputType | true
    }

  export interface scheduled_tasksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['scheduled_tasks'], meta: { name: 'scheduled_tasks' } }
    /**
     * Find zero or one Scheduled_tasks that matches the filter.
     * @param {scheduled_tasksFindUniqueArgs} args - Arguments to find a Scheduled_tasks
     * @example
     * // Get one Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends scheduled_tasksFindUniqueArgs>(args: SelectSubset<T, scheduled_tasksFindUniqueArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scheduled_tasks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {scheduled_tasksFindUniqueOrThrowArgs} args - Arguments to find a Scheduled_tasks
     * @example
     * // Get one Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends scheduled_tasksFindUniqueOrThrowArgs>(args: SelectSubset<T, scheduled_tasksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scheduled_tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduled_tasksFindFirstArgs} args - Arguments to find a Scheduled_tasks
     * @example
     * // Get one Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends scheduled_tasksFindFirstArgs>(args?: SelectSubset<T, scheduled_tasksFindFirstArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scheduled_tasks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduled_tasksFindFirstOrThrowArgs} args - Arguments to find a Scheduled_tasks
     * @example
     * // Get one Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends scheduled_tasksFindFirstOrThrowArgs>(args?: SelectSubset<T, scheduled_tasksFindFirstOrThrowArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scheduled_tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduled_tasksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.findMany()
     * 
     * // Get first 10 Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduled_tasksWithIdOnly = await prisma.scheduled_tasks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends scheduled_tasksFindManyArgs>(args?: SelectSubset<T, scheduled_tasksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scheduled_tasks.
     * @param {scheduled_tasksCreateArgs} args - Arguments to create a Scheduled_tasks.
     * @example
     * // Create one Scheduled_tasks
     * const Scheduled_tasks = await prisma.scheduled_tasks.create({
     *   data: {
     *     // ... data to create a Scheduled_tasks
     *   }
     * })
     * 
     */
    create<T extends scheduled_tasksCreateArgs>(args: SelectSubset<T, scheduled_tasksCreateArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scheduled_tasks.
     * @param {scheduled_tasksCreateManyArgs} args - Arguments to create many Scheduled_tasks.
     * @example
     * // Create many Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends scheduled_tasksCreateManyArgs>(args?: SelectSubset<T, scheduled_tasksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scheduled_tasks and returns the data saved in the database.
     * @param {scheduled_tasksCreateManyAndReturnArgs} args - Arguments to create many Scheduled_tasks.
     * @example
     * // Create many Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scheduled_tasks and only return the `id`
     * const scheduled_tasksWithIdOnly = await prisma.scheduled_tasks.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends scheduled_tasksCreateManyAndReturnArgs>(args?: SelectSubset<T, scheduled_tasksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Scheduled_tasks.
     * @param {scheduled_tasksDeleteArgs} args - Arguments to delete one Scheduled_tasks.
     * @example
     * // Delete one Scheduled_tasks
     * const Scheduled_tasks = await prisma.scheduled_tasks.delete({
     *   where: {
     *     // ... filter to delete one Scheduled_tasks
     *   }
     * })
     * 
     */
    delete<T extends scheduled_tasksDeleteArgs>(args: SelectSubset<T, scheduled_tasksDeleteArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scheduled_tasks.
     * @param {scheduled_tasksUpdateArgs} args - Arguments to update one Scheduled_tasks.
     * @example
     * // Update one Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends scheduled_tasksUpdateArgs>(args: SelectSubset<T, scheduled_tasksUpdateArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scheduled_tasks.
     * @param {scheduled_tasksDeleteManyArgs} args - Arguments to filter Scheduled_tasks to delete.
     * @example
     * // Delete a few Scheduled_tasks
     * const { count } = await prisma.scheduled_tasks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends scheduled_tasksDeleteManyArgs>(args?: SelectSubset<T, scheduled_tasksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scheduled_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduled_tasksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends scheduled_tasksUpdateManyArgs>(args: SelectSubset<T, scheduled_tasksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scheduled_tasks and returns the data updated in the database.
     * @param {scheduled_tasksUpdateManyAndReturnArgs} args - Arguments to update many Scheduled_tasks.
     * @example
     * // Update many Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scheduled_tasks and only return the `id`
     * const scheduled_tasksWithIdOnly = await prisma.scheduled_tasks.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends scheduled_tasksUpdateManyAndReturnArgs>(args: SelectSubset<T, scheduled_tasksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Scheduled_tasks.
     * @param {scheduled_tasksUpsertArgs} args - Arguments to update or create a Scheduled_tasks.
     * @example
     * // Update or create a Scheduled_tasks
     * const scheduled_tasks = await prisma.scheduled_tasks.upsert({
     *   create: {
     *     // ... data to create a Scheduled_tasks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scheduled_tasks we want to update
     *   }
     * })
     */
    upsert<T extends scheduled_tasksUpsertArgs>(args: SelectSubset<T, scheduled_tasksUpsertArgs<ExtArgs>>): Prisma__scheduled_tasksClient<$Result.GetResult<Prisma.$scheduled_tasksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scheduled_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduled_tasksCountArgs} args - Arguments to filter Scheduled_tasks to count.
     * @example
     * // Count the number of Scheduled_tasks
     * const count = await prisma.scheduled_tasks.count({
     *   where: {
     *     // ... the filter for the Scheduled_tasks we want to count
     *   }
     * })
    **/
    count<T extends scheduled_tasksCountArgs>(
      args?: Subset<T, scheduled_tasksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Scheduled_tasksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scheduled_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Scheduled_tasksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Scheduled_tasksAggregateArgs>(args: Subset<T, Scheduled_tasksAggregateArgs>): Prisma.PrismaPromise<GetScheduled_tasksAggregateType<T>>

    /**
     * Group by Scheduled_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scheduled_tasksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends scheduled_tasksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: scheduled_tasksGroupByArgs['orderBy'] }
        : { orderBy?: scheduled_tasksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, scheduled_tasksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduled_tasksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the scheduled_tasks model
   */
  readonly fields: scheduled_tasksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for scheduled_tasks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__scheduled_tasksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the scheduled_tasks model
   */
  interface scheduled_tasksFieldRefs {
    readonly id: FieldRef<"scheduled_tasks", 'String'>
    readonly task_type: FieldRef<"scheduled_tasks", 'String'>
    readonly job_id: FieldRef<"scheduled_tasks", 'String'>
    readonly execute_at: FieldRef<"scheduled_tasks", 'DateTime'>
    readonly payload: FieldRef<"scheduled_tasks", 'Json'>
    readonly createdAt: FieldRef<"scheduled_tasks", 'DateTime'>
    readonly executedAt: FieldRef<"scheduled_tasks", 'DateTime'>
    readonly status: FieldRef<"scheduled_tasks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * scheduled_tasks findUnique
   */
  export type scheduled_tasksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * Filter, which scheduled_tasks to fetch.
     */
    where: scheduled_tasksWhereUniqueInput
  }

  /**
   * scheduled_tasks findUniqueOrThrow
   */
  export type scheduled_tasksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * Filter, which scheduled_tasks to fetch.
     */
    where: scheduled_tasksWhereUniqueInput
  }

  /**
   * scheduled_tasks findFirst
   */
  export type scheduled_tasksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * Filter, which scheduled_tasks to fetch.
     */
    where?: scheduled_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scheduled_tasks to fetch.
     */
    orderBy?: scheduled_tasksOrderByWithRelationInput | scheduled_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scheduled_tasks.
     */
    cursor?: scheduled_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scheduled_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scheduled_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scheduled_tasks.
     */
    distinct?: Scheduled_tasksScalarFieldEnum | Scheduled_tasksScalarFieldEnum[]
  }

  /**
   * scheduled_tasks findFirstOrThrow
   */
  export type scheduled_tasksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * Filter, which scheduled_tasks to fetch.
     */
    where?: scheduled_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scheduled_tasks to fetch.
     */
    orderBy?: scheduled_tasksOrderByWithRelationInput | scheduled_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scheduled_tasks.
     */
    cursor?: scheduled_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scheduled_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scheduled_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scheduled_tasks.
     */
    distinct?: Scheduled_tasksScalarFieldEnum | Scheduled_tasksScalarFieldEnum[]
  }

  /**
   * scheduled_tasks findMany
   */
  export type scheduled_tasksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * Filter, which scheduled_tasks to fetch.
     */
    where?: scheduled_tasksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scheduled_tasks to fetch.
     */
    orderBy?: scheduled_tasksOrderByWithRelationInput | scheduled_tasksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing scheduled_tasks.
     */
    cursor?: scheduled_tasksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scheduled_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scheduled_tasks.
     */
    skip?: number
    distinct?: Scheduled_tasksScalarFieldEnum | Scheduled_tasksScalarFieldEnum[]
  }

  /**
   * scheduled_tasks create
   */
  export type scheduled_tasksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * The data needed to create a scheduled_tasks.
     */
    data: XOR<scheduled_tasksCreateInput, scheduled_tasksUncheckedCreateInput>
  }

  /**
   * scheduled_tasks createMany
   */
  export type scheduled_tasksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many scheduled_tasks.
     */
    data: scheduled_tasksCreateManyInput | scheduled_tasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * scheduled_tasks createManyAndReturn
   */
  export type scheduled_tasksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * The data used to create many scheduled_tasks.
     */
    data: scheduled_tasksCreateManyInput | scheduled_tasksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * scheduled_tasks update
   */
  export type scheduled_tasksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * The data needed to update a scheduled_tasks.
     */
    data: XOR<scheduled_tasksUpdateInput, scheduled_tasksUncheckedUpdateInput>
    /**
     * Choose, which scheduled_tasks to update.
     */
    where: scheduled_tasksWhereUniqueInput
  }

  /**
   * scheduled_tasks updateMany
   */
  export type scheduled_tasksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update scheduled_tasks.
     */
    data: XOR<scheduled_tasksUpdateManyMutationInput, scheduled_tasksUncheckedUpdateManyInput>
    /**
     * Filter which scheduled_tasks to update
     */
    where?: scheduled_tasksWhereInput
    /**
     * Limit how many scheduled_tasks to update.
     */
    limit?: number
  }

  /**
   * scheduled_tasks updateManyAndReturn
   */
  export type scheduled_tasksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * The data used to update scheduled_tasks.
     */
    data: XOR<scheduled_tasksUpdateManyMutationInput, scheduled_tasksUncheckedUpdateManyInput>
    /**
     * Filter which scheduled_tasks to update
     */
    where?: scheduled_tasksWhereInput
    /**
     * Limit how many scheduled_tasks to update.
     */
    limit?: number
  }

  /**
   * scheduled_tasks upsert
   */
  export type scheduled_tasksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * The filter to search for the scheduled_tasks to update in case it exists.
     */
    where: scheduled_tasksWhereUniqueInput
    /**
     * In case the scheduled_tasks found by the `where` argument doesn't exist, create a new scheduled_tasks with this data.
     */
    create: XOR<scheduled_tasksCreateInput, scheduled_tasksUncheckedCreateInput>
    /**
     * In case the scheduled_tasks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<scheduled_tasksUpdateInput, scheduled_tasksUncheckedUpdateInput>
  }

  /**
   * scheduled_tasks delete
   */
  export type scheduled_tasksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
    /**
     * Filter which scheduled_tasks to delete.
     */
    where: scheduled_tasksWhereUniqueInput
  }

  /**
   * scheduled_tasks deleteMany
   */
  export type scheduled_tasksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scheduled_tasks to delete
     */
    where?: scheduled_tasksWhereInput
    /**
     * Limit how many scheduled_tasks to delete.
     */
    limit?: number
  }

  /**
   * scheduled_tasks without action
   */
  export type scheduled_tasksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scheduled_tasks
     */
    select?: scheduled_tasksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scheduled_tasks
     */
    omit?: scheduled_tasksOmit<ExtArgs> | null
  }


  /**
   * Model service_zones
   */

  export type AggregateService_zones = {
    _count: Service_zonesCountAggregateOutputType | null
    _min: Service_zonesMinAggregateOutputType | null
    _max: Service_zonesMaxAggregateOutputType | null
  }

  export type Service_zonesMinAggregateOutputType = {
    id: string | null
    company_id: string | null
    zone_name: string | null
    region_code: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Service_zonesMaxAggregateOutputType = {
    id: string | null
    company_id: string | null
    zone_name: string | null
    region_code: string | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Service_zonesCountAggregateOutputType = {
    id: number
    company_id: number
    zone_name: number
    region_code: number
    boundary_geojson: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Service_zonesMinAggregateInputType = {
    id?: true
    company_id?: true
    zone_name?: true
    region_code?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Service_zonesMaxAggregateInputType = {
    id?: true
    company_id?: true
    zone_name?: true
    region_code?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type Service_zonesCountAggregateInputType = {
    id?: true
    company_id?: true
    zone_name?: true
    region_code?: true
    boundary_geojson?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Service_zonesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_zones to aggregate.
     */
    where?: service_zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_zones to fetch.
     */
    orderBy?: service_zonesOrderByWithRelationInput | service_zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_zones
    **/
    _count?: true | Service_zonesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_zonesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_zonesMaxAggregateInputType
  }

  export type GetService_zonesAggregateType<T extends Service_zonesAggregateArgs> = {
        [P in keyof T & keyof AggregateService_zones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_zones[P]>
      : GetScalarType<T[P], AggregateService_zones[P]>
  }




  export type service_zonesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_zonesWhereInput
    orderBy?: service_zonesOrderByWithAggregationInput | service_zonesOrderByWithAggregationInput[]
    by: Service_zonesScalarFieldEnum[] | Service_zonesScalarFieldEnum
    having?: service_zonesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_zonesCountAggregateInputType | true
    _min?: Service_zonesMinAggregateInputType
    _max?: Service_zonesMaxAggregateInputType
  }

  export type Service_zonesGroupByOutputType = {
    id: string
    company_id: string
    zone_name: string
    region_code: string
    boundary_geojson: JsonValue | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: Service_zonesCountAggregateOutputType | null
    _min: Service_zonesMinAggregateOutputType | null
    _max: Service_zonesMaxAggregateOutputType | null
  }

  type GetService_zonesGroupByPayload<T extends service_zonesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_zonesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_zonesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_zonesGroupByOutputType[P]>
            : GetScalarType<T[P], Service_zonesGroupByOutputType[P]>
        }
      >
    >


  export type service_zonesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    zone_name?: boolean
    region_code?: boolean
    boundary_geojson?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_zones"]>

  export type service_zonesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    zone_name?: boolean
    region_code?: boolean
    boundary_geojson?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_zones"]>

  export type service_zonesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    zone_name?: boolean
    region_code?: boolean
    boundary_geojson?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_zones"]>

  export type service_zonesSelectScalar = {
    id?: boolean
    company_id?: boolean
    zone_name?: boolean
    region_code?: boolean
    boundary_geojson?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type service_zonesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "zone_name" | "region_code" | "boundary_geojson" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["service_zones"]>
  export type service_zonesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type service_zonesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type service_zonesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $service_zonesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_zones"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company_id: string
      zone_name: string
      region_code: string
      boundary_geojson: Prisma.JsonValue | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["service_zones"]>
    composites: {}
  }

  type service_zonesGetPayload<S extends boolean | null | undefined | service_zonesDefaultArgs> = $Result.GetResult<Prisma.$service_zonesPayload, S>

  type service_zonesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<service_zonesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Service_zonesCountAggregateInputType | true
    }

  export interface service_zonesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_zones'], meta: { name: 'service_zones' } }
    /**
     * Find zero or one Service_zones that matches the filter.
     * @param {service_zonesFindUniqueArgs} args - Arguments to find a Service_zones
     * @example
     * // Get one Service_zones
     * const service_zones = await prisma.service_zones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_zonesFindUniqueArgs>(args: SelectSubset<T, service_zonesFindUniqueArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service_zones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {service_zonesFindUniqueOrThrowArgs} args - Arguments to find a Service_zones
     * @example
     * // Get one Service_zones
     * const service_zones = await prisma.service_zones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_zonesFindUniqueOrThrowArgs>(args: SelectSubset<T, service_zonesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_zonesFindFirstArgs} args - Arguments to find a Service_zones
     * @example
     * // Get one Service_zones
     * const service_zones = await prisma.service_zones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_zonesFindFirstArgs>(args?: SelectSubset<T, service_zonesFindFirstArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_zones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_zonesFindFirstOrThrowArgs} args - Arguments to find a Service_zones
     * @example
     * // Get one Service_zones
     * const service_zones = await prisma.service_zones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_zonesFindFirstOrThrowArgs>(args?: SelectSubset<T, service_zonesFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Service_zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_zonesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_zones
     * const service_zones = await prisma.service_zones.findMany()
     * 
     * // Get first 10 Service_zones
     * const service_zones = await prisma.service_zones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_zonesWithIdOnly = await prisma.service_zones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_zonesFindManyArgs>(args?: SelectSubset<T, service_zonesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service_zones.
     * @param {service_zonesCreateArgs} args - Arguments to create a Service_zones.
     * @example
     * // Create one Service_zones
     * const Service_zones = await prisma.service_zones.create({
     *   data: {
     *     // ... data to create a Service_zones
     *   }
     * })
     * 
     */
    create<T extends service_zonesCreateArgs>(args: SelectSubset<T, service_zonesCreateArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Service_zones.
     * @param {service_zonesCreateManyArgs} args - Arguments to create many Service_zones.
     * @example
     * // Create many Service_zones
     * const service_zones = await prisma.service_zones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_zonesCreateManyArgs>(args?: SelectSubset<T, service_zonesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Service_zones and returns the data saved in the database.
     * @param {service_zonesCreateManyAndReturnArgs} args - Arguments to create many Service_zones.
     * @example
     * // Create many Service_zones
     * const service_zones = await prisma.service_zones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Service_zones and only return the `id`
     * const service_zonesWithIdOnly = await prisma.service_zones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends service_zonesCreateManyAndReturnArgs>(args?: SelectSubset<T, service_zonesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service_zones.
     * @param {service_zonesDeleteArgs} args - Arguments to delete one Service_zones.
     * @example
     * // Delete one Service_zones
     * const Service_zones = await prisma.service_zones.delete({
     *   where: {
     *     // ... filter to delete one Service_zones
     *   }
     * })
     * 
     */
    delete<T extends service_zonesDeleteArgs>(args: SelectSubset<T, service_zonesDeleteArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service_zones.
     * @param {service_zonesUpdateArgs} args - Arguments to update one Service_zones.
     * @example
     * // Update one Service_zones
     * const service_zones = await prisma.service_zones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_zonesUpdateArgs>(args: SelectSubset<T, service_zonesUpdateArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Service_zones.
     * @param {service_zonesDeleteManyArgs} args - Arguments to filter Service_zones to delete.
     * @example
     * // Delete a few Service_zones
     * const { count } = await prisma.service_zones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_zonesDeleteManyArgs>(args?: SelectSubset<T, service_zonesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_zonesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_zones
     * const service_zones = await prisma.service_zones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_zonesUpdateManyArgs>(args: SelectSubset<T, service_zonesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_zones and returns the data updated in the database.
     * @param {service_zonesUpdateManyAndReturnArgs} args - Arguments to update many Service_zones.
     * @example
     * // Update many Service_zones
     * const service_zones = await prisma.service_zones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Service_zones and only return the `id`
     * const service_zonesWithIdOnly = await prisma.service_zones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends service_zonesUpdateManyAndReturnArgs>(args: SelectSubset<T, service_zonesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service_zones.
     * @param {service_zonesUpsertArgs} args - Arguments to update or create a Service_zones.
     * @example
     * // Update or create a Service_zones
     * const service_zones = await prisma.service_zones.upsert({
     *   create: {
     *     // ... data to create a Service_zones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_zones we want to update
     *   }
     * })
     */
    upsert<T extends service_zonesUpsertArgs>(args: SelectSubset<T, service_zonesUpsertArgs<ExtArgs>>): Prisma__service_zonesClient<$Result.GetResult<Prisma.$service_zonesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Service_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_zonesCountArgs} args - Arguments to filter Service_zones to count.
     * @example
     * // Count the number of Service_zones
     * const count = await prisma.service_zones.count({
     *   where: {
     *     // ... the filter for the Service_zones we want to count
     *   }
     * })
    **/
    count<T extends service_zonesCountArgs>(
      args?: Subset<T, service_zonesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_zonesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_zonesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_zonesAggregateArgs>(args: Subset<T, Service_zonesAggregateArgs>): Prisma.PrismaPromise<GetService_zonesAggregateType<T>>

    /**
     * Group by Service_zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_zonesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_zonesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_zonesGroupByArgs['orderBy'] }
        : { orderBy?: service_zonesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_zonesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_zonesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_zones model
   */
  readonly fields: service_zonesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_zones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_zonesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_zones model
   */
  interface service_zonesFieldRefs {
    readonly id: FieldRef<"service_zones", 'String'>
    readonly company_id: FieldRef<"service_zones", 'String'>
    readonly zone_name: FieldRef<"service_zones", 'String'>
    readonly region_code: FieldRef<"service_zones", 'String'>
    readonly boundary_geojson: FieldRef<"service_zones", 'Json'>
    readonly is_active: FieldRef<"service_zones", 'Boolean'>
    readonly created_at: FieldRef<"service_zones", 'DateTime'>
    readonly updated_at: FieldRef<"service_zones", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * service_zones findUnique
   */
  export type service_zonesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * Filter, which service_zones to fetch.
     */
    where: service_zonesWhereUniqueInput
  }

  /**
   * service_zones findUniqueOrThrow
   */
  export type service_zonesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * Filter, which service_zones to fetch.
     */
    where: service_zonesWhereUniqueInput
  }

  /**
   * service_zones findFirst
   */
  export type service_zonesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * Filter, which service_zones to fetch.
     */
    where?: service_zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_zones to fetch.
     */
    orderBy?: service_zonesOrderByWithRelationInput | service_zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_zones.
     */
    cursor?: service_zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_zones.
     */
    distinct?: Service_zonesScalarFieldEnum | Service_zonesScalarFieldEnum[]
  }

  /**
   * service_zones findFirstOrThrow
   */
  export type service_zonesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * Filter, which service_zones to fetch.
     */
    where?: service_zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_zones to fetch.
     */
    orderBy?: service_zonesOrderByWithRelationInput | service_zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_zones.
     */
    cursor?: service_zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_zones.
     */
    distinct?: Service_zonesScalarFieldEnum | Service_zonesScalarFieldEnum[]
  }

  /**
   * service_zones findMany
   */
  export type service_zonesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * Filter, which service_zones to fetch.
     */
    where?: service_zonesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_zones to fetch.
     */
    orderBy?: service_zonesOrderByWithRelationInput | service_zonesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_zones.
     */
    cursor?: service_zonesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_zones.
     */
    skip?: number
    distinct?: Service_zonesScalarFieldEnum | Service_zonesScalarFieldEnum[]
  }

  /**
   * service_zones create
   */
  export type service_zonesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * The data needed to create a service_zones.
     */
    data: XOR<service_zonesCreateInput, service_zonesUncheckedCreateInput>
  }

  /**
   * service_zones createMany
   */
  export type service_zonesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_zones.
     */
    data: service_zonesCreateManyInput | service_zonesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_zones createManyAndReturn
   */
  export type service_zonesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * The data used to create many service_zones.
     */
    data: service_zonesCreateManyInput | service_zonesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * service_zones update
   */
  export type service_zonesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * The data needed to update a service_zones.
     */
    data: XOR<service_zonesUpdateInput, service_zonesUncheckedUpdateInput>
    /**
     * Choose, which service_zones to update.
     */
    where: service_zonesWhereUniqueInput
  }

  /**
   * service_zones updateMany
   */
  export type service_zonesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_zones.
     */
    data: XOR<service_zonesUpdateManyMutationInput, service_zonesUncheckedUpdateManyInput>
    /**
     * Filter which service_zones to update
     */
    where?: service_zonesWhereInput
    /**
     * Limit how many service_zones to update.
     */
    limit?: number
  }

  /**
   * service_zones updateManyAndReturn
   */
  export type service_zonesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * The data used to update service_zones.
     */
    data: XOR<service_zonesUpdateManyMutationInput, service_zonesUncheckedUpdateManyInput>
    /**
     * Filter which service_zones to update
     */
    where?: service_zonesWhereInput
    /**
     * Limit how many service_zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * service_zones upsert
   */
  export type service_zonesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * The filter to search for the service_zones to update in case it exists.
     */
    where: service_zonesWhereUniqueInput
    /**
     * In case the service_zones found by the `where` argument doesn't exist, create a new service_zones with this data.
     */
    create: XOR<service_zonesCreateInput, service_zonesUncheckedCreateInput>
    /**
     * In case the service_zones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_zonesUpdateInput, service_zonesUncheckedUpdateInput>
  }

  /**
   * service_zones delete
   */
  export type service_zonesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
    /**
     * Filter which service_zones to delete.
     */
    where: service_zonesWhereUniqueInput
  }

  /**
   * service_zones deleteMany
   */
  export type service_zonesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_zones to delete
     */
    where?: service_zonesWhereInput
    /**
     * Limit how many service_zones to delete.
     */
    limit?: number
  }

  /**
   * service_zones without action
   */
  export type service_zonesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_zones
     */
    select?: service_zonesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_zones
     */
    omit?: service_zonesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_zonesInclude<ExtArgs> | null
  }


  /**
   * Model user_devices
   */

  export type AggregateUser_devices = {
    _count: User_devicesCountAggregateOutputType | null
    _min: User_devicesMinAggregateOutputType | null
    _max: User_devicesMaxAggregateOutputType | null
  }

  export type User_devicesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    device_id: string | null
    fcm_token: string | null
    platform: string | null
    app_version: string | null
    is_active: boolean | null
    last_seen_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_devicesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    device_id: string | null
    fcm_token: string | null
    platform: string | null
    app_version: string | null
    is_active: boolean | null
    last_seen_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type User_devicesCountAggregateOutputType = {
    id: number
    user_id: number
    device_id: number
    fcm_token: number
    platform: number
    app_version: number
    is_active: number
    last_seen_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type User_devicesMinAggregateInputType = {
    id?: true
    user_id?: true
    device_id?: true
    fcm_token?: true
    platform?: true
    app_version?: true
    is_active?: true
    last_seen_at?: true
    created_at?: true
    updated_at?: true
  }

  export type User_devicesMaxAggregateInputType = {
    id?: true
    user_id?: true
    device_id?: true
    fcm_token?: true
    platform?: true
    app_version?: true
    is_active?: true
    last_seen_at?: true
    created_at?: true
    updated_at?: true
  }

  export type User_devicesCountAggregateInputType = {
    id?: true
    user_id?: true
    device_id?: true
    fcm_token?: true
    platform?: true
    app_version?: true
    is_active?: true
    last_seen_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type User_devicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_devices to aggregate.
     */
    where?: user_devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_devices to fetch.
     */
    orderBy?: user_devicesOrderByWithRelationInput | user_devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_devices
    **/
    _count?: true | User_devicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_devicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_devicesMaxAggregateInputType
  }

  export type GetUser_devicesAggregateType<T extends User_devicesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_devices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_devices[P]>
      : GetScalarType<T[P], AggregateUser_devices[P]>
  }




  export type user_devicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_devicesWhereInput
    orderBy?: user_devicesOrderByWithAggregationInput | user_devicesOrderByWithAggregationInput[]
    by: User_devicesScalarFieldEnum[] | User_devicesScalarFieldEnum
    having?: user_devicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_devicesCountAggregateInputType | true
    _min?: User_devicesMinAggregateInputType
    _max?: User_devicesMaxAggregateInputType
  }

  export type User_devicesGroupByOutputType = {
    id: string
    user_id: string
    device_id: string
    fcm_token: string
    platform: string
    app_version: string | null
    is_active: boolean
    last_seen_at: Date
    created_at: Date
    updated_at: Date
    _count: User_devicesCountAggregateOutputType | null
    _min: User_devicesMinAggregateOutputType | null
    _max: User_devicesMaxAggregateOutputType | null
  }

  type GetUser_devicesGroupByPayload<T extends user_devicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_devicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_devicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_devicesGroupByOutputType[P]>
            : GetScalarType<T[P], User_devicesGroupByOutputType[P]>
        }
      >
    >


  export type user_devicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    device_id?: boolean
    fcm_token?: boolean
    platform?: boolean
    app_version?: boolean
    is_active?: boolean
    last_seen_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_devices"]>

  export type user_devicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    device_id?: boolean
    fcm_token?: boolean
    platform?: boolean
    app_version?: boolean
    is_active?: boolean
    last_seen_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_devices"]>

  export type user_devicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    device_id?: boolean
    fcm_token?: boolean
    platform?: boolean
    app_version?: boolean
    is_active?: boolean
    last_seen_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_devices"]>

  export type user_devicesSelectScalar = {
    id?: boolean
    user_id?: boolean
    device_id?: boolean
    fcm_token?: boolean
    platform?: boolean
    app_version?: boolean
    is_active?: boolean
    last_seen_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type user_devicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "device_id" | "fcm_token" | "platform" | "app_version" | "is_active" | "last_seen_at" | "created_at" | "updated_at", ExtArgs["result"]["user_devices"]>
  export type user_devicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_devicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_devicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_devicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_devices"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      device_id: string
      fcm_token: string
      platform: string
      app_version: string | null
      is_active: boolean
      last_seen_at: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user_devices"]>
    composites: {}
  }

  type user_devicesGetPayload<S extends boolean | null | undefined | user_devicesDefaultArgs> = $Result.GetResult<Prisma.$user_devicesPayload, S>

  type user_devicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_devicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_devicesCountAggregateInputType | true
    }

  export interface user_devicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_devices'], meta: { name: 'user_devices' } }
    /**
     * Find zero or one User_devices that matches the filter.
     * @param {user_devicesFindUniqueArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_devicesFindUniqueArgs>(args: SelectSubset<T, user_devicesFindUniqueArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_devices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_devicesFindUniqueOrThrowArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_devicesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_devicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindFirstArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_devicesFindFirstArgs>(args?: SelectSubset<T, user_devicesFindFirstArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_devices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindFirstOrThrowArgs} args - Arguments to find a User_devices
     * @example
     * // Get one User_devices
     * const user_devices = await prisma.user_devices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_devicesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_devicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_devices
     * const user_devices = await prisma.user_devices.findMany()
     * 
     * // Get first 10 User_devices
     * const user_devices = await prisma.user_devices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_devicesWithIdOnly = await prisma.user_devices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_devicesFindManyArgs>(args?: SelectSubset<T, user_devicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_devices.
     * @param {user_devicesCreateArgs} args - Arguments to create a User_devices.
     * @example
     * // Create one User_devices
     * const User_devices = await prisma.user_devices.create({
     *   data: {
     *     // ... data to create a User_devices
     *   }
     * })
     * 
     */
    create<T extends user_devicesCreateArgs>(args: SelectSubset<T, user_devicesCreateArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_devices.
     * @param {user_devicesCreateManyArgs} args - Arguments to create many User_devices.
     * @example
     * // Create many User_devices
     * const user_devices = await prisma.user_devices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_devicesCreateManyArgs>(args?: SelectSubset<T, user_devicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_devices and returns the data saved in the database.
     * @param {user_devicesCreateManyAndReturnArgs} args - Arguments to create many User_devices.
     * @example
     * // Create many User_devices
     * const user_devices = await prisma.user_devices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_devices and only return the `id`
     * const user_devicesWithIdOnly = await prisma.user_devices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_devicesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_devicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_devices.
     * @param {user_devicesDeleteArgs} args - Arguments to delete one User_devices.
     * @example
     * // Delete one User_devices
     * const User_devices = await prisma.user_devices.delete({
     *   where: {
     *     // ... filter to delete one User_devices
     *   }
     * })
     * 
     */
    delete<T extends user_devicesDeleteArgs>(args: SelectSubset<T, user_devicesDeleteArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_devices.
     * @param {user_devicesUpdateArgs} args - Arguments to update one User_devices.
     * @example
     * // Update one User_devices
     * const user_devices = await prisma.user_devices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_devicesUpdateArgs>(args: SelectSubset<T, user_devicesUpdateArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_devices.
     * @param {user_devicesDeleteManyArgs} args - Arguments to filter User_devices to delete.
     * @example
     * // Delete a few User_devices
     * const { count } = await prisma.user_devices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_devicesDeleteManyArgs>(args?: SelectSubset<T, user_devicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_devices
     * const user_devices = await prisma.user_devices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_devicesUpdateManyArgs>(args: SelectSubset<T, user_devicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_devices and returns the data updated in the database.
     * @param {user_devicesUpdateManyAndReturnArgs} args - Arguments to update many User_devices.
     * @example
     * // Update many User_devices
     * const user_devices = await prisma.user_devices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_devices and only return the `id`
     * const user_devicesWithIdOnly = await prisma.user_devices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_devicesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_devicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_devices.
     * @param {user_devicesUpsertArgs} args - Arguments to update or create a User_devices.
     * @example
     * // Update or create a User_devices
     * const user_devices = await prisma.user_devices.upsert({
     *   create: {
     *     // ... data to create a User_devices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_devices we want to update
     *   }
     * })
     */
    upsert<T extends user_devicesUpsertArgs>(args: SelectSubset<T, user_devicesUpsertArgs<ExtArgs>>): Prisma__user_devicesClient<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesCountArgs} args - Arguments to filter User_devices to count.
     * @example
     * // Count the number of User_devices
     * const count = await prisma.user_devices.count({
     *   where: {
     *     // ... the filter for the User_devices we want to count
     *   }
     * })
    **/
    count<T extends user_devicesCountArgs>(
      args?: Subset<T, user_devicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_devicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_devicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_devicesAggregateArgs>(args: Subset<T, User_devicesAggregateArgs>): Prisma.PrismaPromise<GetUser_devicesAggregateType<T>>

    /**
     * Group by User_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_devicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_devicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_devicesGroupByArgs['orderBy'] }
        : { orderBy?: user_devicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_devicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_devicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_devices model
   */
  readonly fields: user_devicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_devices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_devicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_devices model
   */
  interface user_devicesFieldRefs {
    readonly id: FieldRef<"user_devices", 'String'>
    readonly user_id: FieldRef<"user_devices", 'String'>
    readonly device_id: FieldRef<"user_devices", 'String'>
    readonly fcm_token: FieldRef<"user_devices", 'String'>
    readonly platform: FieldRef<"user_devices", 'String'>
    readonly app_version: FieldRef<"user_devices", 'String'>
    readonly is_active: FieldRef<"user_devices", 'Boolean'>
    readonly last_seen_at: FieldRef<"user_devices", 'DateTime'>
    readonly created_at: FieldRef<"user_devices", 'DateTime'>
    readonly updated_at: FieldRef<"user_devices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_devices findUnique
   */
  export type user_devicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * Filter, which user_devices to fetch.
     */
    where: user_devicesWhereUniqueInput
  }

  /**
   * user_devices findUniqueOrThrow
   */
  export type user_devicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * Filter, which user_devices to fetch.
     */
    where: user_devicesWhereUniqueInput
  }

  /**
   * user_devices findFirst
   */
  export type user_devicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * Filter, which user_devices to fetch.
     */
    where?: user_devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_devices to fetch.
     */
    orderBy?: user_devicesOrderByWithRelationInput | user_devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_devices.
     */
    cursor?: user_devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_devices.
     */
    distinct?: User_devicesScalarFieldEnum | User_devicesScalarFieldEnum[]
  }

  /**
   * user_devices findFirstOrThrow
   */
  export type user_devicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * Filter, which user_devices to fetch.
     */
    where?: user_devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_devices to fetch.
     */
    orderBy?: user_devicesOrderByWithRelationInput | user_devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_devices.
     */
    cursor?: user_devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_devices.
     */
    distinct?: User_devicesScalarFieldEnum | User_devicesScalarFieldEnum[]
  }

  /**
   * user_devices findMany
   */
  export type user_devicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * Filter, which user_devices to fetch.
     */
    where?: user_devicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_devices to fetch.
     */
    orderBy?: user_devicesOrderByWithRelationInput | user_devicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_devices.
     */
    cursor?: user_devicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_devices.
     */
    skip?: number
    distinct?: User_devicesScalarFieldEnum | User_devicesScalarFieldEnum[]
  }

  /**
   * user_devices create
   */
  export type user_devicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_devices.
     */
    data: XOR<user_devicesCreateInput, user_devicesUncheckedCreateInput>
  }

  /**
   * user_devices createMany
   */
  export type user_devicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_devices.
     */
    data: user_devicesCreateManyInput | user_devicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_devices createManyAndReturn
   */
  export type user_devicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * The data used to create many user_devices.
     */
    data: user_devicesCreateManyInput | user_devicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_devices update
   */
  export type user_devicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_devices.
     */
    data: XOR<user_devicesUpdateInput, user_devicesUncheckedUpdateInput>
    /**
     * Choose, which user_devices to update.
     */
    where: user_devicesWhereUniqueInput
  }

  /**
   * user_devices updateMany
   */
  export type user_devicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_devices.
     */
    data: XOR<user_devicesUpdateManyMutationInput, user_devicesUncheckedUpdateManyInput>
    /**
     * Filter which user_devices to update
     */
    where?: user_devicesWhereInput
    /**
     * Limit how many user_devices to update.
     */
    limit?: number
  }

  /**
   * user_devices updateManyAndReturn
   */
  export type user_devicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * The data used to update user_devices.
     */
    data: XOR<user_devicesUpdateManyMutationInput, user_devicesUncheckedUpdateManyInput>
    /**
     * Filter which user_devices to update
     */
    where?: user_devicesWhereInput
    /**
     * Limit how many user_devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_devices upsert
   */
  export type user_devicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_devices to update in case it exists.
     */
    where: user_devicesWhereUniqueInput
    /**
     * In case the user_devices found by the `where` argument doesn't exist, create a new user_devices with this data.
     */
    create: XOR<user_devicesCreateInput, user_devicesUncheckedCreateInput>
    /**
     * In case the user_devices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_devicesUpdateInput, user_devicesUncheckedUpdateInput>
  }

  /**
   * user_devices delete
   */
  export type user_devicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    /**
     * Filter which user_devices to delete.
     */
    where: user_devicesWhereUniqueInput
  }

  /**
   * user_devices deleteMany
   */
  export type user_devicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_devices to delete
     */
    where?: user_devicesWhereInput
    /**
     * Limit how many user_devices to delete.
     */
    limit?: number
  }

  /**
   * user_devices without action
   */
  export type user_devicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
  }


  /**
   * Model verification_codes
   */

  export type AggregateVerification_codes = {
    _count: Verification_codesCountAggregateOutputType | null
    _min: Verification_codesMinAggregateOutputType | null
    _max: Verification_codesMaxAggregateOutputType | null
  }

  export type Verification_codesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    type: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    usedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Verification_codesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    type: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    usedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Verification_codesCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    type: number
    expiresAt: number
    isUsed: number
    usedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Verification_codesMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    usedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Verification_codesMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    usedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Verification_codesCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    type?: true
    expiresAt?: true
    isUsed?: true
    usedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Verification_codesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verification_codes to aggregate.
     */
    where?: verification_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_codes to fetch.
     */
    orderBy?: verification_codesOrderByWithRelationInput | verification_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: verification_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned verification_codes
    **/
    _count?: true | Verification_codesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Verification_codesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Verification_codesMaxAggregateInputType
  }

  export type GetVerification_codesAggregateType<T extends Verification_codesAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification_codes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification_codes[P]>
      : GetScalarType<T[P], AggregateVerification_codes[P]>
  }




  export type verification_codesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: verification_codesWhereInput
    orderBy?: verification_codesOrderByWithAggregationInput | verification_codesOrderByWithAggregationInput[]
    by: Verification_codesScalarFieldEnum[] | Verification_codesScalarFieldEnum
    having?: verification_codesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Verification_codesCountAggregateInputType | true
    _min?: Verification_codesMinAggregateInputType
    _max?: Verification_codesMaxAggregateInputType
  }

  export type Verification_codesGroupByOutputType = {
    id: string
    userId: string
    code: string
    type: string
    expiresAt: Date
    isUsed: boolean
    usedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: Verification_codesCountAggregateOutputType | null
    _min: Verification_codesMinAggregateOutputType | null
    _max: Verification_codesMaxAggregateOutputType | null
  }

  type GetVerification_codesGroupByPayload<T extends verification_codesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Verification_codesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Verification_codesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Verification_codesGroupByOutputType[P]>
            : GetScalarType<T[P], Verification_codesGroupByOutputType[P]>
        }
      >
    >


  export type verification_codesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    usedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification_codes"]>

  export type verification_codesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    usedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification_codes"]>

  export type verification_codesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    usedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification_codes"]>

  export type verification_codesSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    type?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    usedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type verification_codesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "code" | "type" | "expiresAt" | "isUsed" | "usedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification_codes"]>
  export type verification_codesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type verification_codesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type verification_codesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $verification_codesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "verification_codes"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      code: string
      type: string
      expiresAt: Date
      isUsed: boolean
      usedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification_codes"]>
    composites: {}
  }

  type verification_codesGetPayload<S extends boolean | null | undefined | verification_codesDefaultArgs> = $Result.GetResult<Prisma.$verification_codesPayload, S>

  type verification_codesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<verification_codesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Verification_codesCountAggregateInputType | true
    }

  export interface verification_codesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['verification_codes'], meta: { name: 'verification_codes' } }
    /**
     * Find zero or one Verification_codes that matches the filter.
     * @param {verification_codesFindUniqueArgs} args - Arguments to find a Verification_codes
     * @example
     * // Get one Verification_codes
     * const verification_codes = await prisma.verification_codes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends verification_codesFindUniqueArgs>(args: SelectSubset<T, verification_codesFindUniqueArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification_codes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {verification_codesFindUniqueOrThrowArgs} args - Arguments to find a Verification_codes
     * @example
     * // Get one Verification_codes
     * const verification_codes = await prisma.verification_codes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends verification_codesFindUniqueOrThrowArgs>(args: SelectSubset<T, verification_codesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_codesFindFirstArgs} args - Arguments to find a Verification_codes
     * @example
     * // Get one Verification_codes
     * const verification_codes = await prisma.verification_codes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends verification_codesFindFirstArgs>(args?: SelectSubset<T, verification_codesFindFirstArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification_codes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_codesFindFirstOrThrowArgs} args - Arguments to find a Verification_codes
     * @example
     * // Get one Verification_codes
     * const verification_codes = await prisma.verification_codes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends verification_codesFindFirstOrThrowArgs>(args?: SelectSubset<T, verification_codesFindFirstOrThrowArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verification_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_codesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verification_codes
     * const verification_codes = await prisma.verification_codes.findMany()
     * 
     * // Get first 10 Verification_codes
     * const verification_codes = await prisma.verification_codes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verification_codesWithIdOnly = await prisma.verification_codes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends verification_codesFindManyArgs>(args?: SelectSubset<T, verification_codesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification_codes.
     * @param {verification_codesCreateArgs} args - Arguments to create a Verification_codes.
     * @example
     * // Create one Verification_codes
     * const Verification_codes = await prisma.verification_codes.create({
     *   data: {
     *     // ... data to create a Verification_codes
     *   }
     * })
     * 
     */
    create<T extends verification_codesCreateArgs>(args: SelectSubset<T, verification_codesCreateArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verification_codes.
     * @param {verification_codesCreateManyArgs} args - Arguments to create many Verification_codes.
     * @example
     * // Create many Verification_codes
     * const verification_codes = await prisma.verification_codes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends verification_codesCreateManyArgs>(args?: SelectSubset<T, verification_codesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verification_codes and returns the data saved in the database.
     * @param {verification_codesCreateManyAndReturnArgs} args - Arguments to create many Verification_codes.
     * @example
     * // Create many Verification_codes
     * const verification_codes = await prisma.verification_codes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verification_codes and only return the `id`
     * const verification_codesWithIdOnly = await prisma.verification_codes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends verification_codesCreateManyAndReturnArgs>(args?: SelectSubset<T, verification_codesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification_codes.
     * @param {verification_codesDeleteArgs} args - Arguments to delete one Verification_codes.
     * @example
     * // Delete one Verification_codes
     * const Verification_codes = await prisma.verification_codes.delete({
     *   where: {
     *     // ... filter to delete one Verification_codes
     *   }
     * })
     * 
     */
    delete<T extends verification_codesDeleteArgs>(args: SelectSubset<T, verification_codesDeleteArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification_codes.
     * @param {verification_codesUpdateArgs} args - Arguments to update one Verification_codes.
     * @example
     * // Update one Verification_codes
     * const verification_codes = await prisma.verification_codes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends verification_codesUpdateArgs>(args: SelectSubset<T, verification_codesUpdateArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verification_codes.
     * @param {verification_codesDeleteManyArgs} args - Arguments to filter Verification_codes to delete.
     * @example
     * // Delete a few Verification_codes
     * const { count } = await prisma.verification_codes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends verification_codesDeleteManyArgs>(args?: SelectSubset<T, verification_codesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verification_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_codesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verification_codes
     * const verification_codes = await prisma.verification_codes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends verification_codesUpdateManyArgs>(args: SelectSubset<T, verification_codesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verification_codes and returns the data updated in the database.
     * @param {verification_codesUpdateManyAndReturnArgs} args - Arguments to update many Verification_codes.
     * @example
     * // Update many Verification_codes
     * const verification_codes = await prisma.verification_codes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verification_codes and only return the `id`
     * const verification_codesWithIdOnly = await prisma.verification_codes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends verification_codesUpdateManyAndReturnArgs>(args: SelectSubset<T, verification_codesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification_codes.
     * @param {verification_codesUpsertArgs} args - Arguments to update or create a Verification_codes.
     * @example
     * // Update or create a Verification_codes
     * const verification_codes = await prisma.verification_codes.upsert({
     *   create: {
     *     // ... data to create a Verification_codes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification_codes we want to update
     *   }
     * })
     */
    upsert<T extends verification_codesUpsertArgs>(args: SelectSubset<T, verification_codesUpsertArgs<ExtArgs>>): Prisma__verification_codesClient<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verification_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_codesCountArgs} args - Arguments to filter Verification_codes to count.
     * @example
     * // Count the number of Verification_codes
     * const count = await prisma.verification_codes.count({
     *   where: {
     *     // ... the filter for the Verification_codes we want to count
     *   }
     * })
    **/
    count<T extends verification_codesCountArgs>(
      args?: Subset<T, verification_codesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Verification_codesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Verification_codesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Verification_codesAggregateArgs>(args: Subset<T, Verification_codesAggregateArgs>): Prisma.PrismaPromise<GetVerification_codesAggregateType<T>>

    /**
     * Group by Verification_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_codesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends verification_codesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: verification_codesGroupByArgs['orderBy'] }
        : { orderBy?: verification_codesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, verification_codesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerification_codesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the verification_codes model
   */
  readonly fields: verification_codesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for verification_codes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__verification_codesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the verification_codes model
   */
  interface verification_codesFieldRefs {
    readonly id: FieldRef<"verification_codes", 'String'>
    readonly userId: FieldRef<"verification_codes", 'String'>
    readonly code: FieldRef<"verification_codes", 'String'>
    readonly type: FieldRef<"verification_codes", 'String'>
    readonly expiresAt: FieldRef<"verification_codes", 'DateTime'>
    readonly isUsed: FieldRef<"verification_codes", 'Boolean'>
    readonly usedAt: FieldRef<"verification_codes", 'DateTime'>
    readonly createdAt: FieldRef<"verification_codes", 'DateTime'>
    readonly updatedAt: FieldRef<"verification_codes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * verification_codes findUnique
   */
  export type verification_codesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * Filter, which verification_codes to fetch.
     */
    where: verification_codesWhereUniqueInput
  }

  /**
   * verification_codes findUniqueOrThrow
   */
  export type verification_codesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * Filter, which verification_codes to fetch.
     */
    where: verification_codesWhereUniqueInput
  }

  /**
   * verification_codes findFirst
   */
  export type verification_codesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * Filter, which verification_codes to fetch.
     */
    where?: verification_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_codes to fetch.
     */
    orderBy?: verification_codesOrderByWithRelationInput | verification_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verification_codes.
     */
    cursor?: verification_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verification_codes.
     */
    distinct?: Verification_codesScalarFieldEnum | Verification_codesScalarFieldEnum[]
  }

  /**
   * verification_codes findFirstOrThrow
   */
  export type verification_codesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * Filter, which verification_codes to fetch.
     */
    where?: verification_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_codes to fetch.
     */
    orderBy?: verification_codesOrderByWithRelationInput | verification_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verification_codes.
     */
    cursor?: verification_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verification_codes.
     */
    distinct?: Verification_codesScalarFieldEnum | Verification_codesScalarFieldEnum[]
  }

  /**
   * verification_codes findMany
   */
  export type verification_codesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * Filter, which verification_codes to fetch.
     */
    where?: verification_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_codes to fetch.
     */
    orderBy?: verification_codesOrderByWithRelationInput | verification_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing verification_codes.
     */
    cursor?: verification_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_codes.
     */
    skip?: number
    distinct?: Verification_codesScalarFieldEnum | Verification_codesScalarFieldEnum[]
  }

  /**
   * verification_codes create
   */
  export type verification_codesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * The data needed to create a verification_codes.
     */
    data: XOR<verification_codesCreateInput, verification_codesUncheckedCreateInput>
  }

  /**
   * verification_codes createMany
   */
  export type verification_codesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many verification_codes.
     */
    data: verification_codesCreateManyInput | verification_codesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * verification_codes createManyAndReturn
   */
  export type verification_codesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * The data used to create many verification_codes.
     */
    data: verification_codesCreateManyInput | verification_codesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * verification_codes update
   */
  export type verification_codesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * The data needed to update a verification_codes.
     */
    data: XOR<verification_codesUpdateInput, verification_codesUncheckedUpdateInput>
    /**
     * Choose, which verification_codes to update.
     */
    where: verification_codesWhereUniqueInput
  }

  /**
   * verification_codes updateMany
   */
  export type verification_codesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update verification_codes.
     */
    data: XOR<verification_codesUpdateManyMutationInput, verification_codesUncheckedUpdateManyInput>
    /**
     * Filter which verification_codes to update
     */
    where?: verification_codesWhereInput
    /**
     * Limit how many verification_codes to update.
     */
    limit?: number
  }

  /**
   * verification_codes updateManyAndReturn
   */
  export type verification_codesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * The data used to update verification_codes.
     */
    data: XOR<verification_codesUpdateManyMutationInput, verification_codesUncheckedUpdateManyInput>
    /**
     * Filter which verification_codes to update
     */
    where?: verification_codesWhereInput
    /**
     * Limit how many verification_codes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * verification_codes upsert
   */
  export type verification_codesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * The filter to search for the verification_codes to update in case it exists.
     */
    where: verification_codesWhereUniqueInput
    /**
     * In case the verification_codes found by the `where` argument doesn't exist, create a new verification_codes with this data.
     */
    create: XOR<verification_codesCreateInput, verification_codesUncheckedCreateInput>
    /**
     * In case the verification_codes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<verification_codesUpdateInput, verification_codesUncheckedUpdateInput>
  }

  /**
   * verification_codes delete
   */
  export type verification_codesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    /**
     * Filter which verification_codes to delete.
     */
    where: verification_codesWhereUniqueInput
  }

  /**
   * verification_codes deleteMany
   */
  export type verification_codesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verification_codes to delete
     */
    where?: verification_codesWhereInput
    /**
     * Limit how many verification_codes to delete.
     */
    limit?: number
  }

  /**
   * verification_codes without action
   */
  export type verification_codesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    phone: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    language: string | null
    kyc_status: $Enums.KYCStatus | null
    kyc_document_url: string | null
    mfa_enabled: boolean | null
    mfa_secret: string | null
    last_login_at: Date | null
    is_active: boolean | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    company_id: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    role: $Enums.UserRole | null
    phone: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    language: string | null
    kyc_status: $Enums.KYCStatus | null
    kyc_document_url: string | null
    mfa_enabled: boolean | null
    mfa_secret: string | null
    last_login_at: Date | null
    is_active: boolean | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    company_id: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    role: number
    phone: number
    email: number
    password_hash: number
    name: number
    language: number
    kyc_status: number
    kyc_document_url: number
    mfa_enabled: number
    mfa_secret: number
    last_login_at: number
    is_active: number
    deleted_at: number
    created_at: number
    updated_at: number
    company_id: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    role?: true
    phone?: true
    email?: true
    password_hash?: true
    name?: true
    language?: true
    kyc_status?: true
    kyc_document_url?: true
    mfa_enabled?: true
    mfa_secret?: true
    last_login_at?: true
    is_active?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    company_id?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    role?: true
    phone?: true
    email?: true
    password_hash?: true
    name?: true
    language?: true
    kyc_status?: true
    kyc_document_url?: true
    mfa_enabled?: true
    mfa_secret?: true
    last_login_at?: true
    is_active?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    company_id?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    role?: true
    phone?: true
    email?: true
    password_hash?: true
    name?: true
    language?: true
    kyc_status?: true
    kyc_document_url?: true
    mfa_enabled?: true
    mfa_secret?: true
    last_login_at?: true
    is_active?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    company_id?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    role: $Enums.UserRole
    phone: string
    email: string | null
    password_hash: string
    name: string
    language: string
    kyc_status: $Enums.KYCStatus
    kyc_document_url: string | null
    mfa_enabled: boolean
    mfa_secret: string | null
    last_login_at: Date | null
    is_active: boolean
    deleted_at: Date | null
    created_at: Date
    updated_at: Date
    company_id: string | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    language?: boolean
    kyc_status?: boolean
    kyc_document_url?: boolean
    mfa_enabled?: boolean
    mfa_secret?: boolean
    last_login_at?: boolean
    is_active?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_id?: boolean
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    caregivers?: boolean | users$caregiversArgs<ExtArgs>
    disputes_disputes_againstTousers?: boolean | users$disputes_disputes_againstTousersArgs<ExtArgs>
    disputes_disputes_raised_byTousers?: boolean | users$disputes_disputes_raised_byTousersArgs<ExtArgs>
    feedbacks_feedbacks_to_user_idTousers?: boolean | users$feedbacks_feedbacks_to_user_idTousersArgs<ExtArgs>
    feedbacks_feedbacks_from_user_idTousers?: boolean | users$feedbacks_feedbacks_from_user_idTousersArgs<ExtArgs>
    job_applications?: boolean | users$job_applicationsArgs<ExtArgs>
    jobs?: boolean | users$jobsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    patients?: boolean | users$patientsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    user_devices?: boolean | users$user_devicesArgs<ExtArgs>
    verification_codes?: boolean | users$verification_codesArgs<ExtArgs>
    companies?: boolean | users$companiesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    language?: boolean
    kyc_status?: boolean
    kyc_document_url?: boolean
    mfa_enabled?: boolean
    mfa_secret?: boolean
    last_login_at?: boolean
    is_active?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_id?: boolean
    companies?: boolean | users$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    language?: boolean
    kyc_status?: boolean
    kyc_document_url?: boolean
    mfa_enabled?: boolean
    mfa_secret?: boolean
    last_login_at?: boolean
    is_active?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_id?: boolean
    companies?: boolean | users$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    role?: boolean
    phone?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    language?: boolean
    kyc_status?: boolean
    kyc_document_url?: boolean
    mfa_enabled?: boolean
    mfa_secret?: boolean
    last_login_at?: boolean
    is_active?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_id?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "phone" | "email" | "password_hash" | "name" | "language" | "kyc_status" | "kyc_document_url" | "mfa_enabled" | "mfa_secret" | "last_login_at" | "is_active" | "deleted_at" | "created_at" | "updated_at" | "company_id", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audit_logs?: boolean | users$audit_logsArgs<ExtArgs>
    caregivers?: boolean | users$caregiversArgs<ExtArgs>
    disputes_disputes_againstTousers?: boolean | users$disputes_disputes_againstTousersArgs<ExtArgs>
    disputes_disputes_raised_byTousers?: boolean | users$disputes_disputes_raised_byTousersArgs<ExtArgs>
    feedbacks_feedbacks_to_user_idTousers?: boolean | users$feedbacks_feedbacks_to_user_idTousersArgs<ExtArgs>
    feedbacks_feedbacks_from_user_idTousers?: boolean | users$feedbacks_feedbacks_from_user_idTousersArgs<ExtArgs>
    job_applications?: boolean | users$job_applicationsArgs<ExtArgs>
    jobs?: boolean | users$jobsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    patients?: boolean | users$patientsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    user_devices?: boolean | users$user_devicesArgs<ExtArgs>
    verification_codes?: boolean | users$verification_codesArgs<ExtArgs>
    companies?: boolean | users$companiesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | users$companiesArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | users$companiesArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      audit_logs: Prisma.$audit_logsPayload<ExtArgs>[]
      caregivers: Prisma.$caregiversPayload<ExtArgs> | null
      disputes_disputes_againstTousers: Prisma.$disputesPayload<ExtArgs>[]
      disputes_disputes_raised_byTousers: Prisma.$disputesPayload<ExtArgs>[]
      feedbacks_feedbacks_to_user_idTousers: Prisma.$feedbacksPayload<ExtArgs>[]
      feedbacks_feedbacks_from_user_idTousers: Prisma.$feedbacksPayload<ExtArgs>[]
      job_applications: Prisma.$job_applicationsPayload<ExtArgs>[]
      jobs: Prisma.$jobsPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      patients: Prisma.$patientsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      user_devices: Prisma.$user_devicesPayload<ExtArgs>[]
      verification_codes: Prisma.$verification_codesPayload<ExtArgs>[]
      companies: Prisma.$companiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.UserRole
      phone: string
      email: string | null
      password_hash: string
      name: string
      language: string
      kyc_status: $Enums.KYCStatus
      kyc_document_url: string | null
      mfa_enabled: boolean
      mfa_secret: string | null
      last_login_at: Date | null
      is_active: boolean
      deleted_at: Date | null
      created_at: Date
      updated_at: Date
      company_id: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    audit_logs<T extends users$audit_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$audit_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$audit_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    caregivers<T extends users$caregiversArgs<ExtArgs> = {}>(args?: Subset<T, users$caregiversArgs<ExtArgs>>): Prisma__caregiversClient<$Result.GetResult<Prisma.$caregiversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    disputes_disputes_againstTousers<T extends users$disputes_disputes_againstTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$disputes_disputes_againstTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputes_disputes_raised_byTousers<T extends users$disputes_disputes_raised_byTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$disputes_disputes_raised_byTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disputesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks_feedbacks_to_user_idTousers<T extends users$feedbacks_feedbacks_to_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$feedbacks_feedbacks_to_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks_feedbacks_from_user_idTousers<T extends users$feedbacks_feedbacks_from_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$feedbacks_feedbacks_from_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    job_applications<T extends users$job_applicationsArgs<ExtArgs> = {}>(args?: Subset<T, users$job_applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_applicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobs<T extends users$jobsArgs<ExtArgs> = {}>(args?: Subset<T, users$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patients<T extends users$patientsArgs<ExtArgs> = {}>(args?: Subset<T, users$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends users$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, users$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_devices<T extends users$user_devicesArgs<ExtArgs> = {}>(args?: Subset<T, users$user_devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_devicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verification_codes<T extends users$verification_codesArgs<ExtArgs> = {}>(args?: Subset<T, users$verification_codesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verification_codesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends users$companiesArgs<ExtArgs> = {}>(args?: Subset<T, users$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'UserRole'>
    readonly phone: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly language: FieldRef<"users", 'String'>
    readonly kyc_status: FieldRef<"users", 'KYCStatus'>
    readonly kyc_document_url: FieldRef<"users", 'String'>
    readonly mfa_enabled: FieldRef<"users", 'Boolean'>
    readonly mfa_secret: FieldRef<"users", 'String'>
    readonly last_login_at: FieldRef<"users", 'DateTime'>
    readonly is_active: FieldRef<"users", 'Boolean'>
    readonly deleted_at: FieldRef<"users", 'DateTime'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly company_id: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.audit_logs
   */
  export type users$audit_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the audit_logs
     */
    select?: audit_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the audit_logs
     */
    omit?: audit_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audit_logsInclude<ExtArgs> | null
    where?: audit_logsWhereInput
    orderBy?: audit_logsOrderByWithRelationInput | audit_logsOrderByWithRelationInput[]
    cursor?: audit_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Audit_logsScalarFieldEnum | Audit_logsScalarFieldEnum[]
  }

  /**
   * users.caregivers
   */
  export type users$caregiversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the caregivers
     */
    select?: caregiversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the caregivers
     */
    omit?: caregiversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: caregiversInclude<ExtArgs> | null
    where?: caregiversWhereInput
  }

  /**
   * users.disputes_disputes_againstTousers
   */
  export type users$disputes_disputes_againstTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    where?: disputesWhereInput
    orderBy?: disputesOrderByWithRelationInput | disputesOrderByWithRelationInput[]
    cursor?: disputesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputesScalarFieldEnum | DisputesScalarFieldEnum[]
  }

  /**
   * users.disputes_disputes_raised_byTousers
   */
  export type users$disputes_disputes_raised_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disputes
     */
    select?: disputesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disputes
     */
    omit?: disputesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disputesInclude<ExtArgs> | null
    where?: disputesWhereInput
    orderBy?: disputesOrderByWithRelationInput | disputesOrderByWithRelationInput[]
    cursor?: disputesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputesScalarFieldEnum | DisputesScalarFieldEnum[]
  }

  /**
   * users.feedbacks_feedbacks_to_user_idTousers
   */
  export type users$feedbacks_feedbacks_to_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    where?: feedbacksWhereInput
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    cursor?: feedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * users.feedbacks_feedbacks_from_user_idTousers
   */
  export type users$feedbacks_feedbacks_from_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    where?: feedbacksWhereInput
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    cursor?: feedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * users.job_applications
   */
  export type users$job_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_applications
     */
    select?: job_applicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_applications
     */
    omit?: job_applicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: job_applicationsInclude<ExtArgs> | null
    where?: job_applicationsWhereInput
    orderBy?: job_applicationsOrderByWithRelationInput | job_applicationsOrderByWithRelationInput[]
    cursor?: job_applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Job_applicationsScalarFieldEnum | Job_applicationsScalarFieldEnum[]
  }

  /**
   * users.jobs
   */
  export type users$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    cursor?: jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * users.notifications
   */
  export type users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.patients
   */
  export type users$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    where?: patientsWhereInput
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    cursor?: patientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * users.payments
   */
  export type users$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * users.user_devices
   */
  export type users$user_devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_devices
     */
    select?: user_devicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_devices
     */
    omit?: user_devicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_devicesInclude<ExtArgs> | null
    where?: user_devicesWhereInput
    orderBy?: user_devicesOrderByWithRelationInput | user_devicesOrderByWithRelationInput[]
    cursor?: user_devicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_devicesScalarFieldEnum | User_devicesScalarFieldEnum[]
  }

  /**
   * users.verification_codes
   */
  export type users$verification_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_codes
     */
    select?: verification_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_codes
     */
    omit?: verification_codesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: verification_codesInclude<ExtArgs> | null
    where?: verification_codesWhereInput
    orderBy?: verification_codesOrderByWithRelationInput | verification_codesOrderByWithRelationInput[]
    cursor?: verification_codesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Verification_codesScalarFieldEnum | Verification_codesScalarFieldEnum[]
  }

  /**
   * users.companies
   */
  export type users$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssignmentsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    caregiver_id: 'caregiver_id',
    role: 'role',
    shift_start_time: 'shift_start_time',
    shift_end_time: 'shift_end_time',
    days_of_week: 'days_of_week',
    status: 'status',
    replaced_by: 'replaced_by',
    replacement_reason: 'replacement_reason',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AssignmentsScalarFieldEnum = (typeof AssignmentsScalarFieldEnum)[keyof typeof AssignmentsScalarFieldEnum]


  export const Audit_logsScalarFieldEnum: {
    id: 'id',
    actor_id: 'actor_id',
    actor_role: 'actor_role',
    action_type: 'action_type',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    changes: 'changes',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    timestamp: 'timestamp'
  };

  export type Audit_logsScalarFieldEnum = (typeof Audit_logsScalarFieldEnum)[keyof typeof Audit_logsScalarFieldEnum]


  export const Care_logsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    assignment_id: 'assignment_id',
    caregiver_id: 'caregiver_id',
    patient_id: 'patient_id',
    log_type: 'log_type',
    timestamp: 'timestamp',
    location_lat: 'location_lat',
    location_lng: 'location_lng',
    data: 'data',
    notes: 'notes',
    photo_urls: 'photo_urls',
    guardian_notified: 'guardian_notified',
    createdAt: 'createdAt'
  };

  export type Care_logsScalarFieldEnum = (typeof Care_logsScalarFieldEnum)[keyof typeof Care_logsScalarFieldEnum]


  export const CaregiversScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    company_id: 'company_id',
    nid: 'nid',
    nid_url: 'nid_url',
    photo_url: 'photo_url',
    date_of_birth: 'date_of_birth',
    gender: 'gender',
    address: 'address',
    location_lat: 'location_lat',
    location_lng: 'location_lng',
    skills: 'skills',
    certifications: 'certifications',
    experience_years: 'experience_years',
    languages: 'languages',
    availabilityCalendar: 'availabilityCalendar',
    hourly_rate: 'hourly_rate',
    background_check_status: 'background_check_status',
    background_check_date: 'background_check_date',
    rating_avg: 'rating_avg',
    rating_count: 'rating_count',
    total_jobs_completed: 'total_jobs_completed',
    is_available: 'is_available',
    is_verified: 'is_verified',
    verification_notes: 'verification_notes',
    deleted_at: 'deleted_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CaregiversScalarFieldEnum = (typeof CaregiversScalarFieldEnum)[keyof typeof CaregiversScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    company_name: 'company_name',
    trade_license: 'trade_license',
    trade_license_url: 'trade_license_url',
    tin: 'tin',
    contact_person: 'contact_person',
    contact_phone: 'contact_phone',
    contact_email: 'contact_email',
    address: 'address',
    logo_url: 'logo_url',
    description: 'description',
    specializations: 'specializations',
    payout_method: 'payout_method',
    payout_account: 'payout_account',
    commission_rate: 'commission_rate',
    subscription_tier: 'subscription_tier',
    subscription_expires_at: 'subscription_expires_at',
    rating_avg: 'rating_avg',
    rating_count: 'rating_count',
    is_verified: 'is_verified',
    verification_notes: 'verification_notes',
    deleted_at: 'deleted_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const DisputesScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    raised_by: 'raised_by',
    against: 'against',
    dispute_type: 'dispute_type',
    description: 'description',
    evidence_urls: 'evidence_urls',
    status: 'status',
    assigned_moderator: 'assigned_moderator',
    resolution: 'resolution',
    resolution_action: 'resolution_action',
    resolved_at: 'resolved_at',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisputesScalarFieldEnum = (typeof DisputesScalarFieldEnum)[keyof typeof DisputesScalarFieldEnum]


  export const EscrowsScalarFieldEnum: {
    id: 'id',
    payment_id: 'payment_id',
    amount: 'amount',
    fee: 'fee',
    status: 'status',
    released_at: 'released_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EscrowsScalarFieldEnum = (typeof EscrowsScalarFieldEnum)[keyof typeof EscrowsScalarFieldEnum]


  export const Escrow_recordsScalarFieldEnum: {
    id: 'id',
    external_ref: 'external_ref',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    released_at: 'released_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Escrow_recordsScalarFieldEnum = (typeof Escrow_recordsScalarFieldEnum)[keyof typeof Escrow_recordsScalarFieldEnum]


  export const Escrow_ledgerScalarFieldEnum: {
    id: 'id',
    escrow_id: 'escrow_id',
    action: 'action',
    amount: 'amount',
    note: 'note',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Escrow_ledgerScalarFieldEnum = (typeof Escrow_ledgerScalarFieldEnum)[keyof typeof Escrow_ledgerScalarFieldEnum]


  export const Provider_transactionsScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    provider_tx_id: 'provider_tx_id',
    status: 'status',
    amount: 'amount',
    currency: 'currency',
    payload: 'payload',
    escrow_id: 'escrow_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Provider_transactionsScalarFieldEnum = (typeof Provider_transactionsScalarFieldEnum)[keyof typeof Provider_transactionsScalarFieldEnum]


  export const Transaction_logsScalarFieldEnum: {
    id: 'id',
    provider_transaction_id: 'provider_transaction_id',
    action: 'action',
    previous_status: 'previous_status',
    new_status: 'new_status',
    note: 'note',
    created_at: 'created_at'
  };

  export type Transaction_logsScalarFieldEnum = (typeof Transaction_logsScalarFieldEnum)[keyof typeof Transaction_logsScalarFieldEnum]


  export const FeedbacksScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    from_user_id: 'from_user_id',
    to_user_id: 'to_user_id',
    reviewee_type: 'reviewee_type',
    rating: 'rating',
    tags: 'tags',
    comments: 'comments',
    is_public: 'is_public',
    company_response: 'company_response',
    responded_at: 'responded_at',
    flagged_inappropriate: 'flagged_inappropriate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedbacksScalarFieldEnum = (typeof FeedbacksScalarFieldEnum)[keyof typeof FeedbacksScalarFieldEnum]


  export const Health_recordsScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    record_type: 'record_type',
    title: 'title',
    description: 'description',
    file_url: 'file_url',
    metadata: 'metadata',
    uploaded_by: 'uploaded_by',
    valid_from: 'valid_from',
    valid_until: 'valid_until',
    is_archived: 'is_archived',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Health_recordsScalarFieldEnum = (typeof Health_recordsScalarFieldEnum)[keyof typeof Health_recordsScalarFieldEnum]


  export const Job_applicationsScalarFieldEnum: {
    id: 'id',
    marketplace_job_id: 'marketplace_job_id',
    caregiver_id: 'caregiver_id',
    coverLetter: 'coverLetter',
    status: 'status',
    reviewed_by: 'reviewed_by',
    reviewed_at: 'reviewed_at',
    review_notes: 'review_notes',
    created_at: 'created_at'
  };

  export type Job_applicationsScalarFieldEnum = (typeof Job_applicationsScalarFieldEnum)[keyof typeof Job_applicationsScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    id: 'id',
    package_id: 'package_id',
    patient_id: 'patient_id',
    company_id: 'company_id',
    guardian_id: 'guardian_id',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    total_price: 'total_price',
    commission_amount: 'commission_amount',
    payout_amount: 'payout_amount',
    special_instructions: 'special_instructions',
    completion_notes: 'completion_notes',
    cancelled_reason: 'cancelled_reason',
    cancelled_at: 'cancelled_at',
    cancelled_by: 'cancelled_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const Marketplace_jobsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    title: 'title',
    description: 'description',
    location: 'location',
    required_skills: 'required_skills',
    start_date: 'start_date',
    duration_days: 'duration_days',
    hours_per_day: 'hours_per_day',
    offered_rate: 'offered_rate',
    status: 'status',
    applications_count: 'applications_count',
    filled_by: 'filled_by',
    filled_at: 'filled_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Marketplace_jobsScalarFieldEnum = (typeof Marketplace_jobsScalarFieldEnum)[keyof typeof Marketplace_jobsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    channel: 'channel',
    title: 'title',
    body: 'body',
    data: 'data',
    status: 'status',
    sent_at: 'sent_at',
    delivered_at: 'delivered_at',
    read_at: 'read_at',
    error_message: 'error_message',
    createdAt: 'createdAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const PackagesScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    name: 'name',
    description: 'description',
    category: 'category',
    price: 'price',
    duration_days: 'duration_days',
    hours_per_day: 'hours_per_day',
    inclusions: 'inclusions',
    exclusions: 'exclusions',
    caregiver_count: 'caregiver_count',
    is_active: 'is_active',
    min_advance_days: 'min_advance_days',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PackagesScalarFieldEnum = (typeof PackagesScalarFieldEnum)[keyof typeof PackagesScalarFieldEnum]


  export const PatientsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    guardian_id: 'guardian_id',
    name: 'name',
    date_of_birth: 'date_of_birth',
    gender: 'gender',
    blood_group: 'blood_group',
    address: 'address',
    emergency_contact_name: 'emergency_contact_name',
    emergency_contact_phone: 'emergency_contact_phone',
    primaryConditions: 'primaryConditions',
    allergies: 'allergies',
    mobility_level: 'mobility_level',
    cognitive_status: 'cognitive_status',
    photoUrl: 'photoUrl',
    consent_data_sharing: 'consent_data_sharing',
    consent_marketing: 'consent_marketing',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientsScalarFieldEnum = (typeof PatientsScalarFieldEnum)[keyof typeof PatientsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    job_id: 'job_id',
    payer_id: 'payer_id',
    amount: 'amount',
    method: 'method',
    transaction_id: 'transaction_id',
    status: 'status',
    invoice_number: 'invoice_number',
    invoice_url: 'invoice_url',
    receipt_url: 'receipt_url',
    paid_at: 'paid_at',
    refund_amount: 'refund_amount',
    refund_reason: 'refund_reason',
    gatewayResponse: 'gatewayResponse',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const Scheduled_tasksScalarFieldEnum: {
    id: 'id',
    task_type: 'task_type',
    job_id: 'job_id',
    execute_at: 'execute_at',
    payload: 'payload',
    createdAt: 'createdAt',
    executedAt: 'executedAt',
    status: 'status'
  };

  export type Scheduled_tasksScalarFieldEnum = (typeof Scheduled_tasksScalarFieldEnum)[keyof typeof Scheduled_tasksScalarFieldEnum]


  export const Service_zonesScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    zone_name: 'zone_name',
    region_code: 'region_code',
    boundary_geojson: 'boundary_geojson',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Service_zonesScalarFieldEnum = (typeof Service_zonesScalarFieldEnum)[keyof typeof Service_zonesScalarFieldEnum]


  export const User_devicesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    device_id: 'device_id',
    fcm_token: 'fcm_token',
    platform: 'platform',
    app_version: 'app_version',
    is_active: 'is_active',
    last_seen_at: 'last_seen_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type User_devicesScalarFieldEnum = (typeof User_devicesScalarFieldEnum)[keyof typeof User_devicesScalarFieldEnum]


  export const Verification_codesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    type: 'type',
    expiresAt: 'expiresAt',
    isUsed: 'isUsed',
    usedAt: 'usedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Verification_codesScalarFieldEnum = (typeof Verification_codesScalarFieldEnum)[keyof typeof Verification_codesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    role: 'role',
    phone: 'phone',
    email: 'email',
    password_hash: 'password_hash',
    name: 'name',
    language: 'language',
    kyc_status: 'kyc_status',
    kyc_document_url: 'kyc_document_url',
    mfa_enabled: 'mfa_enabled',
    mfa_secret: 'mfa_secret',
    last_login_at: 'last_login_at',
    is_active: 'is_active',
    deleted_at: 'deleted_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    company_id: 'company_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AssignmentRole'
   */
  export type EnumAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentRole'>
    


  /**
   * Reference to a field of type 'AssignmentRole[]'
   */
  export type ListEnumAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AssignmentStatus'
   */
  export type EnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus'>
    


  /**
   * Reference to a field of type 'AssignmentStatus[]'
   */
  export type ListEnumAssignmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CareLogType'
   */
  export type EnumCareLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareLogType'>
    


  /**
   * Reference to a field of type 'CareLogType[]'
   */
  export type ListEnumCareLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CareLogType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BackgroundCheckStatus'
   */
  export type EnumBackgroundCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackgroundCheckStatus'>
    


  /**
   * Reference to a field of type 'BackgroundCheckStatus[]'
   */
  export type ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackgroundCheckStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutMethod'
   */
  export type EnumPayoutMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutMethod'>
    


  /**
   * Reference to a field of type 'PayoutMethod[]'
   */
  export type ListEnumPayoutMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutMethod[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'DisputeType'
   */
  export type EnumDisputeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeType'>
    


  /**
   * Reference to a field of type 'DisputeType[]'
   */
  export type ListEnumDisputeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeType[]'>
    


  /**
   * Reference to a field of type 'DisputeStatus'
   */
  export type EnumDisputeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeStatus'>
    


  /**
   * Reference to a field of type 'DisputeStatus[]'
   */
  export type ListEnumDisputeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'HealthRecordType'
   */
  export type EnumHealthRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthRecordType'>
    


  /**
   * Reference to a field of type 'HealthRecordType[]'
   */
  export type ListEnumHealthRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthRecordType[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'PackageCategory'
   */
  export type EnumPackageCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageCategory'>
    


  /**
   * Reference to a field of type 'PackageCategory[]'
   */
  export type ListEnumPackageCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackageCategory[]'>
    


  /**
   * Reference to a field of type 'MobilityLevel'
   */
  export type EnumMobilityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MobilityLevel'>
    


  /**
   * Reference to a field of type 'MobilityLevel[]'
   */
  export type ListEnumMobilityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MobilityLevel[]'>
    


  /**
   * Reference to a field of type 'CognitiveStatus'
   */
  export type EnumCognitiveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CognitiveStatus'>
    


  /**
   * Reference to a field of type 'CognitiveStatus[]'
   */
  export type ListEnumCognitiveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CognitiveStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type assignmentsWhereInput = {
    AND?: assignmentsWhereInput | assignmentsWhereInput[]
    OR?: assignmentsWhereInput[]
    NOT?: assignmentsWhereInput | assignmentsWhereInput[]
    id?: StringFilter<"assignments"> | string
    job_id?: StringFilter<"assignments"> | string
    caregiver_id?: StringFilter<"assignments"> | string
    role?: EnumAssignmentRoleFilter<"assignments"> | $Enums.AssignmentRole
    shift_start_time?: StringFilter<"assignments"> | string
    shift_end_time?: StringFilter<"assignments"> | string
    days_of_week?: JsonFilter<"assignments">
    status?: EnumAssignmentStatusFilter<"assignments"> | $Enums.AssignmentStatus
    replaced_by?: StringNullableFilter<"assignments"> | string | null
    replacement_reason?: StringNullableFilter<"assignments"> | string | null
    created_at?: DateTimeFilter<"assignments"> | Date | string
    updated_at?: DateTimeFilter<"assignments"> | Date | string
    caregivers_assignments_replaced_byTocaregivers?: XOR<CaregiversNullableScalarRelationFilter, caregiversWhereInput> | null
    caregivers_assignments_caregiver_idTocaregivers?: XOR<CaregiversScalarRelationFilter, caregiversWhereInput>
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    care_logs?: Care_logsListRelationFilter
  }

  export type assignmentsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
    shift_start_time?: SortOrder
    shift_end_time?: SortOrder
    days_of_week?: SortOrder
    status?: SortOrder
    replaced_by?: SortOrderInput | SortOrder
    replacement_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    caregivers_assignments_replaced_byTocaregivers?: caregiversOrderByWithRelationInput
    caregivers_assignments_caregiver_idTocaregivers?: caregiversOrderByWithRelationInput
    jobs?: jobsOrderByWithRelationInput
    care_logs?: care_logsOrderByRelationAggregateInput
  }

  export type assignmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    job_id_caregiver_id_role?: assignmentsJob_idCaregiver_idRoleCompoundUniqueInput
    AND?: assignmentsWhereInput | assignmentsWhereInput[]
    OR?: assignmentsWhereInput[]
    NOT?: assignmentsWhereInput | assignmentsWhereInput[]
    job_id?: StringFilter<"assignments"> | string
    caregiver_id?: StringFilter<"assignments"> | string
    role?: EnumAssignmentRoleFilter<"assignments"> | $Enums.AssignmentRole
    shift_start_time?: StringFilter<"assignments"> | string
    shift_end_time?: StringFilter<"assignments"> | string
    days_of_week?: JsonFilter<"assignments">
    status?: EnumAssignmentStatusFilter<"assignments"> | $Enums.AssignmentStatus
    replaced_by?: StringNullableFilter<"assignments"> | string | null
    replacement_reason?: StringNullableFilter<"assignments"> | string | null
    created_at?: DateTimeFilter<"assignments"> | Date | string
    updated_at?: DateTimeFilter<"assignments"> | Date | string
    caregivers_assignments_replaced_byTocaregivers?: XOR<CaregiversNullableScalarRelationFilter, caregiversWhereInput> | null
    caregivers_assignments_caregiver_idTocaregivers?: XOR<CaregiversScalarRelationFilter, caregiversWhereInput>
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    care_logs?: Care_logsListRelationFilter
  }, "id" | "job_id_caregiver_id_role">

  export type assignmentsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
    shift_start_time?: SortOrder
    shift_end_time?: SortOrder
    days_of_week?: SortOrder
    status?: SortOrder
    replaced_by?: SortOrderInput | SortOrder
    replacement_reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: assignmentsCountOrderByAggregateInput
    _max?: assignmentsMaxOrderByAggregateInput
    _min?: assignmentsMinOrderByAggregateInput
  }

  export type assignmentsScalarWhereWithAggregatesInput = {
    AND?: assignmentsScalarWhereWithAggregatesInput | assignmentsScalarWhereWithAggregatesInput[]
    OR?: assignmentsScalarWhereWithAggregatesInput[]
    NOT?: assignmentsScalarWhereWithAggregatesInput | assignmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"assignments"> | string
    job_id?: StringWithAggregatesFilter<"assignments"> | string
    caregiver_id?: StringWithAggregatesFilter<"assignments"> | string
    role?: EnumAssignmentRoleWithAggregatesFilter<"assignments"> | $Enums.AssignmentRole
    shift_start_time?: StringWithAggregatesFilter<"assignments"> | string
    shift_end_time?: StringWithAggregatesFilter<"assignments"> | string
    days_of_week?: JsonWithAggregatesFilter<"assignments">
    status?: EnumAssignmentStatusWithAggregatesFilter<"assignments"> | $Enums.AssignmentStatus
    replaced_by?: StringNullableWithAggregatesFilter<"assignments"> | string | null
    replacement_reason?: StringNullableWithAggregatesFilter<"assignments"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"assignments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"assignments"> | Date | string
  }

  export type audit_logsWhereInput = {
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    id?: StringFilter<"audit_logs"> | string
    actor_id?: StringNullableFilter<"audit_logs"> | string | null
    actor_role?: StringNullableFilter<"audit_logs"> | string | null
    action_type?: StringFilter<"audit_logs"> | string
    entity_type?: StringFilter<"audit_logs"> | string
    entity_id?: StringFilter<"audit_logs"> | string
    changes?: JsonNullableFilter<"audit_logs">
    ip_address?: StringNullableFilter<"audit_logs"> | string | null
    user_agent?: StringNullableFilter<"audit_logs"> | string | null
    timestamp?: DateTimeFilter<"audit_logs"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type audit_logsOrderByWithRelationInput = {
    id?: SortOrder
    actor_id?: SortOrderInput | SortOrder
    actor_role?: SortOrderInput | SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type audit_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: audit_logsWhereInput | audit_logsWhereInput[]
    OR?: audit_logsWhereInput[]
    NOT?: audit_logsWhereInput | audit_logsWhereInput[]
    actor_id?: StringNullableFilter<"audit_logs"> | string | null
    actor_role?: StringNullableFilter<"audit_logs"> | string | null
    action_type?: StringFilter<"audit_logs"> | string
    entity_type?: StringFilter<"audit_logs"> | string
    entity_id?: StringFilter<"audit_logs"> | string
    changes?: JsonNullableFilter<"audit_logs">
    ip_address?: StringNullableFilter<"audit_logs"> | string | null
    user_agent?: StringNullableFilter<"audit_logs"> | string | null
    timestamp?: DateTimeFilter<"audit_logs"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type audit_logsOrderByWithAggregationInput = {
    id?: SortOrder
    actor_id?: SortOrderInput | SortOrder
    actor_role?: SortOrderInput | SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: audit_logsCountOrderByAggregateInput
    _max?: audit_logsMaxOrderByAggregateInput
    _min?: audit_logsMinOrderByAggregateInput
  }

  export type audit_logsScalarWhereWithAggregatesInput = {
    AND?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    OR?: audit_logsScalarWhereWithAggregatesInput[]
    NOT?: audit_logsScalarWhereWithAggregatesInput | audit_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"audit_logs"> | string
    actor_id?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    actor_role?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    action_type?: StringWithAggregatesFilter<"audit_logs"> | string
    entity_type?: StringWithAggregatesFilter<"audit_logs"> | string
    entity_id?: StringWithAggregatesFilter<"audit_logs"> | string
    changes?: JsonNullableWithAggregatesFilter<"audit_logs">
    ip_address?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"audit_logs"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"audit_logs"> | Date | string
  }

  export type care_logsWhereInput = {
    AND?: care_logsWhereInput | care_logsWhereInput[]
    OR?: care_logsWhereInput[]
    NOT?: care_logsWhereInput | care_logsWhereInput[]
    id?: StringFilter<"care_logs"> | string
    job_id?: StringFilter<"care_logs"> | string
    assignment_id?: StringNullableFilter<"care_logs"> | string | null
    caregiver_id?: StringFilter<"care_logs"> | string
    patient_id?: StringFilter<"care_logs"> | string
    log_type?: EnumCareLogTypeFilter<"care_logs"> | $Enums.CareLogType
    timestamp?: DateTimeFilter<"care_logs"> | Date | string
    location_lat?: DecimalNullableFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    data?: JsonFilter<"care_logs">
    notes?: StringNullableFilter<"care_logs"> | string | null
    photo_urls?: JsonNullableFilter<"care_logs">
    guardian_notified?: BoolFilter<"care_logs"> | boolean
    createdAt?: DateTimeFilter<"care_logs"> | Date | string
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
    caregivers?: XOR<CaregiversScalarRelationFilter, caregiversWhereInput>
    assignments?: XOR<AssignmentsNullableScalarRelationFilter, assignmentsWhereInput> | null
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }

  export type care_logsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    assignment_id?: SortOrderInput | SortOrder
    caregiver_id?: SortOrder
    patient_id?: SortOrder
    log_type?: SortOrder
    timestamp?: SortOrder
    location_lat?: SortOrderInput | SortOrder
    location_lng?: SortOrderInput | SortOrder
    data?: SortOrder
    notes?: SortOrderInput | SortOrder
    photo_urls?: SortOrderInput | SortOrder
    guardian_notified?: SortOrder
    createdAt?: SortOrder
    patients?: patientsOrderByWithRelationInput
    caregivers?: caregiversOrderByWithRelationInput
    assignments?: assignmentsOrderByWithRelationInput
    jobs?: jobsOrderByWithRelationInput
  }

  export type care_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: care_logsWhereInput | care_logsWhereInput[]
    OR?: care_logsWhereInput[]
    NOT?: care_logsWhereInput | care_logsWhereInput[]
    job_id?: StringFilter<"care_logs"> | string
    assignment_id?: StringNullableFilter<"care_logs"> | string | null
    caregiver_id?: StringFilter<"care_logs"> | string
    patient_id?: StringFilter<"care_logs"> | string
    log_type?: EnumCareLogTypeFilter<"care_logs"> | $Enums.CareLogType
    timestamp?: DateTimeFilter<"care_logs"> | Date | string
    location_lat?: DecimalNullableFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    data?: JsonFilter<"care_logs">
    notes?: StringNullableFilter<"care_logs"> | string | null
    photo_urls?: JsonNullableFilter<"care_logs">
    guardian_notified?: BoolFilter<"care_logs"> | boolean
    createdAt?: DateTimeFilter<"care_logs"> | Date | string
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
    caregivers?: XOR<CaregiversScalarRelationFilter, caregiversWhereInput>
    assignments?: XOR<AssignmentsNullableScalarRelationFilter, assignmentsWhereInput> | null
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }, "id">

  export type care_logsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    assignment_id?: SortOrderInput | SortOrder
    caregiver_id?: SortOrder
    patient_id?: SortOrder
    log_type?: SortOrder
    timestamp?: SortOrder
    location_lat?: SortOrderInput | SortOrder
    location_lng?: SortOrderInput | SortOrder
    data?: SortOrder
    notes?: SortOrderInput | SortOrder
    photo_urls?: SortOrderInput | SortOrder
    guardian_notified?: SortOrder
    createdAt?: SortOrder
    _count?: care_logsCountOrderByAggregateInput
    _avg?: care_logsAvgOrderByAggregateInput
    _max?: care_logsMaxOrderByAggregateInput
    _min?: care_logsMinOrderByAggregateInput
    _sum?: care_logsSumOrderByAggregateInput
  }

  export type care_logsScalarWhereWithAggregatesInput = {
    AND?: care_logsScalarWhereWithAggregatesInput | care_logsScalarWhereWithAggregatesInput[]
    OR?: care_logsScalarWhereWithAggregatesInput[]
    NOT?: care_logsScalarWhereWithAggregatesInput | care_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"care_logs"> | string
    job_id?: StringWithAggregatesFilter<"care_logs"> | string
    assignment_id?: StringNullableWithAggregatesFilter<"care_logs"> | string | null
    caregiver_id?: StringWithAggregatesFilter<"care_logs"> | string
    patient_id?: StringWithAggregatesFilter<"care_logs"> | string
    log_type?: EnumCareLogTypeWithAggregatesFilter<"care_logs"> | $Enums.CareLogType
    timestamp?: DateTimeWithAggregatesFilter<"care_logs"> | Date | string
    location_lat?: DecimalNullableWithAggregatesFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableWithAggregatesFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    data?: JsonWithAggregatesFilter<"care_logs">
    notes?: StringNullableWithAggregatesFilter<"care_logs"> | string | null
    photo_urls?: JsonNullableWithAggregatesFilter<"care_logs">
    guardian_notified?: BoolWithAggregatesFilter<"care_logs"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"care_logs"> | Date | string
  }

  export type caregiversWhereInput = {
    AND?: caregiversWhereInput | caregiversWhereInput[]
    OR?: caregiversWhereInput[]
    NOT?: caregiversWhereInput | caregiversWhereInput[]
    id?: StringFilter<"caregivers"> | string
    userId?: StringFilter<"caregivers"> | string
    company_id?: StringNullableFilter<"caregivers"> | string | null
    nid?: StringFilter<"caregivers"> | string
    nid_url?: StringFilter<"caregivers"> | string
    photo_url?: StringFilter<"caregivers"> | string
    date_of_birth?: DateTimeFilter<"caregivers"> | Date | string
    gender?: EnumGenderFilter<"caregivers"> | $Enums.Gender
    address?: StringFilter<"caregivers"> | string
    location_lat?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonFilter<"caregivers">
    certifications?: JsonNullableFilter<"caregivers">
    experience_years?: IntFilter<"caregivers"> | number
    languages?: JsonFilter<"caregivers">
    availabilityCalendar?: JsonNullableFilter<"caregivers">
    hourly_rate?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFilter<"caregivers"> | $Enums.BackgroundCheckStatus
    background_check_date?: DateTimeNullableFilter<"caregivers"> | Date | string | null
    rating_avg?: DecimalFilter<"caregivers"> | Decimal | DecimalJsLike | number | string
    rating_count?: IntFilter<"caregivers"> | number
    total_jobs_completed?: IntFilter<"caregivers"> | number
    is_available?: BoolFilter<"caregivers"> | boolean
    is_verified?: BoolFilter<"caregivers"> | boolean
    verification_notes?: StringNullableFilter<"caregivers"> | string | null
    deleted_at?: DateTimeNullableFilter<"caregivers"> | Date | string | null
    created_at?: DateTimeFilter<"caregivers"> | Date | string
    updated_at?: DateTimeFilter<"caregivers"> | Date | string
    assignments_assignments_replaced_byTocaregivers?: AssignmentsListRelationFilter
    assignments_assignments_caregiver_idTocaregivers?: AssignmentsListRelationFilter
    care_logs?: Care_logsListRelationFilter
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    job_applications?: Job_applicationsListRelationFilter
    marketplace_jobs?: Marketplace_jobsListRelationFilter
  }

  export type caregiversOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    company_id?: SortOrderInput | SortOrder
    nid?: SortOrder
    nid_url?: SortOrder
    photo_url?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    location_lat?: SortOrderInput | SortOrder
    location_lng?: SortOrderInput | SortOrder
    skills?: SortOrder
    certifications?: SortOrderInput | SortOrder
    experience_years?: SortOrder
    languages?: SortOrder
    availabilityCalendar?: SortOrderInput | SortOrder
    hourly_rate?: SortOrderInput | SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrderInput | SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    total_jobs_completed?: SortOrder
    is_available?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    assignments_assignments_replaced_byTocaregivers?: assignmentsOrderByRelationAggregateInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsOrderByRelationAggregateInput
    care_logs?: care_logsOrderByRelationAggregateInput
    companies?: companiesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    job_applications?: job_applicationsOrderByRelationAggregateInput
    marketplace_jobs?: marketplace_jobsOrderByRelationAggregateInput
  }

  export type caregiversWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    nid?: string
    AND?: caregiversWhereInput | caregiversWhereInput[]
    OR?: caregiversWhereInput[]
    NOT?: caregiversWhereInput | caregiversWhereInput[]
    company_id?: StringNullableFilter<"caregivers"> | string | null
    nid_url?: StringFilter<"caregivers"> | string
    photo_url?: StringFilter<"caregivers"> | string
    date_of_birth?: DateTimeFilter<"caregivers"> | Date | string
    gender?: EnumGenderFilter<"caregivers"> | $Enums.Gender
    address?: StringFilter<"caregivers"> | string
    location_lat?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonFilter<"caregivers">
    certifications?: JsonNullableFilter<"caregivers">
    experience_years?: IntFilter<"caregivers"> | number
    languages?: JsonFilter<"caregivers">
    availabilityCalendar?: JsonNullableFilter<"caregivers">
    hourly_rate?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFilter<"caregivers"> | $Enums.BackgroundCheckStatus
    background_check_date?: DateTimeNullableFilter<"caregivers"> | Date | string | null
    rating_avg?: DecimalFilter<"caregivers"> | Decimal | DecimalJsLike | number | string
    rating_count?: IntFilter<"caregivers"> | number
    total_jobs_completed?: IntFilter<"caregivers"> | number
    is_available?: BoolFilter<"caregivers"> | boolean
    is_verified?: BoolFilter<"caregivers"> | boolean
    verification_notes?: StringNullableFilter<"caregivers"> | string | null
    deleted_at?: DateTimeNullableFilter<"caregivers"> | Date | string | null
    created_at?: DateTimeFilter<"caregivers"> | Date | string
    updated_at?: DateTimeFilter<"caregivers"> | Date | string
    assignments_assignments_replaced_byTocaregivers?: AssignmentsListRelationFilter
    assignments_assignments_caregiver_idTocaregivers?: AssignmentsListRelationFilter
    care_logs?: Care_logsListRelationFilter
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    job_applications?: Job_applicationsListRelationFilter
    marketplace_jobs?: Marketplace_jobsListRelationFilter
  }, "id" | "userId" | "nid">

  export type caregiversOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    company_id?: SortOrderInput | SortOrder
    nid?: SortOrder
    nid_url?: SortOrder
    photo_url?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    location_lat?: SortOrderInput | SortOrder
    location_lng?: SortOrderInput | SortOrder
    skills?: SortOrder
    certifications?: SortOrderInput | SortOrder
    experience_years?: SortOrder
    languages?: SortOrder
    availabilityCalendar?: SortOrderInput | SortOrder
    hourly_rate?: SortOrderInput | SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrderInput | SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    total_jobs_completed?: SortOrder
    is_available?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: caregiversCountOrderByAggregateInput
    _avg?: caregiversAvgOrderByAggregateInput
    _max?: caregiversMaxOrderByAggregateInput
    _min?: caregiversMinOrderByAggregateInput
    _sum?: caregiversSumOrderByAggregateInput
  }

  export type caregiversScalarWhereWithAggregatesInput = {
    AND?: caregiversScalarWhereWithAggregatesInput | caregiversScalarWhereWithAggregatesInput[]
    OR?: caregiversScalarWhereWithAggregatesInput[]
    NOT?: caregiversScalarWhereWithAggregatesInput | caregiversScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"caregivers"> | string
    userId?: StringWithAggregatesFilter<"caregivers"> | string
    company_id?: StringNullableWithAggregatesFilter<"caregivers"> | string | null
    nid?: StringWithAggregatesFilter<"caregivers"> | string
    nid_url?: StringWithAggregatesFilter<"caregivers"> | string
    photo_url?: StringWithAggregatesFilter<"caregivers"> | string
    date_of_birth?: DateTimeWithAggregatesFilter<"caregivers"> | Date | string
    gender?: EnumGenderWithAggregatesFilter<"caregivers"> | $Enums.Gender
    address?: StringWithAggregatesFilter<"caregivers"> | string
    location_lat?: DecimalNullableWithAggregatesFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableWithAggregatesFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonWithAggregatesFilter<"caregivers">
    certifications?: JsonNullableWithAggregatesFilter<"caregivers">
    experience_years?: IntWithAggregatesFilter<"caregivers"> | number
    languages?: JsonWithAggregatesFilter<"caregivers">
    availabilityCalendar?: JsonNullableWithAggregatesFilter<"caregivers">
    hourly_rate?: DecimalNullableWithAggregatesFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusWithAggregatesFilter<"caregivers"> | $Enums.BackgroundCheckStatus
    background_check_date?: DateTimeNullableWithAggregatesFilter<"caregivers"> | Date | string | null
    rating_avg?: DecimalWithAggregatesFilter<"caregivers"> | Decimal | DecimalJsLike | number | string
    rating_count?: IntWithAggregatesFilter<"caregivers"> | number
    total_jobs_completed?: IntWithAggregatesFilter<"caregivers"> | number
    is_available?: BoolWithAggregatesFilter<"caregivers"> | boolean
    is_verified?: BoolWithAggregatesFilter<"caregivers"> | boolean
    verification_notes?: StringNullableWithAggregatesFilter<"caregivers"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"caregivers"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"caregivers"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"caregivers"> | Date | string
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: StringFilter<"companies"> | string
    userId?: StringFilter<"companies"> | string
    company_name?: StringFilter<"companies"> | string
    trade_license?: StringFilter<"companies"> | string
    trade_license_url?: StringNullableFilter<"companies"> | string | null
    tin?: StringNullableFilter<"companies"> | string | null
    contact_person?: StringFilter<"companies"> | string
    contact_phone?: StringFilter<"companies"> | string
    contact_email?: StringNullableFilter<"companies"> | string | null
    address?: StringFilter<"companies"> | string
    logo_url?: StringNullableFilter<"companies"> | string | null
    description?: StringNullableFilter<"companies"> | string | null
    specializations?: JsonNullableFilter<"companies">
    payout_method?: EnumPayoutMethodFilter<"companies"> | $Enums.PayoutMethod
    payout_account?: StringFilter<"companies"> | string
    commission_rate?: DecimalFilter<"companies"> | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFilter<"companies"> | $Enums.SubscriptionTier
    subscription_expires_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    rating_avg?: DecimalFilter<"companies"> | Decimal | DecimalJsLike | number | string
    rating_count?: IntFilter<"companies"> | number
    is_verified?: BoolFilter<"companies"> | boolean
    verification_notes?: StringNullableFilter<"companies"> | string | null
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    caregivers?: CaregiversListRelationFilter
    jobs?: JobsListRelationFilter
    marketplace_jobs?: Marketplace_jobsListRelationFilter
    packages?: PackagesListRelationFilter
    service_zones?: Service_zonesListRelationFilter
    users?: UsersListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    company_name?: SortOrder
    trade_license?: SortOrder
    trade_license_url?: SortOrderInput | SortOrder
    tin?: SortOrderInput | SortOrder
    contact_person?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrderInput | SortOrder
    address?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    specializations?: SortOrderInput | SortOrder
    payout_method?: SortOrder
    payout_account?: SortOrder
    commission_rate?: SortOrder
    subscription_tier?: SortOrder
    subscription_expires_at?: SortOrderInput | SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    caregivers?: caregiversOrderByRelationAggregateInput
    jobs?: jobsOrderByRelationAggregateInput
    marketplace_jobs?: marketplace_jobsOrderByRelationAggregateInput
    packages?: packagesOrderByRelationAggregateInput
    service_zones?: service_zonesOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    company_name?: StringFilter<"companies"> | string
    trade_license?: StringFilter<"companies"> | string
    trade_license_url?: StringNullableFilter<"companies"> | string | null
    tin?: StringNullableFilter<"companies"> | string | null
    contact_person?: StringFilter<"companies"> | string
    contact_phone?: StringFilter<"companies"> | string
    contact_email?: StringNullableFilter<"companies"> | string | null
    address?: StringFilter<"companies"> | string
    logo_url?: StringNullableFilter<"companies"> | string | null
    description?: StringNullableFilter<"companies"> | string | null
    specializations?: JsonNullableFilter<"companies">
    payout_method?: EnumPayoutMethodFilter<"companies"> | $Enums.PayoutMethod
    payout_account?: StringFilter<"companies"> | string
    commission_rate?: DecimalFilter<"companies"> | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFilter<"companies"> | $Enums.SubscriptionTier
    subscription_expires_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    rating_avg?: DecimalFilter<"companies"> | Decimal | DecimalJsLike | number | string
    rating_count?: IntFilter<"companies"> | number
    is_verified?: BoolFilter<"companies"> | boolean
    verification_notes?: StringNullableFilter<"companies"> | string | null
    deleted_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    caregivers?: CaregiversListRelationFilter
    jobs?: JobsListRelationFilter
    marketplace_jobs?: Marketplace_jobsListRelationFilter
    packages?: PackagesListRelationFilter
    service_zones?: Service_zonesListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "userId">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    company_name?: SortOrder
    trade_license?: SortOrder
    trade_license_url?: SortOrderInput | SortOrder
    tin?: SortOrderInput | SortOrder
    contact_person?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrderInput | SortOrder
    address?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    specializations?: SortOrderInput | SortOrder
    payout_method?: SortOrder
    payout_account?: SortOrder
    commission_rate?: SortOrder
    subscription_tier?: SortOrder
    subscription_expires_at?: SortOrderInput | SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"companies"> | string
    userId?: StringWithAggregatesFilter<"companies"> | string
    company_name?: StringWithAggregatesFilter<"companies"> | string
    trade_license?: StringWithAggregatesFilter<"companies"> | string
    trade_license_url?: StringNullableWithAggregatesFilter<"companies"> | string | null
    tin?: StringNullableWithAggregatesFilter<"companies"> | string | null
    contact_person?: StringWithAggregatesFilter<"companies"> | string
    contact_phone?: StringWithAggregatesFilter<"companies"> | string
    contact_email?: StringNullableWithAggregatesFilter<"companies"> | string | null
    address?: StringWithAggregatesFilter<"companies"> | string
    logo_url?: StringNullableWithAggregatesFilter<"companies"> | string | null
    description?: StringNullableWithAggregatesFilter<"companies"> | string | null
    specializations?: JsonNullableWithAggregatesFilter<"companies">
    payout_method?: EnumPayoutMethodWithAggregatesFilter<"companies"> | $Enums.PayoutMethod
    payout_account?: StringWithAggregatesFilter<"companies"> | string
    commission_rate?: DecimalWithAggregatesFilter<"companies"> | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierWithAggregatesFilter<"companies"> | $Enums.SubscriptionTier
    subscription_expires_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    rating_avg?: DecimalWithAggregatesFilter<"companies"> | Decimal | DecimalJsLike | number | string
    rating_count?: IntWithAggregatesFilter<"companies"> | number
    is_verified?: BoolWithAggregatesFilter<"companies"> | boolean
    verification_notes?: StringNullableWithAggregatesFilter<"companies"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
  }

  export type disputesWhereInput = {
    AND?: disputesWhereInput | disputesWhereInput[]
    OR?: disputesWhereInput[]
    NOT?: disputesWhereInput | disputesWhereInput[]
    id?: StringFilter<"disputes"> | string
    job_id?: StringFilter<"disputes"> | string
    raised_by?: StringFilter<"disputes"> | string
    against?: StringFilter<"disputes"> | string
    dispute_type?: EnumDisputeTypeFilter<"disputes"> | $Enums.DisputeType
    description?: StringFilter<"disputes"> | string
    evidence_urls?: JsonNullableFilter<"disputes">
    status?: EnumDisputeStatusFilter<"disputes"> | $Enums.DisputeStatus
    assigned_moderator?: StringNullableFilter<"disputes"> | string | null
    resolution?: StringNullableFilter<"disputes"> | string | null
    resolution_action?: StringNullableFilter<"disputes"> | string | null
    resolved_at?: DateTimeNullableFilter<"disputes"> | Date | string | null
    createdAt?: DateTimeFilter<"disputes"> | Date | string
    updatedAt?: DateTimeFilter<"disputes"> | Date | string
    users_disputes_againstTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_disputes_raised_byTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }

  export type disputesOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    raised_by?: SortOrder
    against?: SortOrder
    dispute_type?: SortOrder
    description?: SortOrder
    evidence_urls?: SortOrderInput | SortOrder
    status?: SortOrder
    assigned_moderator?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolution_action?: SortOrderInput | SortOrder
    resolved_at?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_disputes_againstTousers?: usersOrderByWithRelationInput
    users_disputes_raised_byTousers?: usersOrderByWithRelationInput
    jobs?: jobsOrderByWithRelationInput
  }

  export type disputesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: disputesWhereInput | disputesWhereInput[]
    OR?: disputesWhereInput[]
    NOT?: disputesWhereInput | disputesWhereInput[]
    job_id?: StringFilter<"disputes"> | string
    raised_by?: StringFilter<"disputes"> | string
    against?: StringFilter<"disputes"> | string
    dispute_type?: EnumDisputeTypeFilter<"disputes"> | $Enums.DisputeType
    description?: StringFilter<"disputes"> | string
    evidence_urls?: JsonNullableFilter<"disputes">
    status?: EnumDisputeStatusFilter<"disputes"> | $Enums.DisputeStatus
    assigned_moderator?: StringNullableFilter<"disputes"> | string | null
    resolution?: StringNullableFilter<"disputes"> | string | null
    resolution_action?: StringNullableFilter<"disputes"> | string | null
    resolved_at?: DateTimeNullableFilter<"disputes"> | Date | string | null
    createdAt?: DateTimeFilter<"disputes"> | Date | string
    updatedAt?: DateTimeFilter<"disputes"> | Date | string
    users_disputes_againstTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_disputes_raised_byTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }, "id">

  export type disputesOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    raised_by?: SortOrder
    against?: SortOrder
    dispute_type?: SortOrder
    description?: SortOrder
    evidence_urls?: SortOrderInput | SortOrder
    status?: SortOrder
    assigned_moderator?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolution_action?: SortOrderInput | SortOrder
    resolved_at?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: disputesCountOrderByAggregateInput
    _max?: disputesMaxOrderByAggregateInput
    _min?: disputesMinOrderByAggregateInput
  }

  export type disputesScalarWhereWithAggregatesInput = {
    AND?: disputesScalarWhereWithAggregatesInput | disputesScalarWhereWithAggregatesInput[]
    OR?: disputesScalarWhereWithAggregatesInput[]
    NOT?: disputesScalarWhereWithAggregatesInput | disputesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"disputes"> | string
    job_id?: StringWithAggregatesFilter<"disputes"> | string
    raised_by?: StringWithAggregatesFilter<"disputes"> | string
    against?: StringWithAggregatesFilter<"disputes"> | string
    dispute_type?: EnumDisputeTypeWithAggregatesFilter<"disputes"> | $Enums.DisputeType
    description?: StringWithAggregatesFilter<"disputes"> | string
    evidence_urls?: JsonNullableWithAggregatesFilter<"disputes">
    status?: EnumDisputeStatusWithAggregatesFilter<"disputes"> | $Enums.DisputeStatus
    assigned_moderator?: StringNullableWithAggregatesFilter<"disputes"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"disputes"> | string | null
    resolution_action?: StringNullableWithAggregatesFilter<"disputes"> | string | null
    resolved_at?: DateTimeNullableWithAggregatesFilter<"disputes"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"disputes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"disputes"> | Date | string
  }

  export type escrowsWhereInput = {
    AND?: escrowsWhereInput | escrowsWhereInput[]
    OR?: escrowsWhereInput[]
    NOT?: escrowsWhereInput | escrowsWhereInput[]
    id?: StringFilter<"escrows"> | string
    payment_id?: StringFilter<"escrows"> | string
    amount?: DecimalFilter<"escrows"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalFilter<"escrows"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"escrows"> | string
    released_at?: DateTimeNullableFilter<"escrows"> | Date | string | null
    created_at?: DateTimeFilter<"escrows"> | Date | string
    updated_at?: DateTimeFilter<"escrows"> | Date | string
    payments?: XOR<PaymentsScalarRelationFilter, paymentsWhereInput>
  }

  export type escrowsOrderByWithRelationInput = {
    id?: SortOrder
    payment_id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    released_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    payments?: paymentsOrderByWithRelationInput
  }

  export type escrowsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    payment_id?: string
    AND?: escrowsWhereInput | escrowsWhereInput[]
    OR?: escrowsWhereInput[]
    NOT?: escrowsWhereInput | escrowsWhereInput[]
    amount?: DecimalFilter<"escrows"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalFilter<"escrows"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"escrows"> | string
    released_at?: DateTimeNullableFilter<"escrows"> | Date | string | null
    created_at?: DateTimeFilter<"escrows"> | Date | string
    updated_at?: DateTimeFilter<"escrows"> | Date | string
    payments?: XOR<PaymentsScalarRelationFilter, paymentsWhereInput>
  }, "id" | "payment_id">

  export type escrowsOrderByWithAggregationInput = {
    id?: SortOrder
    payment_id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    released_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: escrowsCountOrderByAggregateInput
    _avg?: escrowsAvgOrderByAggregateInput
    _max?: escrowsMaxOrderByAggregateInput
    _min?: escrowsMinOrderByAggregateInput
    _sum?: escrowsSumOrderByAggregateInput
  }

  export type escrowsScalarWhereWithAggregatesInput = {
    AND?: escrowsScalarWhereWithAggregatesInput | escrowsScalarWhereWithAggregatesInput[]
    OR?: escrowsScalarWhereWithAggregatesInput[]
    NOT?: escrowsScalarWhereWithAggregatesInput | escrowsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"escrows"> | string
    payment_id?: StringWithAggregatesFilter<"escrows"> | string
    amount?: DecimalWithAggregatesFilter<"escrows"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalWithAggregatesFilter<"escrows"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"escrows"> | string
    released_at?: DateTimeNullableWithAggregatesFilter<"escrows"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"escrows"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"escrows"> | Date | string
  }

  export type escrow_recordsWhereInput = {
    AND?: escrow_recordsWhereInput | escrow_recordsWhereInput[]
    OR?: escrow_recordsWhereInput[]
    NOT?: escrow_recordsWhereInput | escrow_recordsWhereInput[]
    id?: StringFilter<"escrow_records"> | string
    external_ref?: StringNullableFilter<"escrow_records"> | string | null
    amount?: DecimalFilter<"escrow_records"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"escrow_records"> | string
    status?: StringFilter<"escrow_records"> | string
    released_at?: DateTimeNullableFilter<"escrow_records"> | Date | string | null
    created_at?: DateTimeFilter<"escrow_records"> | Date | string
    updated_at?: DateTimeFilter<"escrow_records"> | Date | string
    ledger_entries?: Escrow_ledgerListRelationFilter
  }

  export type escrow_recordsOrderByWithRelationInput = {
    id?: SortOrder
    external_ref?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    released_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    ledger_entries?: escrow_ledgerOrderByRelationAggregateInput
  }

  export type escrow_recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: escrow_recordsWhereInput | escrow_recordsWhereInput[]
    OR?: escrow_recordsWhereInput[]
    NOT?: escrow_recordsWhereInput | escrow_recordsWhereInput[]
    external_ref?: StringNullableFilter<"escrow_records"> | string | null
    amount?: DecimalFilter<"escrow_records"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"escrow_records"> | string
    status?: StringFilter<"escrow_records"> | string
    released_at?: DateTimeNullableFilter<"escrow_records"> | Date | string | null
    created_at?: DateTimeFilter<"escrow_records"> | Date | string
    updated_at?: DateTimeFilter<"escrow_records"> | Date | string
    ledger_entries?: Escrow_ledgerListRelationFilter
  }, "id">

  export type escrow_recordsOrderByWithAggregationInput = {
    id?: SortOrder
    external_ref?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    released_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: escrow_recordsCountOrderByAggregateInput
    _avg?: escrow_recordsAvgOrderByAggregateInput
    _max?: escrow_recordsMaxOrderByAggregateInput
    _min?: escrow_recordsMinOrderByAggregateInput
    _sum?: escrow_recordsSumOrderByAggregateInput
  }

  export type escrow_recordsScalarWhereWithAggregatesInput = {
    AND?: escrow_recordsScalarWhereWithAggregatesInput | escrow_recordsScalarWhereWithAggregatesInput[]
    OR?: escrow_recordsScalarWhereWithAggregatesInput[]
    NOT?: escrow_recordsScalarWhereWithAggregatesInput | escrow_recordsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"escrow_records"> | string
    external_ref?: StringNullableWithAggregatesFilter<"escrow_records"> | string | null
    amount?: DecimalWithAggregatesFilter<"escrow_records"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"escrow_records"> | string
    status?: StringWithAggregatesFilter<"escrow_records"> | string
    released_at?: DateTimeNullableWithAggregatesFilter<"escrow_records"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"escrow_records"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"escrow_records"> | Date | string
  }

  export type escrow_ledgerWhereInput = {
    AND?: escrow_ledgerWhereInput | escrow_ledgerWhereInput[]
    OR?: escrow_ledgerWhereInput[]
    NOT?: escrow_ledgerWhereInput | escrow_ledgerWhereInput[]
    id?: StringFilter<"escrow_ledger"> | string
    escrow_id?: StringFilter<"escrow_ledger"> | string
    action?: StringFilter<"escrow_ledger"> | string
    amount?: DecimalFilter<"escrow_ledger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"escrow_ledger"> | string | null
    created_at?: DateTimeFilter<"escrow_ledger"> | Date | string
    updated_at?: DateTimeFilter<"escrow_ledger"> | Date | string
    escrow_records?: XOR<Escrow_recordsScalarRelationFilter, escrow_recordsWhereInput>
  }

  export type escrow_ledgerOrderByWithRelationInput = {
    id?: SortOrder
    escrow_id?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    escrow_records?: escrow_recordsOrderByWithRelationInput
  }

  export type escrow_ledgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: escrow_ledgerWhereInput | escrow_ledgerWhereInput[]
    OR?: escrow_ledgerWhereInput[]
    NOT?: escrow_ledgerWhereInput | escrow_ledgerWhereInput[]
    escrow_id?: StringFilter<"escrow_ledger"> | string
    action?: StringFilter<"escrow_ledger"> | string
    amount?: DecimalFilter<"escrow_ledger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"escrow_ledger"> | string | null
    created_at?: DateTimeFilter<"escrow_ledger"> | Date | string
    updated_at?: DateTimeFilter<"escrow_ledger"> | Date | string
    escrow_records?: XOR<Escrow_recordsScalarRelationFilter, escrow_recordsWhereInput>
  }, "id">

  export type escrow_ledgerOrderByWithAggregationInput = {
    id?: SortOrder
    escrow_id?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: escrow_ledgerCountOrderByAggregateInput
    _avg?: escrow_ledgerAvgOrderByAggregateInput
    _max?: escrow_ledgerMaxOrderByAggregateInput
    _min?: escrow_ledgerMinOrderByAggregateInput
    _sum?: escrow_ledgerSumOrderByAggregateInput
  }

  export type escrow_ledgerScalarWhereWithAggregatesInput = {
    AND?: escrow_ledgerScalarWhereWithAggregatesInput | escrow_ledgerScalarWhereWithAggregatesInput[]
    OR?: escrow_ledgerScalarWhereWithAggregatesInput[]
    NOT?: escrow_ledgerScalarWhereWithAggregatesInput | escrow_ledgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"escrow_ledger"> | string
    escrow_id?: StringWithAggregatesFilter<"escrow_ledger"> | string
    action?: StringWithAggregatesFilter<"escrow_ledger"> | string
    amount?: DecimalWithAggregatesFilter<"escrow_ledger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableWithAggregatesFilter<"escrow_ledger"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"escrow_ledger"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"escrow_ledger"> | Date | string
  }

  export type provider_transactionsWhereInput = {
    AND?: provider_transactionsWhereInput | provider_transactionsWhereInput[]
    OR?: provider_transactionsWhereInput[]
    NOT?: provider_transactionsWhereInput | provider_transactionsWhereInput[]
    id?: StringFilter<"provider_transactions"> | string
    provider?: StringFilter<"provider_transactions"> | string
    provider_tx_id?: StringFilter<"provider_transactions"> | string
    status?: StringFilter<"provider_transactions"> | string
    amount?: DecimalFilter<"provider_transactions"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"provider_transactions"> | string
    payload?: JsonNullableFilter<"provider_transactions">
    escrow_id?: StringNullableFilter<"provider_transactions"> | string | null
    created_at?: DateTimeFilter<"provider_transactions"> | Date | string
    updated_at?: DateTimeFilter<"provider_transactions"> | Date | string
    logs?: Transaction_logsListRelationFilter
  }

  export type provider_transactionsOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    provider_tx_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    payload?: SortOrderInput | SortOrder
    escrow_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    logs?: transaction_logsOrderByRelationAggregateInput
  }

  export type provider_transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_tx_id?: string
    AND?: provider_transactionsWhereInput | provider_transactionsWhereInput[]
    OR?: provider_transactionsWhereInput[]
    NOT?: provider_transactionsWhereInput | provider_transactionsWhereInput[]
    provider?: StringFilter<"provider_transactions"> | string
    status?: StringFilter<"provider_transactions"> | string
    amount?: DecimalFilter<"provider_transactions"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"provider_transactions"> | string
    payload?: JsonNullableFilter<"provider_transactions">
    escrow_id?: StringNullableFilter<"provider_transactions"> | string | null
    created_at?: DateTimeFilter<"provider_transactions"> | Date | string
    updated_at?: DateTimeFilter<"provider_transactions"> | Date | string
    logs?: Transaction_logsListRelationFilter
  }, "id" | "provider_tx_id">

  export type provider_transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    provider_tx_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    payload?: SortOrderInput | SortOrder
    escrow_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: provider_transactionsCountOrderByAggregateInput
    _avg?: provider_transactionsAvgOrderByAggregateInput
    _max?: provider_transactionsMaxOrderByAggregateInput
    _min?: provider_transactionsMinOrderByAggregateInput
    _sum?: provider_transactionsSumOrderByAggregateInput
  }

  export type provider_transactionsScalarWhereWithAggregatesInput = {
    AND?: provider_transactionsScalarWhereWithAggregatesInput | provider_transactionsScalarWhereWithAggregatesInput[]
    OR?: provider_transactionsScalarWhereWithAggregatesInput[]
    NOT?: provider_transactionsScalarWhereWithAggregatesInput | provider_transactionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"provider_transactions"> | string
    provider?: StringWithAggregatesFilter<"provider_transactions"> | string
    provider_tx_id?: StringWithAggregatesFilter<"provider_transactions"> | string
    status?: StringWithAggregatesFilter<"provider_transactions"> | string
    amount?: DecimalWithAggregatesFilter<"provider_transactions"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"provider_transactions"> | string
    payload?: JsonNullableWithAggregatesFilter<"provider_transactions">
    escrow_id?: StringNullableWithAggregatesFilter<"provider_transactions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"provider_transactions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"provider_transactions"> | Date | string
  }

  export type transaction_logsWhereInput = {
    AND?: transaction_logsWhereInput | transaction_logsWhereInput[]
    OR?: transaction_logsWhereInput[]
    NOT?: transaction_logsWhereInput | transaction_logsWhereInput[]
    id?: StringFilter<"transaction_logs"> | string
    provider_transaction_id?: StringFilter<"transaction_logs"> | string
    action?: StringFilter<"transaction_logs"> | string
    previous_status?: StringNullableFilter<"transaction_logs"> | string | null
    new_status?: StringFilter<"transaction_logs"> | string
    note?: StringNullableFilter<"transaction_logs"> | string | null
    created_at?: DateTimeFilter<"transaction_logs"> | Date | string
    provider_transactions?: XOR<Provider_transactionsScalarRelationFilter, provider_transactionsWhereInput>
  }

  export type transaction_logsOrderByWithRelationInput = {
    id?: SortOrder
    provider_transaction_id?: SortOrder
    action?: SortOrder
    previous_status?: SortOrderInput | SortOrder
    new_status?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    provider_transactions?: provider_transactionsOrderByWithRelationInput
  }

  export type transaction_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transaction_logsWhereInput | transaction_logsWhereInput[]
    OR?: transaction_logsWhereInput[]
    NOT?: transaction_logsWhereInput | transaction_logsWhereInput[]
    provider_transaction_id?: StringFilter<"transaction_logs"> | string
    action?: StringFilter<"transaction_logs"> | string
    previous_status?: StringNullableFilter<"transaction_logs"> | string | null
    new_status?: StringFilter<"transaction_logs"> | string
    note?: StringNullableFilter<"transaction_logs"> | string | null
    created_at?: DateTimeFilter<"transaction_logs"> | Date | string
    provider_transactions?: XOR<Provider_transactionsScalarRelationFilter, provider_transactionsWhereInput>
  }, "id">

  export type transaction_logsOrderByWithAggregationInput = {
    id?: SortOrder
    provider_transaction_id?: SortOrder
    action?: SortOrder
    previous_status?: SortOrderInput | SortOrder
    new_status?: SortOrder
    note?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: transaction_logsCountOrderByAggregateInput
    _max?: transaction_logsMaxOrderByAggregateInput
    _min?: transaction_logsMinOrderByAggregateInput
  }

  export type transaction_logsScalarWhereWithAggregatesInput = {
    AND?: transaction_logsScalarWhereWithAggregatesInput | transaction_logsScalarWhereWithAggregatesInput[]
    OR?: transaction_logsScalarWhereWithAggregatesInput[]
    NOT?: transaction_logsScalarWhereWithAggregatesInput | transaction_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"transaction_logs"> | string
    provider_transaction_id?: StringWithAggregatesFilter<"transaction_logs"> | string
    action?: StringWithAggregatesFilter<"transaction_logs"> | string
    previous_status?: StringNullableWithAggregatesFilter<"transaction_logs"> | string | null
    new_status?: StringWithAggregatesFilter<"transaction_logs"> | string
    note?: StringNullableWithAggregatesFilter<"transaction_logs"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"transaction_logs"> | Date | string
  }

  export type feedbacksWhereInput = {
    AND?: feedbacksWhereInput | feedbacksWhereInput[]
    OR?: feedbacksWhereInput[]
    NOT?: feedbacksWhereInput | feedbacksWhereInput[]
    id?: StringFilter<"feedbacks"> | string
    job_id?: StringFilter<"feedbacks"> | string
    from_user_id?: StringFilter<"feedbacks"> | string
    to_user_id?: StringFilter<"feedbacks"> | string
    reviewee_type?: EnumFeedbackTypeFilter<"feedbacks"> | $Enums.FeedbackType
    rating?: IntFilter<"feedbacks"> | number
    tags?: JsonNullableFilter<"feedbacks">
    comments?: StringNullableFilter<"feedbacks"> | string | null
    is_public?: BoolFilter<"feedbacks"> | boolean
    company_response?: StringNullableFilter<"feedbacks"> | string | null
    responded_at?: DateTimeNullableFilter<"feedbacks"> | Date | string | null
    flagged_inappropriate?: BoolFilter<"feedbacks"> | boolean
    createdAt?: DateTimeFilter<"feedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"feedbacks"> | Date | string
    users_feedbacks_to_user_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_feedbacks_from_user_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type feedbacksOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    reviewee_type?: SortOrder
    rating?: SortOrder
    tags?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    is_public?: SortOrder
    company_response?: SortOrderInput | SortOrder
    responded_at?: SortOrderInput | SortOrder
    flagged_inappropriate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users_feedbacks_to_user_idTousers?: usersOrderByWithRelationInput
    users_feedbacks_from_user_idTousers?: usersOrderByWithRelationInput
  }

  export type feedbacksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    job_id_from_user_id_to_user_id?: feedbacksJob_idFrom_user_idTo_user_idCompoundUniqueInput
    AND?: feedbacksWhereInput | feedbacksWhereInput[]
    OR?: feedbacksWhereInput[]
    NOT?: feedbacksWhereInput | feedbacksWhereInput[]
    job_id?: StringFilter<"feedbacks"> | string
    from_user_id?: StringFilter<"feedbacks"> | string
    to_user_id?: StringFilter<"feedbacks"> | string
    reviewee_type?: EnumFeedbackTypeFilter<"feedbacks"> | $Enums.FeedbackType
    rating?: IntFilter<"feedbacks"> | number
    tags?: JsonNullableFilter<"feedbacks">
    comments?: StringNullableFilter<"feedbacks"> | string | null
    is_public?: BoolFilter<"feedbacks"> | boolean
    company_response?: StringNullableFilter<"feedbacks"> | string | null
    responded_at?: DateTimeNullableFilter<"feedbacks"> | Date | string | null
    flagged_inappropriate?: BoolFilter<"feedbacks"> | boolean
    createdAt?: DateTimeFilter<"feedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"feedbacks"> | Date | string
    users_feedbacks_to_user_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_feedbacks_from_user_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "job_id_from_user_id_to_user_id">

  export type feedbacksOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    reviewee_type?: SortOrder
    rating?: SortOrder
    tags?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    is_public?: SortOrder
    company_response?: SortOrderInput | SortOrder
    responded_at?: SortOrderInput | SortOrder
    flagged_inappropriate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: feedbacksCountOrderByAggregateInput
    _avg?: feedbacksAvgOrderByAggregateInput
    _max?: feedbacksMaxOrderByAggregateInput
    _min?: feedbacksMinOrderByAggregateInput
    _sum?: feedbacksSumOrderByAggregateInput
  }

  export type feedbacksScalarWhereWithAggregatesInput = {
    AND?: feedbacksScalarWhereWithAggregatesInput | feedbacksScalarWhereWithAggregatesInput[]
    OR?: feedbacksScalarWhereWithAggregatesInput[]
    NOT?: feedbacksScalarWhereWithAggregatesInput | feedbacksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"feedbacks"> | string
    job_id?: StringWithAggregatesFilter<"feedbacks"> | string
    from_user_id?: StringWithAggregatesFilter<"feedbacks"> | string
    to_user_id?: StringWithAggregatesFilter<"feedbacks"> | string
    reviewee_type?: EnumFeedbackTypeWithAggregatesFilter<"feedbacks"> | $Enums.FeedbackType
    rating?: IntWithAggregatesFilter<"feedbacks"> | number
    tags?: JsonNullableWithAggregatesFilter<"feedbacks">
    comments?: StringNullableWithAggregatesFilter<"feedbacks"> | string | null
    is_public?: BoolWithAggregatesFilter<"feedbacks"> | boolean
    company_response?: StringNullableWithAggregatesFilter<"feedbacks"> | string | null
    responded_at?: DateTimeNullableWithAggregatesFilter<"feedbacks"> | Date | string | null
    flagged_inappropriate?: BoolWithAggregatesFilter<"feedbacks"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"feedbacks"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"feedbacks"> | Date | string
  }

  export type health_recordsWhereInput = {
    AND?: health_recordsWhereInput | health_recordsWhereInput[]
    OR?: health_recordsWhereInput[]
    NOT?: health_recordsWhereInput | health_recordsWhereInput[]
    id?: StringFilter<"health_records"> | string
    patient_id?: StringFilter<"health_records"> | string
    record_type?: EnumHealthRecordTypeFilter<"health_records"> | $Enums.HealthRecordType
    title?: StringFilter<"health_records"> | string
    description?: StringNullableFilter<"health_records"> | string | null
    file_url?: StringNullableFilter<"health_records"> | string | null
    metadata?: JsonNullableFilter<"health_records">
    uploaded_by?: StringNullableFilter<"health_records"> | string | null
    valid_from?: DateTimeNullableFilter<"health_records"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"health_records"> | Date | string | null
    is_archived?: BoolFilter<"health_records"> | boolean
    created_at?: DateTimeFilter<"health_records"> | Date | string
    updated_at?: DateTimeFilter<"health_records"> | Date | string
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }

  export type health_recordsOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    record_type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    uploaded_by?: SortOrderInput | SortOrder
    valid_from?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    is_archived?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    patients?: patientsOrderByWithRelationInput
  }

  export type health_recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: health_recordsWhereInput | health_recordsWhereInput[]
    OR?: health_recordsWhereInput[]
    NOT?: health_recordsWhereInput | health_recordsWhereInput[]
    patient_id?: StringFilter<"health_records"> | string
    record_type?: EnumHealthRecordTypeFilter<"health_records"> | $Enums.HealthRecordType
    title?: StringFilter<"health_records"> | string
    description?: StringNullableFilter<"health_records"> | string | null
    file_url?: StringNullableFilter<"health_records"> | string | null
    metadata?: JsonNullableFilter<"health_records">
    uploaded_by?: StringNullableFilter<"health_records"> | string | null
    valid_from?: DateTimeNullableFilter<"health_records"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"health_records"> | Date | string | null
    is_archived?: BoolFilter<"health_records"> | boolean
    created_at?: DateTimeFilter<"health_records"> | Date | string
    updated_at?: DateTimeFilter<"health_records"> | Date | string
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }, "id">

  export type health_recordsOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    record_type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file_url?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    uploaded_by?: SortOrderInput | SortOrder
    valid_from?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    is_archived?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: health_recordsCountOrderByAggregateInput
    _max?: health_recordsMaxOrderByAggregateInput
    _min?: health_recordsMinOrderByAggregateInput
  }

  export type health_recordsScalarWhereWithAggregatesInput = {
    AND?: health_recordsScalarWhereWithAggregatesInput | health_recordsScalarWhereWithAggregatesInput[]
    OR?: health_recordsScalarWhereWithAggregatesInput[]
    NOT?: health_recordsScalarWhereWithAggregatesInput | health_recordsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"health_records"> | string
    patient_id?: StringWithAggregatesFilter<"health_records"> | string
    record_type?: EnumHealthRecordTypeWithAggregatesFilter<"health_records"> | $Enums.HealthRecordType
    title?: StringWithAggregatesFilter<"health_records"> | string
    description?: StringNullableWithAggregatesFilter<"health_records"> | string | null
    file_url?: StringNullableWithAggregatesFilter<"health_records"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"health_records">
    uploaded_by?: StringNullableWithAggregatesFilter<"health_records"> | string | null
    valid_from?: DateTimeNullableWithAggregatesFilter<"health_records"> | Date | string | null
    valid_until?: DateTimeNullableWithAggregatesFilter<"health_records"> | Date | string | null
    is_archived?: BoolWithAggregatesFilter<"health_records"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"health_records"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"health_records"> | Date | string
  }

  export type job_applicationsWhereInput = {
    AND?: job_applicationsWhereInput | job_applicationsWhereInput[]
    OR?: job_applicationsWhereInput[]
    NOT?: job_applicationsWhereInput | job_applicationsWhereInput[]
    id?: StringFilter<"job_applications"> | string
    marketplace_job_id?: StringFilter<"job_applications"> | string
    caregiver_id?: StringFilter<"job_applications"> | string
    coverLetter?: StringNullableFilter<"job_applications"> | string | null
    status?: StringFilter<"job_applications"> | string
    reviewed_by?: StringNullableFilter<"job_applications"> | string | null
    reviewed_at?: DateTimeNullableFilter<"job_applications"> | Date | string | null
    review_notes?: StringNullableFilter<"job_applications"> | string | null
    created_at?: DateTimeFilter<"job_applications"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    caregivers?: XOR<CaregiversScalarRelationFilter, caregiversWhereInput>
    marketplace_jobs?: XOR<Marketplace_jobsScalarRelationFilter, marketplace_jobsWhereInput>
  }

  export type job_applicationsOrderByWithRelationInput = {
    id?: SortOrder
    marketplace_job_id?: SortOrder
    caregiver_id?: SortOrder
    coverLetter?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    reviewed_at?: SortOrderInput | SortOrder
    review_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
    caregivers?: caregiversOrderByWithRelationInput
    marketplace_jobs?: marketplace_jobsOrderByWithRelationInput
  }

  export type job_applicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    marketplace_job_id_caregiver_id?: job_applicationsMarketplace_job_idCaregiver_idCompoundUniqueInput
    AND?: job_applicationsWhereInput | job_applicationsWhereInput[]
    OR?: job_applicationsWhereInput[]
    NOT?: job_applicationsWhereInput | job_applicationsWhereInput[]
    marketplace_job_id?: StringFilter<"job_applications"> | string
    caregiver_id?: StringFilter<"job_applications"> | string
    coverLetter?: StringNullableFilter<"job_applications"> | string | null
    status?: StringFilter<"job_applications"> | string
    reviewed_by?: StringNullableFilter<"job_applications"> | string | null
    reviewed_at?: DateTimeNullableFilter<"job_applications"> | Date | string | null
    review_notes?: StringNullableFilter<"job_applications"> | string | null
    created_at?: DateTimeFilter<"job_applications"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    caregivers?: XOR<CaregiversScalarRelationFilter, caregiversWhereInput>
    marketplace_jobs?: XOR<Marketplace_jobsScalarRelationFilter, marketplace_jobsWhereInput>
  }, "id" | "marketplace_job_id_caregiver_id">

  export type job_applicationsOrderByWithAggregationInput = {
    id?: SortOrder
    marketplace_job_id?: SortOrder
    caregiver_id?: SortOrder
    coverLetter?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewed_by?: SortOrderInput | SortOrder
    reviewed_at?: SortOrderInput | SortOrder
    review_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: job_applicationsCountOrderByAggregateInput
    _max?: job_applicationsMaxOrderByAggregateInput
    _min?: job_applicationsMinOrderByAggregateInput
  }

  export type job_applicationsScalarWhereWithAggregatesInput = {
    AND?: job_applicationsScalarWhereWithAggregatesInput | job_applicationsScalarWhereWithAggregatesInput[]
    OR?: job_applicationsScalarWhereWithAggregatesInput[]
    NOT?: job_applicationsScalarWhereWithAggregatesInput | job_applicationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"job_applications"> | string
    marketplace_job_id?: StringWithAggregatesFilter<"job_applications"> | string
    caregiver_id?: StringWithAggregatesFilter<"job_applications"> | string
    coverLetter?: StringNullableWithAggregatesFilter<"job_applications"> | string | null
    status?: StringWithAggregatesFilter<"job_applications"> | string
    reviewed_by?: StringNullableWithAggregatesFilter<"job_applications"> | string | null
    reviewed_at?: DateTimeNullableWithAggregatesFilter<"job_applications"> | Date | string | null
    review_notes?: StringNullableWithAggregatesFilter<"job_applications"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"job_applications"> | Date | string
  }

  export type jobsWhereInput = {
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    id?: StringFilter<"jobs"> | string
    package_id?: StringFilter<"jobs"> | string
    patient_id?: StringFilter<"jobs"> | string
    company_id?: StringFilter<"jobs"> | string
    guardian_id?: StringFilter<"jobs"> | string
    start_date?: DateTimeFilter<"jobs"> | Date | string
    end_date?: DateTimeFilter<"jobs"> | Date | string
    status?: EnumJobStatusFilter<"jobs"> | $Enums.JobStatus
    total_price?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    special_instructions?: StringNullableFilter<"jobs"> | string | null
    completion_notes?: StringNullableFilter<"jobs"> | string | null
    cancelled_reason?: StringNullableFilter<"jobs"> | string | null
    cancelled_at?: DateTimeNullableFilter<"jobs"> | Date | string | null
    cancelled_by?: StringNullableFilter<"jobs"> | string | null
    created_at?: DateTimeFilter<"jobs"> | Date | string
    updated_at?: DateTimeFilter<"jobs"> | Date | string
    assignments?: AssignmentsListRelationFilter
    care_logs?: Care_logsListRelationFilter
    disputes?: DisputesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
    packages?: XOR<PackagesScalarRelationFilter, packagesWhereInput>
    payments?: PaymentsListRelationFilter
  }

  export type jobsOrderByWithRelationInput = {
    id?: SortOrder
    package_id?: SortOrder
    patient_id?: SortOrder
    company_id?: SortOrder
    guardian_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    total_price?: SortOrder
    commission_amount?: SortOrder
    payout_amount?: SortOrder
    special_instructions?: SortOrderInput | SortOrder
    completion_notes?: SortOrderInput | SortOrder
    cancelled_reason?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    assignments?: assignmentsOrderByRelationAggregateInput
    care_logs?: care_logsOrderByRelationAggregateInput
    disputes?: disputesOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    patients?: patientsOrderByWithRelationInput
    packages?: packagesOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
  }

  export type jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    package_id?: StringFilter<"jobs"> | string
    patient_id?: StringFilter<"jobs"> | string
    company_id?: StringFilter<"jobs"> | string
    guardian_id?: StringFilter<"jobs"> | string
    start_date?: DateTimeFilter<"jobs"> | Date | string
    end_date?: DateTimeFilter<"jobs"> | Date | string
    status?: EnumJobStatusFilter<"jobs"> | $Enums.JobStatus
    total_price?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    special_instructions?: StringNullableFilter<"jobs"> | string | null
    completion_notes?: StringNullableFilter<"jobs"> | string | null
    cancelled_reason?: StringNullableFilter<"jobs"> | string | null
    cancelled_at?: DateTimeNullableFilter<"jobs"> | Date | string | null
    cancelled_by?: StringNullableFilter<"jobs"> | string | null
    created_at?: DateTimeFilter<"jobs"> | Date | string
    updated_at?: DateTimeFilter<"jobs"> | Date | string
    assignments?: AssignmentsListRelationFilter
    care_logs?: Care_logsListRelationFilter
    disputes?: DisputesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
    packages?: XOR<PackagesScalarRelationFilter, packagesWhereInput>
    payments?: PaymentsListRelationFilter
  }, "id">

  export type jobsOrderByWithAggregationInput = {
    id?: SortOrder
    package_id?: SortOrder
    patient_id?: SortOrder
    company_id?: SortOrder
    guardian_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    total_price?: SortOrder
    commission_amount?: SortOrder
    payout_amount?: SortOrder
    special_instructions?: SortOrderInput | SortOrder
    completion_notes?: SortOrderInput | SortOrder
    cancelled_reason?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    cancelled_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: jobsCountOrderByAggregateInput
    _avg?: jobsAvgOrderByAggregateInput
    _max?: jobsMaxOrderByAggregateInput
    _min?: jobsMinOrderByAggregateInput
    _sum?: jobsSumOrderByAggregateInput
  }

  export type jobsScalarWhereWithAggregatesInput = {
    AND?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    OR?: jobsScalarWhereWithAggregatesInput[]
    NOT?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"jobs"> | string
    package_id?: StringWithAggregatesFilter<"jobs"> | string
    patient_id?: StringWithAggregatesFilter<"jobs"> | string
    company_id?: StringWithAggregatesFilter<"jobs"> | string
    guardian_id?: StringWithAggregatesFilter<"jobs"> | string
    start_date?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    status?: EnumJobStatusWithAggregatesFilter<"jobs"> | $Enums.JobStatus
    total_price?: DecimalWithAggregatesFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalWithAggregatesFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalWithAggregatesFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    special_instructions?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    completion_notes?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    cancelled_reason?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    cancelled_at?: DateTimeNullableWithAggregatesFilter<"jobs"> | Date | string | null
    cancelled_by?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
  }

  export type marketplace_jobsWhereInput = {
    AND?: marketplace_jobsWhereInput | marketplace_jobsWhereInput[]
    OR?: marketplace_jobsWhereInput[]
    NOT?: marketplace_jobsWhereInput | marketplace_jobsWhereInput[]
    id?: StringFilter<"marketplace_jobs"> | string
    company_id?: StringFilter<"marketplace_jobs"> | string
    title?: StringFilter<"marketplace_jobs"> | string
    description?: StringFilter<"marketplace_jobs"> | string
    location?: StringFilter<"marketplace_jobs"> | string
    required_skills?: JsonFilter<"marketplace_jobs">
    start_date?: DateTimeFilter<"marketplace_jobs"> | Date | string
    duration_days?: IntFilter<"marketplace_jobs"> | number
    hours_per_day?: IntFilter<"marketplace_jobs"> | number
    offered_rate?: DecimalFilter<"marketplace_jobs"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"marketplace_jobs"> | string
    applications_count?: IntFilter<"marketplace_jobs"> | number
    filled_by?: StringNullableFilter<"marketplace_jobs"> | string | null
    filled_at?: DateTimeNullableFilter<"marketplace_jobs"> | Date | string | null
    created_at?: DateTimeFilter<"marketplace_jobs"> | Date | string
    updated_at?: DateTimeFilter<"marketplace_jobs"> | Date | string
    job_applications?: Job_applicationsListRelationFilter
    caregivers?: XOR<CaregiversNullableScalarRelationFilter, caregiversWhereInput> | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type marketplace_jobsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    required_skills?: SortOrder
    start_date?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    offered_rate?: SortOrder
    status?: SortOrder
    applications_count?: SortOrder
    filled_by?: SortOrderInput | SortOrder
    filled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    job_applications?: job_applicationsOrderByRelationAggregateInput
    caregivers?: caregiversOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
  }

  export type marketplace_jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: marketplace_jobsWhereInput | marketplace_jobsWhereInput[]
    OR?: marketplace_jobsWhereInput[]
    NOT?: marketplace_jobsWhereInput | marketplace_jobsWhereInput[]
    company_id?: StringFilter<"marketplace_jobs"> | string
    title?: StringFilter<"marketplace_jobs"> | string
    description?: StringFilter<"marketplace_jobs"> | string
    location?: StringFilter<"marketplace_jobs"> | string
    required_skills?: JsonFilter<"marketplace_jobs">
    start_date?: DateTimeFilter<"marketplace_jobs"> | Date | string
    duration_days?: IntFilter<"marketplace_jobs"> | number
    hours_per_day?: IntFilter<"marketplace_jobs"> | number
    offered_rate?: DecimalFilter<"marketplace_jobs"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"marketplace_jobs"> | string
    applications_count?: IntFilter<"marketplace_jobs"> | number
    filled_by?: StringNullableFilter<"marketplace_jobs"> | string | null
    filled_at?: DateTimeNullableFilter<"marketplace_jobs"> | Date | string | null
    created_at?: DateTimeFilter<"marketplace_jobs"> | Date | string
    updated_at?: DateTimeFilter<"marketplace_jobs"> | Date | string
    job_applications?: Job_applicationsListRelationFilter
    caregivers?: XOR<CaregiversNullableScalarRelationFilter, caregiversWhereInput> | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type marketplace_jobsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    required_skills?: SortOrder
    start_date?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    offered_rate?: SortOrder
    status?: SortOrder
    applications_count?: SortOrder
    filled_by?: SortOrderInput | SortOrder
    filled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: marketplace_jobsCountOrderByAggregateInput
    _avg?: marketplace_jobsAvgOrderByAggregateInput
    _max?: marketplace_jobsMaxOrderByAggregateInput
    _min?: marketplace_jobsMinOrderByAggregateInput
    _sum?: marketplace_jobsSumOrderByAggregateInput
  }

  export type marketplace_jobsScalarWhereWithAggregatesInput = {
    AND?: marketplace_jobsScalarWhereWithAggregatesInput | marketplace_jobsScalarWhereWithAggregatesInput[]
    OR?: marketplace_jobsScalarWhereWithAggregatesInput[]
    NOT?: marketplace_jobsScalarWhereWithAggregatesInput | marketplace_jobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"marketplace_jobs"> | string
    company_id?: StringWithAggregatesFilter<"marketplace_jobs"> | string
    title?: StringWithAggregatesFilter<"marketplace_jobs"> | string
    description?: StringWithAggregatesFilter<"marketplace_jobs"> | string
    location?: StringWithAggregatesFilter<"marketplace_jobs"> | string
    required_skills?: JsonWithAggregatesFilter<"marketplace_jobs">
    start_date?: DateTimeWithAggregatesFilter<"marketplace_jobs"> | Date | string
    duration_days?: IntWithAggregatesFilter<"marketplace_jobs"> | number
    hours_per_day?: IntWithAggregatesFilter<"marketplace_jobs"> | number
    offered_rate?: DecimalWithAggregatesFilter<"marketplace_jobs"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"marketplace_jobs"> | string
    applications_count?: IntWithAggregatesFilter<"marketplace_jobs"> | number
    filled_by?: StringNullableWithAggregatesFilter<"marketplace_jobs"> | string | null
    filled_at?: DateTimeNullableWithAggregatesFilter<"marketplace_jobs"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"marketplace_jobs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"marketplace_jobs"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: StringFilter<"notifications"> | string
    userId?: StringFilter<"notifications"> | string
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    channel?: StringFilter<"notifications"> | string
    title?: StringNullableFilter<"notifications"> | string | null
    body?: StringFilter<"notifications"> | string
    data?: JsonNullableFilter<"notifications">
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    sent_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    delivered_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    error_message?: StringNullableFilter<"notifications"> | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    status?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    delivered_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    userId?: StringFilter<"notifications"> | string
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    channel?: StringFilter<"notifications"> | string
    title?: StringNullableFilter<"notifications"> | string | null
    body?: StringFilter<"notifications"> | string
    data?: JsonNullableFilter<"notifications">
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    sent_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    delivered_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    error_message?: StringNullableFilter<"notifications"> | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    status?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    delivered_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notifications"> | string
    userId?: StringWithAggregatesFilter<"notifications"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"notifications"> | $Enums.NotificationType
    channel?: StringWithAggregatesFilter<"notifications"> | string
    title?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    body?: StringWithAggregatesFilter<"notifications"> | string
    data?: JsonNullableWithAggregatesFilter<"notifications">
    status?: EnumNotificationStatusWithAggregatesFilter<"notifications"> | $Enums.NotificationStatus
    sent_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    delivered_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    error_message?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type packagesWhereInput = {
    AND?: packagesWhereInput | packagesWhereInput[]
    OR?: packagesWhereInput[]
    NOT?: packagesWhereInput | packagesWhereInput[]
    id?: StringFilter<"packages"> | string
    company_id?: StringFilter<"packages"> | string
    name?: StringFilter<"packages"> | string
    description?: StringFilter<"packages"> | string
    category?: EnumPackageCategoryFilter<"packages"> | $Enums.PackageCategory
    price?: DecimalFilter<"packages"> | Decimal | DecimalJsLike | number | string
    duration_days?: IntFilter<"packages"> | number
    hours_per_day?: IntFilter<"packages"> | number
    inclusions?: JsonFilter<"packages">
    exclusions?: JsonNullableFilter<"packages">
    caregiver_count?: IntFilter<"packages"> | number
    is_active?: BoolFilter<"packages"> | boolean
    min_advance_days?: IntFilter<"packages"> | number
    created_at?: DateTimeFilter<"packages"> | Date | string
    updated_at?: DateTimeFilter<"packages"> | Date | string
    jobs?: JobsListRelationFilter
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type packagesOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    inclusions?: SortOrder
    exclusions?: SortOrderInput | SortOrder
    caregiver_count?: SortOrder
    is_active?: SortOrder
    min_advance_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    jobs?: jobsOrderByRelationAggregateInput
    companies?: companiesOrderByWithRelationInput
  }

  export type packagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: packagesWhereInput | packagesWhereInput[]
    OR?: packagesWhereInput[]
    NOT?: packagesWhereInput | packagesWhereInput[]
    company_id?: StringFilter<"packages"> | string
    name?: StringFilter<"packages"> | string
    description?: StringFilter<"packages"> | string
    category?: EnumPackageCategoryFilter<"packages"> | $Enums.PackageCategory
    price?: DecimalFilter<"packages"> | Decimal | DecimalJsLike | number | string
    duration_days?: IntFilter<"packages"> | number
    hours_per_day?: IntFilter<"packages"> | number
    inclusions?: JsonFilter<"packages">
    exclusions?: JsonNullableFilter<"packages">
    caregiver_count?: IntFilter<"packages"> | number
    is_active?: BoolFilter<"packages"> | boolean
    min_advance_days?: IntFilter<"packages"> | number
    created_at?: DateTimeFilter<"packages"> | Date | string
    updated_at?: DateTimeFilter<"packages"> | Date | string
    jobs?: JobsListRelationFilter
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type packagesOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    inclusions?: SortOrder
    exclusions?: SortOrderInput | SortOrder
    caregiver_count?: SortOrder
    is_active?: SortOrder
    min_advance_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: packagesCountOrderByAggregateInput
    _avg?: packagesAvgOrderByAggregateInput
    _max?: packagesMaxOrderByAggregateInput
    _min?: packagesMinOrderByAggregateInput
    _sum?: packagesSumOrderByAggregateInput
  }

  export type packagesScalarWhereWithAggregatesInput = {
    AND?: packagesScalarWhereWithAggregatesInput | packagesScalarWhereWithAggregatesInput[]
    OR?: packagesScalarWhereWithAggregatesInput[]
    NOT?: packagesScalarWhereWithAggregatesInput | packagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"packages"> | string
    company_id?: StringWithAggregatesFilter<"packages"> | string
    name?: StringWithAggregatesFilter<"packages"> | string
    description?: StringWithAggregatesFilter<"packages"> | string
    category?: EnumPackageCategoryWithAggregatesFilter<"packages"> | $Enums.PackageCategory
    price?: DecimalWithAggregatesFilter<"packages"> | Decimal | DecimalJsLike | number | string
    duration_days?: IntWithAggregatesFilter<"packages"> | number
    hours_per_day?: IntWithAggregatesFilter<"packages"> | number
    inclusions?: JsonWithAggregatesFilter<"packages">
    exclusions?: JsonNullableWithAggregatesFilter<"packages">
    caregiver_count?: IntWithAggregatesFilter<"packages"> | number
    is_active?: BoolWithAggregatesFilter<"packages"> | boolean
    min_advance_days?: IntWithAggregatesFilter<"packages"> | number
    created_at?: DateTimeWithAggregatesFilter<"packages"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"packages"> | Date | string
  }

  export type patientsWhereInput = {
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    id?: StringFilter<"patients"> | string
    user_id?: StringNullableFilter<"patients"> | string | null
    guardian_id?: StringFilter<"patients"> | string
    name?: StringFilter<"patients"> | string
    date_of_birth?: DateTimeFilter<"patients"> | Date | string
    gender?: EnumGenderFilter<"patients"> | $Enums.Gender
    blood_group?: StringNullableFilter<"patients"> | string | null
    address?: StringFilter<"patients"> | string
    emergency_contact_name?: StringFilter<"patients"> | string
    emergency_contact_phone?: StringFilter<"patients"> | string
    primaryConditions?: JsonNullableFilter<"patients">
    allergies?: StringNullableFilter<"patients"> | string | null
    mobility_level?: EnumMobilityLevelFilter<"patients"> | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFilter<"patients"> | $Enums.CognitiveStatus
    photoUrl?: StringNullableFilter<"patients"> | string | null
    consent_data_sharing?: BoolFilter<"patients"> | boolean
    consent_marketing?: BoolFilter<"patients"> | boolean
    deletedAt?: DateTimeNullableFilter<"patients"> | Date | string | null
    createdAt?: DateTimeFilter<"patients"> | Date | string
    updatedAt?: DateTimeFilter<"patients"> | Date | string
    care_logs?: Care_logsListRelationFilter
    health_records?: Health_recordsListRelationFilter
    jobs?: JobsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type patientsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    guardian_id?: SortOrder
    name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    blood_group?: SortOrderInput | SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_phone?: SortOrder
    primaryConditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    mobility_level?: SortOrder
    cognitive_status?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    consent_data_sharing?: SortOrder
    consent_marketing?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    care_logs?: care_logsOrderByRelationAggregateInput
    health_records?: health_recordsOrderByRelationAggregateInput
    jobs?: jobsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type patientsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    user_id?: StringNullableFilter<"patients"> | string | null
    guardian_id?: StringFilter<"patients"> | string
    name?: StringFilter<"patients"> | string
    date_of_birth?: DateTimeFilter<"patients"> | Date | string
    gender?: EnumGenderFilter<"patients"> | $Enums.Gender
    blood_group?: StringNullableFilter<"patients"> | string | null
    address?: StringFilter<"patients"> | string
    emergency_contact_name?: StringFilter<"patients"> | string
    emergency_contact_phone?: StringFilter<"patients"> | string
    primaryConditions?: JsonNullableFilter<"patients">
    allergies?: StringNullableFilter<"patients"> | string | null
    mobility_level?: EnumMobilityLevelFilter<"patients"> | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFilter<"patients"> | $Enums.CognitiveStatus
    photoUrl?: StringNullableFilter<"patients"> | string | null
    consent_data_sharing?: BoolFilter<"patients"> | boolean
    consent_marketing?: BoolFilter<"patients"> | boolean
    deletedAt?: DateTimeNullableFilter<"patients"> | Date | string | null
    createdAt?: DateTimeFilter<"patients"> | Date | string
    updatedAt?: DateTimeFilter<"patients"> | Date | string
    care_logs?: Care_logsListRelationFilter
    health_records?: Health_recordsListRelationFilter
    jobs?: JobsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type patientsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    guardian_id?: SortOrder
    name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    blood_group?: SortOrderInput | SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_phone?: SortOrder
    primaryConditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    mobility_level?: SortOrder
    cognitive_status?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    consent_data_sharing?: SortOrder
    consent_marketing?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: patientsCountOrderByAggregateInput
    _max?: patientsMaxOrderByAggregateInput
    _min?: patientsMinOrderByAggregateInput
  }

  export type patientsScalarWhereWithAggregatesInput = {
    AND?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    OR?: patientsScalarWhereWithAggregatesInput[]
    NOT?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"patients"> | string
    user_id?: StringNullableWithAggregatesFilter<"patients"> | string | null
    guardian_id?: StringWithAggregatesFilter<"patients"> | string
    name?: StringWithAggregatesFilter<"patients"> | string
    date_of_birth?: DateTimeWithAggregatesFilter<"patients"> | Date | string
    gender?: EnumGenderWithAggregatesFilter<"patients"> | $Enums.Gender
    blood_group?: StringNullableWithAggregatesFilter<"patients"> | string | null
    address?: StringWithAggregatesFilter<"patients"> | string
    emergency_contact_name?: StringWithAggregatesFilter<"patients"> | string
    emergency_contact_phone?: StringWithAggregatesFilter<"patients"> | string
    primaryConditions?: JsonNullableWithAggregatesFilter<"patients">
    allergies?: StringNullableWithAggregatesFilter<"patients"> | string | null
    mobility_level?: EnumMobilityLevelWithAggregatesFilter<"patients"> | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusWithAggregatesFilter<"patients"> | $Enums.CognitiveStatus
    photoUrl?: StringNullableWithAggregatesFilter<"patients"> | string | null
    consent_data_sharing?: BoolWithAggregatesFilter<"patients"> | boolean
    consent_marketing?: BoolWithAggregatesFilter<"patients"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"patients"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"patients"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"patients"> | Date | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: StringFilter<"payments"> | string
    job_id?: StringNullableFilter<"payments"> | string | null
    payer_id?: StringFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    transaction_id?: StringFilter<"payments"> | string
    status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    invoice_number?: StringFilter<"payments"> | string
    invoice_url?: StringNullableFilter<"payments"> | string | null
    receipt_url?: StringNullableFilter<"payments"> | string | null
    paid_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_reason?: StringNullableFilter<"payments"> | string | null
    gatewayResponse?: JsonNullableFilter<"payments">
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeFilter<"payments"> | Date | string
    escrows?: XOR<EscrowsNullableScalarRelationFilter, escrowsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    jobs?: XOR<JobsNullableScalarRelationFilter, jobsWhereInput> | null
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    job_id?: SortOrderInput | SortOrder
    payer_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
    invoice_url?: SortOrderInput | SortOrder
    receipt_url?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    refund_amount?: SortOrderInput | SortOrder
    refund_reason?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    escrows?: escrowsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    jobs?: jobsOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transaction_id?: string
    invoice_number?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    job_id?: StringNullableFilter<"payments"> | string | null
    payer_id?: StringFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    invoice_url?: StringNullableFilter<"payments"> | string | null
    receipt_url?: StringNullableFilter<"payments"> | string | null
    paid_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_reason?: StringNullableFilter<"payments"> | string | null
    gatewayResponse?: JsonNullableFilter<"payments">
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeFilter<"payments"> | Date | string
    escrows?: XOR<EscrowsNullableScalarRelationFilter, escrowsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    jobs?: XOR<JobsNullableScalarRelationFilter, jobsWhereInput> | null
  }, "id" | "transaction_id" | "invoice_number">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    job_id?: SortOrderInput | SortOrder
    payer_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
    invoice_url?: SortOrderInput | SortOrder
    receipt_url?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    refund_amount?: SortOrderInput | SortOrder
    refund_reason?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"payments"> | string
    job_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    payer_id?: StringWithAggregatesFilter<"payments"> | string
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    transaction_id?: StringWithAggregatesFilter<"payments"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"payments"> | $Enums.PaymentStatus
    invoice_number?: StringWithAggregatesFilter<"payments"> | string
    invoice_url?: StringNullableWithAggregatesFilter<"payments"> | string | null
    receipt_url?: StringNullableWithAggregatesFilter<"payments"> | string | null
    paid_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_reason?: StringNullableWithAggregatesFilter<"payments"> | string | null
    gatewayResponse?: JsonNullableWithAggregatesFilter<"payments">
    created_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
  }

  export type scheduled_tasksWhereInput = {
    AND?: scheduled_tasksWhereInput | scheduled_tasksWhereInput[]
    OR?: scheduled_tasksWhereInput[]
    NOT?: scheduled_tasksWhereInput | scheduled_tasksWhereInput[]
    id?: StringFilter<"scheduled_tasks"> | string
    task_type?: StringFilter<"scheduled_tasks"> | string
    job_id?: StringNullableFilter<"scheduled_tasks"> | string | null
    execute_at?: DateTimeFilter<"scheduled_tasks"> | Date | string
    payload?: JsonNullableFilter<"scheduled_tasks">
    createdAt?: DateTimeFilter<"scheduled_tasks"> | Date | string
    executedAt?: DateTimeNullableFilter<"scheduled_tasks"> | Date | string | null
    status?: StringFilter<"scheduled_tasks"> | string
  }

  export type scheduled_tasksOrderByWithRelationInput = {
    id?: SortOrder
    task_type?: SortOrder
    job_id?: SortOrderInput | SortOrder
    execute_at?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    status?: SortOrder
  }

  export type scheduled_tasksWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: scheduled_tasksWhereInput | scheduled_tasksWhereInput[]
    OR?: scheduled_tasksWhereInput[]
    NOT?: scheduled_tasksWhereInput | scheduled_tasksWhereInput[]
    task_type?: StringFilter<"scheduled_tasks"> | string
    job_id?: StringNullableFilter<"scheduled_tasks"> | string | null
    execute_at?: DateTimeFilter<"scheduled_tasks"> | Date | string
    payload?: JsonNullableFilter<"scheduled_tasks">
    createdAt?: DateTimeFilter<"scheduled_tasks"> | Date | string
    executedAt?: DateTimeNullableFilter<"scheduled_tasks"> | Date | string | null
    status?: StringFilter<"scheduled_tasks"> | string
  }, "id">

  export type scheduled_tasksOrderByWithAggregationInput = {
    id?: SortOrder
    task_type?: SortOrder
    job_id?: SortOrderInput | SortOrder
    execute_at?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: scheduled_tasksCountOrderByAggregateInput
    _max?: scheduled_tasksMaxOrderByAggregateInput
    _min?: scheduled_tasksMinOrderByAggregateInput
  }

  export type scheduled_tasksScalarWhereWithAggregatesInput = {
    AND?: scheduled_tasksScalarWhereWithAggregatesInput | scheduled_tasksScalarWhereWithAggregatesInput[]
    OR?: scheduled_tasksScalarWhereWithAggregatesInput[]
    NOT?: scheduled_tasksScalarWhereWithAggregatesInput | scheduled_tasksScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"scheduled_tasks"> | string
    task_type?: StringWithAggregatesFilter<"scheduled_tasks"> | string
    job_id?: StringNullableWithAggregatesFilter<"scheduled_tasks"> | string | null
    execute_at?: DateTimeWithAggregatesFilter<"scheduled_tasks"> | Date | string
    payload?: JsonNullableWithAggregatesFilter<"scheduled_tasks">
    createdAt?: DateTimeWithAggregatesFilter<"scheduled_tasks"> | Date | string
    executedAt?: DateTimeNullableWithAggregatesFilter<"scheduled_tasks"> | Date | string | null
    status?: StringWithAggregatesFilter<"scheduled_tasks"> | string
  }

  export type service_zonesWhereInput = {
    AND?: service_zonesWhereInput | service_zonesWhereInput[]
    OR?: service_zonesWhereInput[]
    NOT?: service_zonesWhereInput | service_zonesWhereInput[]
    id?: StringFilter<"service_zones"> | string
    company_id?: StringFilter<"service_zones"> | string
    zone_name?: StringFilter<"service_zones"> | string
    region_code?: StringFilter<"service_zones"> | string
    boundary_geojson?: JsonNullableFilter<"service_zones">
    is_active?: BoolFilter<"service_zones"> | boolean
    created_at?: DateTimeFilter<"service_zones"> | Date | string
    updated_at?: DateTimeFilter<"service_zones"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type service_zonesOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    zone_name?: SortOrder
    region_code?: SortOrder
    boundary_geojson?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type service_zonesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: service_zonesWhereInput | service_zonesWhereInput[]
    OR?: service_zonesWhereInput[]
    NOT?: service_zonesWhereInput | service_zonesWhereInput[]
    company_id?: StringFilter<"service_zones"> | string
    zone_name?: StringFilter<"service_zones"> | string
    region_code?: StringFilter<"service_zones"> | string
    boundary_geojson?: JsonNullableFilter<"service_zones">
    is_active?: BoolFilter<"service_zones"> | boolean
    created_at?: DateTimeFilter<"service_zones"> | Date | string
    updated_at?: DateTimeFilter<"service_zones"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type service_zonesOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    zone_name?: SortOrder
    region_code?: SortOrder
    boundary_geojson?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: service_zonesCountOrderByAggregateInput
    _max?: service_zonesMaxOrderByAggregateInput
    _min?: service_zonesMinOrderByAggregateInput
  }

  export type service_zonesScalarWhereWithAggregatesInput = {
    AND?: service_zonesScalarWhereWithAggregatesInput | service_zonesScalarWhereWithAggregatesInput[]
    OR?: service_zonesScalarWhereWithAggregatesInput[]
    NOT?: service_zonesScalarWhereWithAggregatesInput | service_zonesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"service_zones"> | string
    company_id?: StringWithAggregatesFilter<"service_zones"> | string
    zone_name?: StringWithAggregatesFilter<"service_zones"> | string
    region_code?: StringWithAggregatesFilter<"service_zones"> | string
    boundary_geojson?: JsonNullableWithAggregatesFilter<"service_zones">
    is_active?: BoolWithAggregatesFilter<"service_zones"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"service_zones"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"service_zones"> | Date | string
  }

  export type user_devicesWhereInput = {
    AND?: user_devicesWhereInput | user_devicesWhereInput[]
    OR?: user_devicesWhereInput[]
    NOT?: user_devicesWhereInput | user_devicesWhereInput[]
    id?: StringFilter<"user_devices"> | string
    user_id?: StringFilter<"user_devices"> | string
    device_id?: StringFilter<"user_devices"> | string
    fcm_token?: StringFilter<"user_devices"> | string
    platform?: StringFilter<"user_devices"> | string
    app_version?: StringNullableFilter<"user_devices"> | string | null
    is_active?: BoolFilter<"user_devices"> | boolean
    last_seen_at?: DateTimeFilter<"user_devices"> | Date | string
    created_at?: DateTimeFilter<"user_devices"> | Date | string
    updated_at?: DateTimeFilter<"user_devices"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_devicesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    fcm_token?: SortOrder
    platform?: SortOrder
    app_version?: SortOrderInput | SortOrder
    is_active?: SortOrder
    last_seen_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_devicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    device_id?: string
    AND?: user_devicesWhereInput | user_devicesWhereInput[]
    OR?: user_devicesWhereInput[]
    NOT?: user_devicesWhereInput | user_devicesWhereInput[]
    user_id?: StringFilter<"user_devices"> | string
    fcm_token?: StringFilter<"user_devices"> | string
    platform?: StringFilter<"user_devices"> | string
    app_version?: StringNullableFilter<"user_devices"> | string | null
    is_active?: BoolFilter<"user_devices"> | boolean
    last_seen_at?: DateTimeFilter<"user_devices"> | Date | string
    created_at?: DateTimeFilter<"user_devices"> | Date | string
    updated_at?: DateTimeFilter<"user_devices"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "device_id">

  export type user_devicesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    fcm_token?: SortOrder
    platform?: SortOrder
    app_version?: SortOrderInput | SortOrder
    is_active?: SortOrder
    last_seen_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: user_devicesCountOrderByAggregateInput
    _max?: user_devicesMaxOrderByAggregateInput
    _min?: user_devicesMinOrderByAggregateInput
  }

  export type user_devicesScalarWhereWithAggregatesInput = {
    AND?: user_devicesScalarWhereWithAggregatesInput | user_devicesScalarWhereWithAggregatesInput[]
    OR?: user_devicesScalarWhereWithAggregatesInput[]
    NOT?: user_devicesScalarWhereWithAggregatesInput | user_devicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_devices"> | string
    user_id?: StringWithAggregatesFilter<"user_devices"> | string
    device_id?: StringWithAggregatesFilter<"user_devices"> | string
    fcm_token?: StringWithAggregatesFilter<"user_devices"> | string
    platform?: StringWithAggregatesFilter<"user_devices"> | string
    app_version?: StringNullableWithAggregatesFilter<"user_devices"> | string | null
    is_active?: BoolWithAggregatesFilter<"user_devices"> | boolean
    last_seen_at?: DateTimeWithAggregatesFilter<"user_devices"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"user_devices"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user_devices"> | Date | string
  }

  export type verification_codesWhereInput = {
    AND?: verification_codesWhereInput | verification_codesWhereInput[]
    OR?: verification_codesWhereInput[]
    NOT?: verification_codesWhereInput | verification_codesWhereInput[]
    id?: StringFilter<"verification_codes"> | string
    userId?: StringFilter<"verification_codes"> | string
    code?: StringFilter<"verification_codes"> | string
    type?: StringFilter<"verification_codes"> | string
    expiresAt?: DateTimeFilter<"verification_codes"> | Date | string
    isUsed?: BoolFilter<"verification_codes"> | boolean
    usedAt?: DateTimeNullableFilter<"verification_codes"> | Date | string | null
    createdAt?: DateTimeFilter<"verification_codes"> | Date | string
    updatedAt?: DateTimeFilter<"verification_codes"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type verification_codesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type verification_codesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: verification_codesWhereInput | verification_codesWhereInput[]
    OR?: verification_codesWhereInput[]
    NOT?: verification_codesWhereInput | verification_codesWhereInput[]
    userId?: StringFilter<"verification_codes"> | string
    code?: StringFilter<"verification_codes"> | string
    type?: StringFilter<"verification_codes"> | string
    expiresAt?: DateTimeFilter<"verification_codes"> | Date | string
    isUsed?: BoolFilter<"verification_codes"> | boolean
    usedAt?: DateTimeNullableFilter<"verification_codes"> | Date | string | null
    createdAt?: DateTimeFilter<"verification_codes"> | Date | string
    updatedAt?: DateTimeFilter<"verification_codes"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type verification_codesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: verification_codesCountOrderByAggregateInput
    _max?: verification_codesMaxOrderByAggregateInput
    _min?: verification_codesMinOrderByAggregateInput
  }

  export type verification_codesScalarWhereWithAggregatesInput = {
    AND?: verification_codesScalarWhereWithAggregatesInput | verification_codesScalarWhereWithAggregatesInput[]
    OR?: verification_codesScalarWhereWithAggregatesInput[]
    NOT?: verification_codesScalarWhereWithAggregatesInput | verification_codesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"verification_codes"> | string
    userId?: StringWithAggregatesFilter<"verification_codes"> | string
    code?: StringWithAggregatesFilter<"verification_codes"> | string
    type?: StringWithAggregatesFilter<"verification_codes"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"verification_codes"> | Date | string
    isUsed?: BoolWithAggregatesFilter<"verification_codes"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"verification_codes"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"verification_codes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"verification_codes"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    phone?: StringFilter<"users"> | string
    email?: StringNullableFilter<"users"> | string | null
    password_hash?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    language?: StringFilter<"users"> | string
    kyc_status?: EnumKYCStatusFilter<"users"> | $Enums.KYCStatus
    kyc_document_url?: StringNullableFilter<"users"> | string | null
    mfa_enabled?: BoolFilter<"users"> | boolean
    mfa_secret?: StringNullableFilter<"users"> | string | null
    last_login_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_active?: BoolFilter<"users"> | boolean
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    company_id?: StringNullableFilter<"users"> | string | null
    audit_logs?: Audit_logsListRelationFilter
    caregivers?: XOR<CaregiversNullableScalarRelationFilter, caregiversWhereInput> | null
    disputes_disputes_againstTousers?: DisputesListRelationFilter
    disputes_disputes_raised_byTousers?: DisputesListRelationFilter
    feedbacks_feedbacks_to_user_idTousers?: FeedbacksListRelationFilter
    feedbacks_feedbacks_from_user_idTousers?: FeedbacksListRelationFilter
    job_applications?: Job_applicationsListRelationFilter
    jobs?: JobsListRelationFilter
    notifications?: NotificationsListRelationFilter
    patients?: PatientsListRelationFilter
    payments?: PaymentsListRelationFilter
    user_devices?: User_devicesListRelationFilter
    verification_codes?: Verification_codesListRelationFilter
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    language?: SortOrder
    kyc_status?: SortOrder
    kyc_document_url?: SortOrderInput | SortOrder
    mfa_enabled?: SortOrder
    mfa_secret?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company_id?: SortOrderInput | SortOrder
    audit_logs?: audit_logsOrderByRelationAggregateInput
    caregivers?: caregiversOrderByWithRelationInput
    disputes_disputes_againstTousers?: disputesOrderByRelationAggregateInput
    disputes_disputes_raised_byTousers?: disputesOrderByRelationAggregateInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksOrderByRelationAggregateInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksOrderByRelationAggregateInput
    job_applications?: job_applicationsOrderByRelationAggregateInput
    jobs?: jobsOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    patients?: patientsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    user_devices?: user_devicesOrderByRelationAggregateInput
    verification_codes?: verification_codesOrderByRelationAggregateInput
    companies?: companiesOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    password_hash?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    language?: StringFilter<"users"> | string
    kyc_status?: EnumKYCStatusFilter<"users"> | $Enums.KYCStatus
    kyc_document_url?: StringNullableFilter<"users"> | string | null
    mfa_enabled?: BoolFilter<"users"> | boolean
    mfa_secret?: StringNullableFilter<"users"> | string | null
    last_login_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_active?: BoolFilter<"users"> | boolean
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    company_id?: StringNullableFilter<"users"> | string | null
    audit_logs?: Audit_logsListRelationFilter
    caregivers?: XOR<CaregiversNullableScalarRelationFilter, caregiversWhereInput> | null
    disputes_disputes_againstTousers?: DisputesListRelationFilter
    disputes_disputes_raised_byTousers?: DisputesListRelationFilter
    feedbacks_feedbacks_to_user_idTousers?: FeedbacksListRelationFilter
    feedbacks_feedbacks_from_user_idTousers?: FeedbacksListRelationFilter
    job_applications?: Job_applicationsListRelationFilter
    jobs?: JobsListRelationFilter
    notifications?: NotificationsListRelationFilter
    patients?: PatientsListRelationFilter
    payments?: PaymentsListRelationFilter
    user_devices?: User_devicesListRelationFilter
    verification_codes?: Verification_codesListRelationFilter
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
  }, "id" | "phone" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    language?: SortOrder
    kyc_status?: SortOrder
    kyc_document_url?: SortOrderInput | SortOrder
    mfa_enabled?: SortOrder
    mfa_secret?: SortOrderInput | SortOrder
    last_login_at?: SortOrderInput | SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company_id?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    role?: EnumUserRoleWithAggregatesFilter<"users"> | $Enums.UserRole
    phone?: StringWithAggregatesFilter<"users"> | string
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    password_hash?: StringWithAggregatesFilter<"users"> | string
    name?: StringWithAggregatesFilter<"users"> | string
    language?: StringWithAggregatesFilter<"users"> | string
    kyc_status?: EnumKYCStatusWithAggregatesFilter<"users"> | $Enums.KYCStatus
    kyc_document_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    mfa_enabled?: BoolWithAggregatesFilter<"users"> | boolean
    mfa_secret?: StringNullableWithAggregatesFilter<"users"> | string | null
    last_login_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    is_active?: BoolWithAggregatesFilter<"users"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    company_id?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type assignmentsCreateInput = {
    id?: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversCreateNestedOneWithoutAssignments_assignments_replaced_byTocaregiversInput
    caregivers_assignments_caregiver_idTocaregivers: caregiversCreateNestedOneWithoutAssignments_assignments_caregiver_idTocaregiversInput
    jobs: jobsCreateNestedOneWithoutAssignmentsInput
    care_logs?: care_logsCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsUncheckedCreateInput = {
    id?: string
    job_id: string
    caregiver_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replaced_by?: string | null
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversUpdateOneWithoutAssignments_assignments_replaced_byTocaregiversNestedInput
    caregivers_assignments_caregiver_idTocaregivers?: caregiversUpdateOneRequiredWithoutAssignments_assignments_caregiver_idTocaregiversNestedInput
    jobs?: jobsUpdateOneRequiredWithoutAssignmentsNestedInput
    care_logs?: care_logsUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replaced_by?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsCreateManyInput = {
    id?: string
    job_id: string
    caregiver_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replaced_by?: string | null
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type assignmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replaced_by?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsCreateInput = {
    id?: string
    actor_role?: string | null
    action_type: string
    entity_type: string
    entity_id: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string
    users?: usersCreateNestedOneWithoutAudit_logsInput
  }

  export type audit_logsUncheckedCreateInput = {
    id?: string
    actor_id?: string | null
    actor_role?: string | null
    action_type: string
    entity_type: string
    entity_id: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string
  }

  export type audit_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actor_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutAudit_logsNestedInput
  }

  export type audit_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actor_id?: NullableStringFieldUpdateOperationsInput | string | null
    actor_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsCreateManyInput = {
    id?: string
    actor_id?: string | null
    actor_role?: string | null
    action_type: string
    entity_type: string
    entity_id: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string
  }

  export type audit_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actor_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actor_id?: NullableStringFieldUpdateOperationsInput | string | null
    actor_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsCreateInput = {
    id?: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
    patients: patientsCreateNestedOneWithoutCare_logsInput
    caregivers: caregiversCreateNestedOneWithoutCare_logsInput
    assignments?: assignmentsCreateNestedOneWithoutCare_logsInput
    jobs: jobsCreateNestedOneWithoutCare_logsInput
  }

  export type care_logsUncheckedCreateInput = {
    id?: string
    job_id: string
    assignment_id?: string | null
    caregiver_id: string
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type care_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: patientsUpdateOneRequiredWithoutCare_logsNestedInput
    caregivers?: caregiversUpdateOneRequiredWithoutCare_logsNestedInput
    assignments?: assignmentsUpdateOneWithoutCare_logsNestedInput
    jobs?: jobsUpdateOneRequiredWithoutCare_logsNestedInput
  }

  export type care_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    caregiver_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsCreateManyInput = {
    id?: string
    job_id: string
    assignment_id?: string | null
    caregiver_id: string
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type care_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    caregiver_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type caregiversCreateInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutCaregiversInput
    companies?: companiesCreateNestedOneWithoutCaregiversInput
    users: usersCreateNestedOneWithoutCaregiversInput
    job_applications?: job_applicationsCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateInput = {
    id?: string
    userId: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutCaregiversInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutCaregiversNestedInput
    companies?: companiesUpdateOneWithoutCaregiversNestedInput
    users?: usersUpdateOneRequiredWithoutCaregiversNestedInput
    job_applications?: job_applicationsUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutCaregiversNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversCreateManyInput = {
    id?: string
    userId: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type caregiversUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type caregiversUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companiesCreateInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedManyWithoutCompaniesInput
    jobs?: jobsCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCompaniesInput
    packages?: packagesCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversUncheckedCreateNestedManyWithoutCompaniesInput
    jobs?: jobsUncheckedCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCompaniesInput
    packages?: packagesUncheckedCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUncheckedUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type companiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesCreateInput = {
    id?: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users_disputes_againstTousers: usersCreateNestedOneWithoutDisputes_disputes_againstTousersInput
    users_disputes_raised_byTousers: usersCreateNestedOneWithoutDisputes_disputes_raised_byTousersInput
    jobs: jobsCreateNestedOneWithoutDisputesInput
  }

  export type disputesUncheckedCreateInput = {
    id?: string
    job_id: string
    raised_by: string
    against: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type disputesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_disputes_againstTousers?: usersUpdateOneRequiredWithoutDisputes_disputes_againstTousersNestedInput
    users_disputes_raised_byTousers?: usersUpdateOneRequiredWithoutDisputes_disputes_raised_byTousersNestedInput
    jobs?: jobsUpdateOneRequiredWithoutDisputesNestedInput
  }

  export type disputesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    raised_by?: StringFieldUpdateOperationsInput | string
    against?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesCreateManyInput = {
    id?: string
    job_id: string
    raised_by: string
    against: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type disputesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    raised_by?: StringFieldUpdateOperationsInput | string
    against?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrowsCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments: paymentsCreateNestedOneWithoutEscrowsInput
  }

  export type escrowsUncheckedCreateInput = {
    id?: string
    payment_id: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrowsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: paymentsUpdateOneRequiredWithoutEscrowsNestedInput
  }

  export type escrowsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrowsCreateManyInput = {
    id?: string
    payment_id: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrowsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrowsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_recordsCreateInput = {
    id?: string
    external_ref?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    ledger_entries?: escrow_ledgerCreateNestedManyWithoutEscrow_recordsInput
  }

  export type escrow_recordsUncheckedCreateInput = {
    id?: string
    external_ref?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    ledger_entries?: escrow_ledgerUncheckedCreateNestedManyWithoutEscrow_recordsInput
  }

  export type escrow_recordsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_ref?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger_entries?: escrow_ledgerUpdateManyWithoutEscrow_recordsNestedInput
  }

  export type escrow_recordsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_ref?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger_entries?: escrow_ledgerUncheckedUpdateManyWithoutEscrow_recordsNestedInput
  }

  export type escrow_recordsCreateManyInput = {
    id?: string
    external_ref?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_recordsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_ref?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_recordsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_ref?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_ledgerCreateInput = {
    id?: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    escrow_records: escrow_recordsCreateNestedOneWithoutLedger_entriesInput
  }

  export type escrow_ledgerUncheckedCreateInput = {
    id?: string
    escrow_id: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_ledgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    escrow_records?: escrow_recordsUpdateOneRequiredWithoutLedger_entriesNestedInput
  }

  export type escrow_ledgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrow_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_ledgerCreateManyInput = {
    id?: string
    escrow_id: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_ledgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_ledgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    escrow_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_transactionsCreateInput = {
    id?: string
    provider: string
    provider_tx_id: string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    logs?: transaction_logsCreateNestedManyWithoutProvider_transactionsInput
  }

  export type provider_transactionsUncheckedCreateInput = {
    id?: string
    provider: string
    provider_tx_id: string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    logs?: transaction_logsUncheckedCreateNestedManyWithoutProvider_transactionsInput
  }

  export type provider_transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_tx_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: transaction_logsUpdateManyWithoutProvider_transactionsNestedInput
  }

  export type provider_transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_tx_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: transaction_logsUncheckedUpdateManyWithoutProvider_transactionsNestedInput
  }

  export type provider_transactionsCreateManyInput = {
    id?: string
    provider: string
    provider_tx_id: string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type provider_transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_tx_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_tx_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaction_logsCreateInput = {
    id?: string
    action: string
    previous_status?: string | null
    new_status: string
    note?: string | null
    created_at?: Date | string
    provider_transactions: provider_transactionsCreateNestedOneWithoutLogsInput
  }

  export type transaction_logsUncheckedCreateInput = {
    id?: string
    provider_transaction_id: string
    action: string
    previous_status?: string | null
    new_status: string
    note?: string | null
    created_at?: Date | string
  }

  export type transaction_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    previous_status?: NullableStringFieldUpdateOperationsInput | string | null
    new_status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    provider_transactions?: provider_transactionsUpdateOneRequiredWithoutLogsNestedInput
  }

  export type transaction_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_transaction_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    previous_status?: NullableStringFieldUpdateOperationsInput | string | null
    new_status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaction_logsCreateManyInput = {
    id?: string
    provider_transaction_id: string
    action: string
    previous_status?: string | null
    new_status: string
    note?: string | null
    created_at?: Date | string
  }

  export type transaction_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    previous_status?: NullableStringFieldUpdateOperationsInput | string | null
    new_status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaction_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_transaction_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    previous_status?: NullableStringFieldUpdateOperationsInput | string | null
    new_status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksCreateInput = {
    id?: string
    job_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users_feedbacks_to_user_idTousers: usersCreateNestedOneWithoutFeedbacks_feedbacks_to_user_idTousersInput
    users_feedbacks_from_user_idTousers: usersCreateNestedOneWithoutFeedbacks_feedbacks_from_user_idTousersInput
  }

  export type feedbacksUncheckedCreateInput = {
    id?: string
    job_id: string
    from_user_id: string
    to_user_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbacksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_feedbacks_to_user_idTousers?: usersUpdateOneRequiredWithoutFeedbacks_feedbacks_to_user_idTousersNestedInput
    users_feedbacks_from_user_idTousers?: usersUpdateOneRequiredWithoutFeedbacks_feedbacks_from_user_idTousersNestedInput
  }

  export type feedbacksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksCreateManyInput = {
    id?: string
    job_id: string
    from_user_id: string
    to_user_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbacksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type health_recordsCreateInput = {
    id?: string
    record_type: $Enums.HealthRecordType
    title: string
    description?: string | null
    file_url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: string | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    is_archived?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    patients: patientsCreateNestedOneWithoutHealth_recordsInput
  }

  export type health_recordsUncheckedCreateInput = {
    id?: string
    patient_id: string
    record_type: $Enums.HealthRecordType
    title: string
    description?: string | null
    file_url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: string | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    is_archived?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type health_recordsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    record_type?: EnumHealthRecordTypeFieldUpdateOperationsInput | $Enums.HealthRecordType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: patientsUpdateOneRequiredWithoutHealth_recordsNestedInput
  }

  export type health_recordsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    record_type?: EnumHealthRecordTypeFieldUpdateOperationsInput | $Enums.HealthRecordType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type health_recordsCreateManyInput = {
    id?: string
    patient_id: string
    record_type: $Enums.HealthRecordType
    title: string
    description?: string | null
    file_url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: string | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    is_archived?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type health_recordsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    record_type?: EnumHealthRecordTypeFieldUpdateOperationsInput | $Enums.HealthRecordType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type health_recordsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    record_type?: EnumHealthRecordTypeFieldUpdateOperationsInput | $Enums.HealthRecordType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsCreateInput = {
    id?: string
    coverLetter?: string | null
    status?: string
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
    users?: usersCreateNestedOneWithoutJob_applicationsInput
    caregivers: caregiversCreateNestedOneWithoutJob_applicationsInput
    marketplace_jobs: marketplace_jobsCreateNestedOneWithoutJob_applicationsInput
  }

  export type job_applicationsUncheckedCreateInput = {
    id?: string
    marketplace_job_id: string
    caregiver_id: string
    coverLetter?: string | null
    status?: string
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type job_applicationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutJob_applicationsNestedInput
    caregivers?: caregiversUpdateOneRequiredWithoutJob_applicationsNestedInput
    marketplace_jobs?: marketplace_jobsUpdateOneRequiredWithoutJob_applicationsNestedInput
  }

  export type job_applicationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplace_job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsCreateManyInput = {
    id?: string
    marketplace_job_id: string
    caregiver_id: string
    coverLetter?: string | null
    status?: string
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type job_applicationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplace_job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsCreateInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsCreateManyInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type jobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type marketplace_jobsCreateInput = {
    id?: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_applications?: job_applicationsCreateNestedManyWithoutMarketplace_jobsInput
    caregivers?: caregiversCreateNestedOneWithoutMarketplace_jobsInput
    companies: companiesCreateNestedOneWithoutMarketplace_jobsInput
  }

  export type marketplace_jobsUncheckedCreateInput = {
    id?: string
    company_id: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_by?: string | null
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutMarketplace_jobsInput
  }

  export type marketplace_jobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_applications?: job_applicationsUpdateManyWithoutMarketplace_jobsNestedInput
    caregivers?: caregiversUpdateOneWithoutMarketplace_jobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutMarketplace_jobsNestedInput
  }

  export type marketplace_jobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_by?: NullableStringFieldUpdateOperationsInput | string | null
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_applications?: job_applicationsUncheckedUpdateManyWithoutMarketplace_jobsNestedInput
  }

  export type marketplace_jobsCreateManyInput = {
    id?: string
    company_id: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_by?: string | null
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type marketplace_jobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type marketplace_jobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_by?: NullableStringFieldUpdateOperationsInput | string | null
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    id?: string
    type: $Enums.NotificationType
    channel: string
    title?: string | null
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    error_message?: string | null
    createdAt?: Date | string
    users: usersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    channel: string
    title?: string | null
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    error_message?: string | null
    createdAt?: Date | string
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    channel: string
    title?: string | null
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    error_message?: string | null
    createdAt?: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type packagesCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
    jobs?: jobsCreateNestedManyWithoutPackagesInput
    companies: companiesCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateInput = {
    id?: string
    company_id: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
    jobs?: jobsUncheckedCreateNestedManyWithoutPackagesInput
  }

  export type packagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUpdateManyWithoutPackagesNestedInput
    companies?: companiesUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUncheckedUpdateManyWithoutPackagesNestedInput
  }

  export type packagesCreateManyInput = {
    id?: string
    company_id: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type packagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type packagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientsCreateInput = {
    id?: string
    user_id?: string | null
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsCreateNestedManyWithoutPatientsInput
    health_records?: health_recordsCreateNestedManyWithoutPatientsInput
    jobs?: jobsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
  }

  export type patientsUncheckedCreateInput = {
    id?: string
    user_id?: string | null
    guardian_id: string
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutPatientsInput
    health_records?: health_recordsUncheckedCreateNestedManyWithoutPatientsInput
    jobs?: jobsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUpdateManyWithoutPatientsNestedInput
    health_records?: health_recordsUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutPatientsNestedInput
    health_records?: health_recordsUncheckedUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patientsCreateManyInput = {
    id?: string
    user_id?: string | null
    guardian_id: string
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type patientsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    escrows?: escrowsCreateNestedOneWithoutPaymentsInput
    users: usersCreateNestedOneWithoutPaymentsInput
    jobs?: jobsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: string
    job_id?: string | null
    payer_id: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    escrows?: escrowsUncheckedCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    escrows?: escrowsUpdateOneWithoutPaymentsNestedInput
    users?: usersUpdateOneRequiredWithoutPaymentsNestedInput
    jobs?: jobsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    payer_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    escrows?: escrowsUncheckedUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsCreateManyInput = {
    id?: string
    job_id?: string | null
    payer_id: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type paymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    payer_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type scheduled_tasksCreateInput = {
    id?: string
    task_type: string
    job_id?: string | null
    execute_at: Date | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    executedAt?: Date | string | null
    status?: string
  }

  export type scheduled_tasksUncheckedCreateInput = {
    id?: string
    task_type: string
    job_id?: string | null
    execute_at: Date | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    executedAt?: Date | string | null
    status?: string
  }

  export type scheduled_tasksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_type?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    execute_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type scheduled_tasksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_type?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    execute_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type scheduled_tasksCreateManyInput = {
    id?: string
    task_type: string
    job_id?: string | null
    execute_at: Date | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    executedAt?: Date | string | null
    status?: string
  }

  export type scheduled_tasksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_type?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    execute_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type scheduled_tasksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_type?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    execute_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type service_zonesCreateInput = {
    id?: string
    zone_name: string
    region_code: string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies: companiesCreateNestedOneWithoutService_zonesInput
  }

  export type service_zonesUncheckedCreateInput = {
    id?: string
    company_id: string
    zone_name: string
    region_code: string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_zonesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone_name?: StringFieldUpdateOperationsInput | string
    region_code?: StringFieldUpdateOperationsInput | string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutService_zonesNestedInput
  }

  export type service_zonesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    zone_name?: StringFieldUpdateOperationsInput | string
    region_code?: StringFieldUpdateOperationsInput | string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_zonesCreateManyInput = {
    id?: string
    company_id: string
    zone_name: string
    region_code: string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_zonesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone_name?: StringFieldUpdateOperationsInput | string
    region_code?: StringFieldUpdateOperationsInput | string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_zonesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    zone_name?: StringFieldUpdateOperationsInput | string
    region_code?: StringFieldUpdateOperationsInput | string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesCreateInput = {
    id?: string
    device_id: string
    fcm_token: string
    platform: string
    app_version?: string | null
    is_active?: boolean
    last_seen_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutUser_devicesInput
  }

  export type user_devicesUncheckedCreateInput = {
    id?: string
    user_id: string
    device_id: string
    fcm_token: string
    platform: string
    app_version?: string | null
    is_active?: boolean
    last_seen_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_devicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    fcm_token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    app_version?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    last_seen_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUser_devicesNestedInput
  }

  export type user_devicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    fcm_token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    app_version?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    last_seen_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesCreateManyInput = {
    id?: string
    user_id: string
    device_id: string
    fcm_token: string
    platform: string
    app_version?: string | null
    is_active?: boolean
    last_seen_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_devicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    fcm_token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    app_version?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    last_seen_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    fcm_token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    app_version?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    last_seen_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_codesCreateInput = {
    id?: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users: usersCreateNestedOneWithoutVerification_codesInput
  }

  export type verification_codesUncheckedCreateInput = {
    id?: string
    userId: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type verification_codesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutVerification_codesNestedInput
  }

  export type verification_codesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_codesCreateManyInput = {
    id?: string
    userId: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type verification_codesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_codesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAssignmentRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleFilter<$PrismaModel> | $Enums.AssignmentRole
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CaregiversNullableScalarRelationFilter = {
    is?: caregiversWhereInput | null
    isNot?: caregiversWhereInput | null
  }

  export type CaregiversScalarRelationFilter = {
    is?: caregiversWhereInput
    isNot?: caregiversWhereInput
  }

  export type JobsScalarRelationFilter = {
    is?: jobsWhereInput
    isNot?: jobsWhereInput
  }

  export type Care_logsListRelationFilter = {
    every?: care_logsWhereInput
    some?: care_logsWhereInput
    none?: care_logsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type care_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type assignmentsJob_idCaregiver_idRoleCompoundUniqueInput = {
    job_id: string
    caregiver_id: string
    role: $Enums.AssignmentRole
  }

  export type assignmentsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
    shift_start_time?: SortOrder
    shift_end_time?: SortOrder
    days_of_week?: SortOrder
    status?: SortOrder
    replaced_by?: SortOrder
    replacement_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type assignmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
    shift_start_time?: SortOrder
    shift_end_time?: SortOrder
    status?: SortOrder
    replaced_by?: SortOrder
    replacement_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type assignmentsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    caregiver_id?: SortOrder
    role?: SortOrder
    shift_start_time?: SortOrder
    shift_end_time?: SortOrder
    status?: SortOrder
    replaced_by?: SortOrder
    replacement_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAssignmentRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentRoleFilter<$PrismaModel>
    _max?: NestedEnumAssignmentRoleFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type audit_logsCountOrderByAggregateInput = {
    id?: SortOrder
    actor_id?: SortOrder
    actor_role?: SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    changes?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    timestamp?: SortOrder
  }

  export type audit_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    actor_id?: SortOrder
    actor_role?: SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    timestamp?: SortOrder
  }

  export type audit_logsMinOrderByAggregateInput = {
    id?: SortOrder
    actor_id?: SortOrder
    actor_role?: SortOrder
    action_type?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    timestamp?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCareLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareLogType | EnumCareLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareLogTypeFilter<$PrismaModel> | $Enums.CareLogType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PatientsScalarRelationFilter = {
    is?: patientsWhereInput
    isNot?: patientsWhereInput
  }

  export type AssignmentsNullableScalarRelationFilter = {
    is?: assignmentsWhereInput | null
    isNot?: assignmentsWhereInput | null
  }

  export type care_logsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    assignment_id?: SortOrder
    caregiver_id?: SortOrder
    patient_id?: SortOrder
    log_type?: SortOrder
    timestamp?: SortOrder
    location_lat?: SortOrder
    location_lng?: SortOrder
    data?: SortOrder
    notes?: SortOrder
    photo_urls?: SortOrder
    guardian_notified?: SortOrder
    createdAt?: SortOrder
  }

  export type care_logsAvgOrderByAggregateInput = {
    location_lat?: SortOrder
    location_lng?: SortOrder
  }

  export type care_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    assignment_id?: SortOrder
    caregiver_id?: SortOrder
    patient_id?: SortOrder
    log_type?: SortOrder
    timestamp?: SortOrder
    location_lat?: SortOrder
    location_lng?: SortOrder
    notes?: SortOrder
    guardian_notified?: SortOrder
    createdAt?: SortOrder
  }

  export type care_logsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    assignment_id?: SortOrder
    caregiver_id?: SortOrder
    patient_id?: SortOrder
    log_type?: SortOrder
    timestamp?: SortOrder
    location_lat?: SortOrder
    location_lng?: SortOrder
    notes?: SortOrder
    guardian_notified?: SortOrder
    createdAt?: SortOrder
  }

  export type care_logsSumOrderByAggregateInput = {
    location_lat?: SortOrder
    location_lng?: SortOrder
  }

  export type EnumCareLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareLogType | EnumCareLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareLogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareLogTypeFilter<$PrismaModel>
    _max?: NestedEnumCareLogTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumBackgroundCheckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCheckStatus | EnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCheckStatusFilter<$PrismaModel> | $Enums.BackgroundCheckStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AssignmentsListRelationFilter = {
    every?: assignmentsWhereInput
    some?: assignmentsWhereInput
    none?: assignmentsWhereInput
  }

  export type CompaniesNullableScalarRelationFilter = {
    is?: companiesWhereInput | null
    isNot?: companiesWhereInput | null
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type Job_applicationsListRelationFilter = {
    every?: job_applicationsWhereInput
    some?: job_applicationsWhereInput
    none?: job_applicationsWhereInput
  }

  export type Marketplace_jobsListRelationFilter = {
    every?: marketplace_jobsWhereInput
    some?: marketplace_jobsWhereInput
    none?: marketplace_jobsWhereInput
  }

  export type assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type job_applicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marketplace_jobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type caregiversCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company_id?: SortOrder
    nid?: SortOrder
    nid_url?: SortOrder
    photo_url?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    location_lat?: SortOrder
    location_lng?: SortOrder
    skills?: SortOrder
    certifications?: SortOrder
    experience_years?: SortOrder
    languages?: SortOrder
    availabilityCalendar?: SortOrder
    hourly_rate?: SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    total_jobs_completed?: SortOrder
    is_available?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type caregiversAvgOrderByAggregateInput = {
    location_lat?: SortOrder
    location_lng?: SortOrder
    experience_years?: SortOrder
    hourly_rate?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    total_jobs_completed?: SortOrder
  }

  export type caregiversMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company_id?: SortOrder
    nid?: SortOrder
    nid_url?: SortOrder
    photo_url?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    location_lat?: SortOrder
    location_lng?: SortOrder
    experience_years?: SortOrder
    hourly_rate?: SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    total_jobs_completed?: SortOrder
    is_available?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type caregiversMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company_id?: SortOrder
    nid?: SortOrder
    nid_url?: SortOrder
    photo_url?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    location_lat?: SortOrder
    location_lng?: SortOrder
    experience_years?: SortOrder
    hourly_rate?: SortOrder
    background_check_status?: SortOrder
    background_check_date?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    total_jobs_completed?: SortOrder
    is_available?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type caregiversSumOrderByAggregateInput = {
    location_lat?: SortOrder
    location_lng?: SortOrder
    experience_years?: SortOrder
    hourly_rate?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    total_jobs_completed?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumBackgroundCheckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCheckStatus | EnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCheckStatusWithAggregatesFilter<$PrismaModel> | $Enums.BackgroundCheckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackgroundCheckStatusFilter<$PrismaModel>
    _max?: NestedEnumBackgroundCheckStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPayoutMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodFilter<$PrismaModel> | $Enums.PayoutMethod
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type CaregiversListRelationFilter = {
    every?: caregiversWhereInput
    some?: caregiversWhereInput
    none?: caregiversWhereInput
  }

  export type JobsListRelationFilter = {
    every?: jobsWhereInput
    some?: jobsWhereInput
    none?: jobsWhereInput
  }

  export type PackagesListRelationFilter = {
    every?: packagesWhereInput
    some?: packagesWhereInput
    none?: packagesWhereInput
  }

  export type Service_zonesListRelationFilter = {
    every?: service_zonesWhereInput
    some?: service_zonesWhereInput
    none?: service_zonesWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type caregiversOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type packagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_zonesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company_name?: SortOrder
    trade_license?: SortOrder
    trade_license_url?: SortOrder
    tin?: SortOrder
    contact_person?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrder
    address?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    specializations?: SortOrder
    payout_method?: SortOrder
    payout_account?: SortOrder
    commission_rate?: SortOrder
    subscription_tier?: SortOrder
    subscription_expires_at?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    commission_rate?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company_name?: SortOrder
    trade_license?: SortOrder
    trade_license_url?: SortOrder
    tin?: SortOrder
    contact_person?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrder
    address?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    payout_method?: SortOrder
    payout_account?: SortOrder
    commission_rate?: SortOrder
    subscription_tier?: SortOrder
    subscription_expires_at?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company_name?: SortOrder
    trade_license?: SortOrder
    trade_license_url?: SortOrder
    tin?: SortOrder
    contact_person?: SortOrder
    contact_phone?: SortOrder
    contact_email?: SortOrder
    address?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    payout_method?: SortOrder
    payout_account?: SortOrder
    commission_rate?: SortOrder
    subscription_tier?: SortOrder
    subscription_expires_at?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
    is_verified?: SortOrder
    verification_notes?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    commission_rate?: SortOrder
    rating_avg?: SortOrder
    rating_count?: SortOrder
  }

  export type EnumPayoutMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodWithAggregatesFilter<$PrismaModel> | $Enums.PayoutMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutMethodFilter<$PrismaModel>
    _max?: NestedEnumPayoutMethodFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type EnumDisputeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeFilter<$PrismaModel> | $Enums.DisputeType
  }

  export type EnumDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusFilter<$PrismaModel> | $Enums.DisputeStatus
  }

  export type disputesCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    raised_by?: SortOrder
    against?: SortOrder
    dispute_type?: SortOrder
    description?: SortOrder
    evidence_urls?: SortOrder
    status?: SortOrder
    assigned_moderator?: SortOrder
    resolution?: SortOrder
    resolution_action?: SortOrder
    resolved_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type disputesMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    raised_by?: SortOrder
    against?: SortOrder
    dispute_type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    assigned_moderator?: SortOrder
    resolution?: SortOrder
    resolution_action?: SortOrder
    resolved_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type disputesMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    raised_by?: SortOrder
    against?: SortOrder
    dispute_type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    assigned_moderator?: SortOrder
    resolution?: SortOrder
    resolution_action?: SortOrder
    resolved_at?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDisputeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeWithAggregatesFilter<$PrismaModel> | $Enums.DisputeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeTypeFilter<$PrismaModel>
    _max?: NestedEnumDisputeTypeFilter<$PrismaModel>
  }

  export type EnumDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumDisputeStatusFilter<$PrismaModel>
  }

  export type PaymentsScalarRelationFilter = {
    is?: paymentsWhereInput
    isNot?: paymentsWhereInput
  }

  export type escrowsCountOrderByAggregateInput = {
    id?: SortOrder
    payment_id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    released_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrowsAvgOrderByAggregateInput = {
    amount?: SortOrder
    fee?: SortOrder
  }

  export type escrowsMaxOrderByAggregateInput = {
    id?: SortOrder
    payment_id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    released_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrowsMinOrderByAggregateInput = {
    id?: SortOrder
    payment_id?: SortOrder
    amount?: SortOrder
    fee?: SortOrder
    status?: SortOrder
    released_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrowsSumOrderByAggregateInput = {
    amount?: SortOrder
    fee?: SortOrder
  }

  export type Escrow_ledgerListRelationFilter = {
    every?: escrow_ledgerWhereInput
    some?: escrow_ledgerWhereInput
    none?: escrow_ledgerWhereInput
  }

  export type escrow_ledgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type escrow_recordsCountOrderByAggregateInput = {
    id?: SortOrder
    external_ref?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    released_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrow_recordsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type escrow_recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    external_ref?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    released_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrow_recordsMinOrderByAggregateInput = {
    id?: SortOrder
    external_ref?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    released_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrow_recordsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Escrow_recordsScalarRelationFilter = {
    is?: escrow_recordsWhereInput
    isNot?: escrow_recordsWhereInput
  }

  export type escrow_ledgerCountOrderByAggregateInput = {
    id?: SortOrder
    escrow_id?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrow_ledgerAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type escrow_ledgerMaxOrderByAggregateInput = {
    id?: SortOrder
    escrow_id?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrow_ledgerMinOrderByAggregateInput = {
    id?: SortOrder
    escrow_id?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type escrow_ledgerSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Transaction_logsListRelationFilter = {
    every?: transaction_logsWhereInput
    some?: transaction_logsWhereInput
    none?: transaction_logsWhereInput
  }

  export type transaction_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provider_transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    provider_tx_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    payload?: SortOrder
    escrow_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type provider_transactionsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type provider_transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    provider_tx_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    escrow_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type provider_transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    provider_tx_id?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    escrow_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type provider_transactionsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Provider_transactionsScalarRelationFilter = {
    is?: provider_transactionsWhereInput
    isNot?: provider_transactionsWhereInput
  }

  export type transaction_logsCountOrderByAggregateInput = {
    id?: SortOrder
    provider_transaction_id?: SortOrder
    action?: SortOrder
    previous_status?: SortOrder
    new_status?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type transaction_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    provider_transaction_id?: SortOrder
    action?: SortOrder
    previous_status?: SortOrder
    new_status?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type transaction_logsMinOrderByAggregateInput = {
    id?: SortOrder
    provider_transaction_id?: SortOrder
    action?: SortOrder
    previous_status?: SortOrder
    new_status?: SortOrder
    note?: SortOrder
    created_at?: SortOrder
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type feedbacksJob_idFrom_user_idTo_user_idCompoundUniqueInput = {
    job_id: string
    from_user_id: string
    to_user_id: string
  }

  export type feedbacksCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    reviewee_type?: SortOrder
    rating?: SortOrder
    tags?: SortOrder
    comments?: SortOrder
    is_public?: SortOrder
    company_response?: SortOrder
    responded_at?: SortOrder
    flagged_inappropriate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbacksAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type feedbacksMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    reviewee_type?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    is_public?: SortOrder
    company_response?: SortOrder
    responded_at?: SortOrder
    flagged_inappropriate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbacksMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    from_user_id?: SortOrder
    to_user_id?: SortOrder
    reviewee_type?: SortOrder
    rating?: SortOrder
    comments?: SortOrder
    is_public?: SortOrder
    company_response?: SortOrder
    responded_at?: SortOrder
    flagged_inappropriate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type feedbacksSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type EnumHealthRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthRecordType | EnumHealthRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthRecordTypeFilter<$PrismaModel> | $Enums.HealthRecordType
  }

  export type health_recordsCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    record_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_url?: SortOrder
    metadata?: SortOrder
    uploaded_by?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
    is_archived?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type health_recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    record_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_url?: SortOrder
    uploaded_by?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
    is_archived?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type health_recordsMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    record_type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_url?: SortOrder
    uploaded_by?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
    is_archived?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumHealthRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthRecordType | EnumHealthRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.HealthRecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumHealthRecordTypeFilter<$PrismaModel>
  }

  export type Marketplace_jobsScalarRelationFilter = {
    is?: marketplace_jobsWhereInput
    isNot?: marketplace_jobsWhereInput
  }

  export type job_applicationsMarketplace_job_idCaregiver_idCompoundUniqueInput = {
    marketplace_job_id: string
    caregiver_id: string
  }

  export type job_applicationsCountOrderByAggregateInput = {
    id?: SortOrder
    marketplace_job_id?: SortOrder
    caregiver_id?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    reviewed_at?: SortOrder
    review_notes?: SortOrder
    created_at?: SortOrder
  }

  export type job_applicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    marketplace_job_id?: SortOrder
    caregiver_id?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    reviewed_at?: SortOrder
    review_notes?: SortOrder
    created_at?: SortOrder
  }

  export type job_applicationsMinOrderByAggregateInput = {
    id?: SortOrder
    marketplace_job_id?: SortOrder
    caregiver_id?: SortOrder
    coverLetter?: SortOrder
    status?: SortOrder
    reviewed_by?: SortOrder
    reviewed_at?: SortOrder
    review_notes?: SortOrder
    created_at?: SortOrder
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type DisputesListRelationFilter = {
    every?: disputesWhereInput
    some?: disputesWhereInput
    none?: disputesWhereInput
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type PackagesScalarRelationFilter = {
    is?: packagesWhereInput
    isNot?: packagesWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type disputesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobsCountOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    patient_id?: SortOrder
    company_id?: SortOrder
    guardian_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    total_price?: SortOrder
    commission_amount?: SortOrder
    payout_amount?: SortOrder
    special_instructions?: SortOrder
    completion_notes?: SortOrder
    cancelled_reason?: SortOrder
    cancelled_at?: SortOrder
    cancelled_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type jobsAvgOrderByAggregateInput = {
    total_price?: SortOrder
    commission_amount?: SortOrder
    payout_amount?: SortOrder
  }

  export type jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    patient_id?: SortOrder
    company_id?: SortOrder
    guardian_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    total_price?: SortOrder
    commission_amount?: SortOrder
    payout_amount?: SortOrder
    special_instructions?: SortOrder
    completion_notes?: SortOrder
    cancelled_reason?: SortOrder
    cancelled_at?: SortOrder
    cancelled_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type jobsMinOrderByAggregateInput = {
    id?: SortOrder
    package_id?: SortOrder
    patient_id?: SortOrder
    company_id?: SortOrder
    guardian_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    total_price?: SortOrder
    commission_amount?: SortOrder
    payout_amount?: SortOrder
    special_instructions?: SortOrder
    completion_notes?: SortOrder
    cancelled_reason?: SortOrder
    cancelled_at?: SortOrder
    cancelled_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type jobsSumOrderByAggregateInput = {
    total_price?: SortOrder
    commission_amount?: SortOrder
    payout_amount?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type marketplace_jobsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    required_skills?: SortOrder
    start_date?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    offered_rate?: SortOrder
    status?: SortOrder
    applications_count?: SortOrder
    filled_by?: SortOrder
    filled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type marketplace_jobsAvgOrderByAggregateInput = {
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    offered_rate?: SortOrder
    applications_count?: SortOrder
  }

  export type marketplace_jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    offered_rate?: SortOrder
    status?: SortOrder
    applications_count?: SortOrder
    filled_by?: SortOrder
    filled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type marketplace_jobsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    offered_rate?: SortOrder
    status?: SortOrder
    applications_count?: SortOrder
    filled_by?: SortOrder
    filled_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type marketplace_jobsSumOrderByAggregateInput = {
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    offered_rate?: SortOrder
    applications_count?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    status?: SortOrder
    sent_at?: SortOrder
    delivered_at?: SortOrder
    read_at?: SortOrder
    error_message?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sent_at?: SortOrder
    delivered_at?: SortOrder
    read_at?: SortOrder
    error_message?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    channel?: SortOrder
    title?: SortOrder
    body?: SortOrder
    status?: SortOrder
    sent_at?: SortOrder
    delivered_at?: SortOrder
    read_at?: SortOrder
    error_message?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumPackageCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageCategory | EnumPackageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageCategoryFilter<$PrismaModel> | $Enums.PackageCategory
  }

  export type packagesCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    inclusions?: SortOrder
    exclusions?: SortOrder
    caregiver_count?: SortOrder
    is_active?: SortOrder
    min_advance_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type packagesAvgOrderByAggregateInput = {
    price?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    caregiver_count?: SortOrder
    min_advance_days?: SortOrder
  }

  export type packagesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    caregiver_count?: SortOrder
    is_active?: SortOrder
    min_advance_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type packagesMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    caregiver_count?: SortOrder
    is_active?: SortOrder
    min_advance_days?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type packagesSumOrderByAggregateInput = {
    price?: SortOrder
    duration_days?: SortOrder
    hours_per_day?: SortOrder
    caregiver_count?: SortOrder
    min_advance_days?: SortOrder
  }

  export type EnumPackageCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageCategory | EnumPackageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PackageCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackageCategoryFilter<$PrismaModel>
    _max?: NestedEnumPackageCategoryFilter<$PrismaModel>
  }

  export type EnumMobilityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.MobilityLevel | EnumMobilityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMobilityLevelFilter<$PrismaModel> | $Enums.MobilityLevel
  }

  export type EnumCognitiveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CognitiveStatus | EnumCognitiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCognitiveStatusFilter<$PrismaModel> | $Enums.CognitiveStatus
  }

  export type Health_recordsListRelationFilter = {
    every?: health_recordsWhereInput
    some?: health_recordsWhereInput
    none?: health_recordsWhereInput
  }

  export type health_recordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type patientsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    guardian_id?: SortOrder
    name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    blood_group?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_phone?: SortOrder
    primaryConditions?: SortOrder
    allergies?: SortOrder
    mobility_level?: SortOrder
    cognitive_status?: SortOrder
    photoUrl?: SortOrder
    consent_data_sharing?: SortOrder
    consent_marketing?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type patientsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    guardian_id?: SortOrder
    name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    blood_group?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_phone?: SortOrder
    allergies?: SortOrder
    mobility_level?: SortOrder
    cognitive_status?: SortOrder
    photoUrl?: SortOrder
    consent_data_sharing?: SortOrder
    consent_marketing?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type patientsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    guardian_id?: SortOrder
    name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    blood_group?: SortOrder
    address?: SortOrder
    emergency_contact_name?: SortOrder
    emergency_contact_phone?: SortOrder
    allergies?: SortOrder
    mobility_level?: SortOrder
    cognitive_status?: SortOrder
    photoUrl?: SortOrder
    consent_data_sharing?: SortOrder
    consent_marketing?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMobilityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MobilityLevel | EnumMobilityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMobilityLevelWithAggregatesFilter<$PrismaModel> | $Enums.MobilityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMobilityLevelFilter<$PrismaModel>
    _max?: NestedEnumMobilityLevelFilter<$PrismaModel>
  }

  export type EnumCognitiveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CognitiveStatus | EnumCognitiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCognitiveStatusWithAggregatesFilter<$PrismaModel> | $Enums.CognitiveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCognitiveStatusFilter<$PrismaModel>
    _max?: NestedEnumCognitiveStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EscrowsNullableScalarRelationFilter = {
    is?: escrowsWhereInput | null
    isNot?: escrowsWhereInput | null
  }

  export type JobsNullableScalarRelationFilter = {
    is?: jobsWhereInput | null
    isNot?: jobsWhereInput | null
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    payer_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
    invoice_url?: SortOrder
    receipt_url?: SortOrder
    paid_at?: SortOrder
    refund_amount?: SortOrder
    refund_reason?: SortOrder
    gatewayResponse?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    amount?: SortOrder
    refund_amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    payer_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
    invoice_url?: SortOrder
    receipt_url?: SortOrder
    paid_at?: SortOrder
    refund_amount?: SortOrder
    refund_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    job_id?: SortOrder
    payer_id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    invoice_number?: SortOrder
    invoice_url?: SortOrder
    receipt_url?: SortOrder
    paid_at?: SortOrder
    refund_amount?: SortOrder
    refund_reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    amount?: SortOrder
    refund_amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type scheduled_tasksCountOrderByAggregateInput = {
    id?: SortOrder
    task_type?: SortOrder
    job_id?: SortOrder
    execute_at?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
  }

  export type scheduled_tasksMaxOrderByAggregateInput = {
    id?: SortOrder
    task_type?: SortOrder
    job_id?: SortOrder
    execute_at?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
  }

  export type scheduled_tasksMinOrderByAggregateInput = {
    id?: SortOrder
    task_type?: SortOrder
    job_id?: SortOrder
    execute_at?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
  }

  export type service_zonesCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    zone_name?: SortOrder
    region_code?: SortOrder
    boundary_geojson?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_zonesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    zone_name?: SortOrder
    region_code?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type service_zonesMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    zone_name?: SortOrder
    region_code?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_devicesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    fcm_token?: SortOrder
    platform?: SortOrder
    app_version?: SortOrder
    is_active?: SortOrder
    last_seen_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_devicesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    fcm_token?: SortOrder
    platform?: SortOrder
    app_version?: SortOrder
    is_active?: SortOrder
    last_seen_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type user_devicesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    device_id?: SortOrder
    fcm_token?: SortOrder
    platform?: SortOrder
    app_version?: SortOrder
    is_active?: SortOrder
    last_seen_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type verification_codesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verification_codesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type verification_codesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type Audit_logsListRelationFilter = {
    every?: audit_logsWhereInput
    some?: audit_logsWhereInput
    none?: audit_logsWhereInput
  }

  export type FeedbacksListRelationFilter = {
    every?: feedbacksWhereInput
    some?: feedbacksWhereInput
    none?: feedbacksWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type PatientsListRelationFilter = {
    every?: patientsWhereInput
    some?: patientsWhereInput
    none?: patientsWhereInput
  }

  export type User_devicesListRelationFilter = {
    every?: user_devicesWhereInput
    some?: user_devicesWhereInput
    none?: user_devicesWhereInput
  }

  export type Verification_codesListRelationFilter = {
    every?: verification_codesWhereInput
    some?: verification_codesWhereInput
    none?: verification_codesWhereInput
  }

  export type audit_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type feedbacksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type patientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_devicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type verification_codesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    language?: SortOrder
    kyc_status?: SortOrder
    kyc_document_url?: SortOrder
    mfa_enabled?: SortOrder
    mfa_secret?: SortOrder
    last_login_at?: SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    language?: SortOrder
    kyc_status?: SortOrder
    kyc_document_url?: SortOrder
    mfa_enabled?: SortOrder
    mfa_secret?: SortOrder
    last_login_at?: SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company_id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    language?: SortOrder
    kyc_status?: SortOrder
    kyc_document_url?: SortOrder
    mfa_enabled?: SortOrder
    mfa_secret?: SortOrder
    last_login_at?: SortOrder
    is_active?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    company_id?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type caregiversCreateNestedOneWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    create?: XOR<caregiversCreateWithoutAssignments_assignments_replaced_byTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_replaced_byTocaregiversInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutAssignments_assignments_replaced_byTocaregiversInput
    connect?: caregiversWhereUniqueInput
  }

  export type caregiversCreateNestedOneWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    create?: XOR<caregiversCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutAssignments_assignments_caregiver_idTocaregiversInput
    connect?: caregiversWhereUniqueInput
  }

  export type jobsCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<jobsCreateWithoutAssignmentsInput, jobsUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutAssignmentsInput
    connect?: jobsWhereUniqueInput
  }

  export type care_logsCreateNestedManyWithoutAssignmentsInput = {
    create?: XOR<care_logsCreateWithoutAssignmentsInput, care_logsUncheckedCreateWithoutAssignmentsInput> | care_logsCreateWithoutAssignmentsInput[] | care_logsUncheckedCreateWithoutAssignmentsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutAssignmentsInput | care_logsCreateOrConnectWithoutAssignmentsInput[]
    createMany?: care_logsCreateManyAssignmentsInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type care_logsUncheckedCreateNestedManyWithoutAssignmentsInput = {
    create?: XOR<care_logsCreateWithoutAssignmentsInput, care_logsUncheckedCreateWithoutAssignmentsInput> | care_logsCreateWithoutAssignmentsInput[] | care_logsUncheckedCreateWithoutAssignmentsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutAssignmentsInput | care_logsCreateOrConnectWithoutAssignmentsInput[]
    createMany?: care_logsCreateManyAssignmentsInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAssignmentRoleFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentRole
  }

  export type EnumAssignmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type caregiversUpdateOneWithoutAssignments_assignments_replaced_byTocaregiversNestedInput = {
    create?: XOR<caregiversCreateWithoutAssignments_assignments_replaced_byTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_replaced_byTocaregiversInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutAssignments_assignments_replaced_byTocaregiversInput
    upsert?: caregiversUpsertWithoutAssignments_assignments_replaced_byTocaregiversInput
    disconnect?: caregiversWhereInput | boolean
    delete?: caregiversWhereInput | boolean
    connect?: caregiversWhereUniqueInput
    update?: XOR<XOR<caregiversUpdateToOneWithWhereWithoutAssignments_assignments_replaced_byTocaregiversInput, caregiversUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput>, caregiversUncheckedUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput>
  }

  export type caregiversUpdateOneRequiredWithoutAssignments_assignments_caregiver_idTocaregiversNestedInput = {
    create?: XOR<caregiversCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutAssignments_assignments_caregiver_idTocaregiversInput
    upsert?: caregiversUpsertWithoutAssignments_assignments_caregiver_idTocaregiversInput
    connect?: caregiversWhereUniqueInput
    update?: XOR<XOR<caregiversUpdateToOneWithWhereWithoutAssignments_assignments_caregiver_idTocaregiversInput, caregiversUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput>, caregiversUncheckedUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput>
  }

  export type jobsUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<jobsCreateWithoutAssignmentsInput, jobsUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutAssignmentsInput
    upsert?: jobsUpsertWithoutAssignmentsInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutAssignmentsInput, jobsUpdateWithoutAssignmentsInput>, jobsUncheckedUpdateWithoutAssignmentsInput>
  }

  export type care_logsUpdateManyWithoutAssignmentsNestedInput = {
    create?: XOR<care_logsCreateWithoutAssignmentsInput, care_logsUncheckedCreateWithoutAssignmentsInput> | care_logsCreateWithoutAssignmentsInput[] | care_logsUncheckedCreateWithoutAssignmentsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutAssignmentsInput | care_logsCreateOrConnectWithoutAssignmentsInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutAssignmentsInput | care_logsUpsertWithWhereUniqueWithoutAssignmentsInput[]
    createMany?: care_logsCreateManyAssignmentsInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutAssignmentsInput | care_logsUpdateWithWhereUniqueWithoutAssignmentsInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutAssignmentsInput | care_logsUpdateManyWithWhereWithoutAssignmentsInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type care_logsUncheckedUpdateManyWithoutAssignmentsNestedInput = {
    create?: XOR<care_logsCreateWithoutAssignmentsInput, care_logsUncheckedCreateWithoutAssignmentsInput> | care_logsCreateWithoutAssignmentsInput[] | care_logsUncheckedCreateWithoutAssignmentsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutAssignmentsInput | care_logsCreateOrConnectWithoutAssignmentsInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutAssignmentsInput | care_logsUpsertWithWhereUniqueWithoutAssignmentsInput[]
    createMany?: care_logsCreateManyAssignmentsInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutAssignmentsInput | care_logsUpdateWithWhereUniqueWithoutAssignmentsInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutAssignmentsInput | care_logsUpdateManyWithWhereWithoutAssignmentsInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutAudit_logsInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutAudit_logsNestedInput = {
    create?: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAudit_logsInput
    upsert?: usersUpsertWithoutAudit_logsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAudit_logsInput, usersUpdateWithoutAudit_logsInput>, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type patientsCreateNestedOneWithoutCare_logsInput = {
    create?: XOR<patientsCreateWithoutCare_logsInput, patientsUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutCare_logsInput
    connect?: patientsWhereUniqueInput
  }

  export type caregiversCreateNestedOneWithoutCare_logsInput = {
    create?: XOR<caregiversCreateWithoutCare_logsInput, caregiversUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutCare_logsInput
    connect?: caregiversWhereUniqueInput
  }

  export type assignmentsCreateNestedOneWithoutCare_logsInput = {
    create?: XOR<assignmentsCreateWithoutCare_logsInput, assignmentsUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: assignmentsCreateOrConnectWithoutCare_logsInput
    connect?: assignmentsWhereUniqueInput
  }

  export type jobsCreateNestedOneWithoutCare_logsInput = {
    create?: XOR<jobsCreateWithoutCare_logsInput, jobsUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutCare_logsInput
    connect?: jobsWhereUniqueInput
  }

  export type EnumCareLogTypeFieldUpdateOperationsInput = {
    set?: $Enums.CareLogType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type patientsUpdateOneRequiredWithoutCare_logsNestedInput = {
    create?: XOR<patientsCreateWithoutCare_logsInput, patientsUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutCare_logsInput
    upsert?: patientsUpsertWithoutCare_logsInput
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutCare_logsInput, patientsUpdateWithoutCare_logsInput>, patientsUncheckedUpdateWithoutCare_logsInput>
  }

  export type caregiversUpdateOneRequiredWithoutCare_logsNestedInput = {
    create?: XOR<caregiversCreateWithoutCare_logsInput, caregiversUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutCare_logsInput
    upsert?: caregiversUpsertWithoutCare_logsInput
    connect?: caregiversWhereUniqueInput
    update?: XOR<XOR<caregiversUpdateToOneWithWhereWithoutCare_logsInput, caregiversUpdateWithoutCare_logsInput>, caregiversUncheckedUpdateWithoutCare_logsInput>
  }

  export type assignmentsUpdateOneWithoutCare_logsNestedInput = {
    create?: XOR<assignmentsCreateWithoutCare_logsInput, assignmentsUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: assignmentsCreateOrConnectWithoutCare_logsInput
    upsert?: assignmentsUpsertWithoutCare_logsInput
    disconnect?: assignmentsWhereInput | boolean
    delete?: assignmentsWhereInput | boolean
    connect?: assignmentsWhereUniqueInput
    update?: XOR<XOR<assignmentsUpdateToOneWithWhereWithoutCare_logsInput, assignmentsUpdateWithoutCare_logsInput>, assignmentsUncheckedUpdateWithoutCare_logsInput>
  }

  export type jobsUpdateOneRequiredWithoutCare_logsNestedInput = {
    create?: XOR<jobsCreateWithoutCare_logsInput, jobsUncheckedCreateWithoutCare_logsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutCare_logsInput
    upsert?: jobsUpsertWithoutCare_logsInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutCare_logsInput, jobsUpdateWithoutCare_logsInput>, jobsUncheckedUpdateWithoutCare_logsInput>
  }

  export type assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type care_logsCreateNestedManyWithoutCaregiversInput = {
    create?: XOR<care_logsCreateWithoutCaregiversInput, care_logsUncheckedCreateWithoutCaregiversInput> | care_logsCreateWithoutCaregiversInput[] | care_logsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutCaregiversInput | care_logsCreateOrConnectWithoutCaregiversInput[]
    createMany?: care_logsCreateManyCaregiversInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type companiesCreateNestedOneWithoutCaregiversInput = {
    create?: XOR<companiesCreateWithoutCaregiversInput, companiesUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCaregiversInput
    connect?: companiesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCaregiversInput = {
    create?: XOR<usersCreateWithoutCaregiversInput, usersUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: usersCreateOrConnectWithoutCaregiversInput
    connect?: usersWhereUniqueInput
  }

  export type job_applicationsCreateNestedManyWithoutCaregiversInput = {
    create?: XOR<job_applicationsCreateWithoutCaregiversInput, job_applicationsUncheckedCreateWithoutCaregiversInput> | job_applicationsCreateWithoutCaregiversInput[] | job_applicationsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutCaregiversInput | job_applicationsCreateOrConnectWithoutCaregiversInput[]
    createMany?: job_applicationsCreateManyCaregiversInputEnvelope
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
  }

  export type marketplace_jobsCreateNestedManyWithoutCaregiversInput = {
    create?: XOR<marketplace_jobsCreateWithoutCaregiversInput, marketplace_jobsUncheckedCreateWithoutCaregiversInput> | marketplace_jobsCreateWithoutCaregiversInput[] | marketplace_jobsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCaregiversInput | marketplace_jobsCreateOrConnectWithoutCaregiversInput[]
    createMany?: marketplace_jobsCreateManyCaregiversInputEnvelope
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
  }

  export type assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type care_logsUncheckedCreateNestedManyWithoutCaregiversInput = {
    create?: XOR<care_logsCreateWithoutCaregiversInput, care_logsUncheckedCreateWithoutCaregiversInput> | care_logsCreateWithoutCaregiversInput[] | care_logsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutCaregiversInput | care_logsCreateOrConnectWithoutCaregiversInput[]
    createMany?: care_logsCreateManyCaregiversInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput = {
    create?: XOR<job_applicationsCreateWithoutCaregiversInput, job_applicationsUncheckedCreateWithoutCaregiversInput> | job_applicationsCreateWithoutCaregiversInput[] | job_applicationsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutCaregiversInput | job_applicationsCreateOrConnectWithoutCaregiversInput[]
    createMany?: job_applicationsCreateManyCaregiversInputEnvelope
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
  }

  export type marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput = {
    create?: XOR<marketplace_jobsCreateWithoutCaregiversInput, marketplace_jobsUncheckedCreateWithoutCaregiversInput> | marketplace_jobsCreateWithoutCaregiversInput[] | marketplace_jobsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCaregiversInput | marketplace_jobsCreateOrConnectWithoutCaregiversInput[]
    createMany?: marketplace_jobsCreateManyCaregiversInputEnvelope
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBackgroundCheckStatusFieldUpdateOperationsInput = {
    set?: $Enums.BackgroundCheckStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type care_logsUpdateManyWithoutCaregiversNestedInput = {
    create?: XOR<care_logsCreateWithoutCaregiversInput, care_logsUncheckedCreateWithoutCaregiversInput> | care_logsCreateWithoutCaregiversInput[] | care_logsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutCaregiversInput | care_logsCreateOrConnectWithoutCaregiversInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutCaregiversInput | care_logsUpsertWithWhereUniqueWithoutCaregiversInput[]
    createMany?: care_logsCreateManyCaregiversInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutCaregiversInput | care_logsUpdateWithWhereUniqueWithoutCaregiversInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutCaregiversInput | care_logsUpdateManyWithWhereWithoutCaregiversInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type companiesUpdateOneWithoutCaregiversNestedInput = {
    create?: XOR<companiesCreateWithoutCaregiversInput, companiesUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCaregiversInput
    upsert?: companiesUpsertWithoutCaregiversInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCaregiversInput, companiesUpdateWithoutCaregiversInput>, companiesUncheckedUpdateWithoutCaregiversInput>
  }

  export type usersUpdateOneRequiredWithoutCaregiversNestedInput = {
    create?: XOR<usersCreateWithoutCaregiversInput, usersUncheckedCreateWithoutCaregiversInput>
    connectOrCreate?: usersCreateOrConnectWithoutCaregiversInput
    upsert?: usersUpsertWithoutCaregiversInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCaregiversInput, usersUpdateWithoutCaregiversInput>, usersUncheckedUpdateWithoutCaregiversInput>
  }

  export type job_applicationsUpdateManyWithoutCaregiversNestedInput = {
    create?: XOR<job_applicationsCreateWithoutCaregiversInput, job_applicationsUncheckedCreateWithoutCaregiversInput> | job_applicationsCreateWithoutCaregiversInput[] | job_applicationsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutCaregiversInput | job_applicationsCreateOrConnectWithoutCaregiversInput[]
    upsert?: job_applicationsUpsertWithWhereUniqueWithoutCaregiversInput | job_applicationsUpsertWithWhereUniqueWithoutCaregiversInput[]
    createMany?: job_applicationsCreateManyCaregiversInputEnvelope
    set?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    disconnect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    delete?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    update?: job_applicationsUpdateWithWhereUniqueWithoutCaregiversInput | job_applicationsUpdateWithWhereUniqueWithoutCaregiversInput[]
    updateMany?: job_applicationsUpdateManyWithWhereWithoutCaregiversInput | job_applicationsUpdateManyWithWhereWithoutCaregiversInput[]
    deleteMany?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
  }

  export type marketplace_jobsUpdateManyWithoutCaregiversNestedInput = {
    create?: XOR<marketplace_jobsCreateWithoutCaregiversInput, marketplace_jobsUncheckedCreateWithoutCaregiversInput> | marketplace_jobsCreateWithoutCaregiversInput[] | marketplace_jobsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCaregiversInput | marketplace_jobsCreateOrConnectWithoutCaregiversInput[]
    upsert?: marketplace_jobsUpsertWithWhereUniqueWithoutCaregiversInput | marketplace_jobsUpsertWithWhereUniqueWithoutCaregiversInput[]
    createMany?: marketplace_jobsCreateManyCaregiversInputEnvelope
    set?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    disconnect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    delete?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    update?: marketplace_jobsUpdateWithWhereUniqueWithoutCaregiversInput | marketplace_jobsUpdateWithWhereUniqueWithoutCaregiversInput[]
    updateMany?: marketplace_jobsUpdateManyWithWhereWithoutCaregiversInput | marketplace_jobsUpdateManyWithWhereWithoutCaregiversInput[]
    deleteMany?: marketplace_jobsScalarWhereInput | marketplace_jobsScalarWhereInput[]
  }

  export type assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_replaced_byTocaregiversInput | assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_replaced_byTocaregiversInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput = {
    create?: XOR<assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput> | assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[] | assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    createMany?: assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_caregiver_idTocaregiversInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type care_logsUncheckedUpdateManyWithoutCaregiversNestedInput = {
    create?: XOR<care_logsCreateWithoutCaregiversInput, care_logsUncheckedCreateWithoutCaregiversInput> | care_logsCreateWithoutCaregiversInput[] | care_logsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutCaregiversInput | care_logsCreateOrConnectWithoutCaregiversInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutCaregiversInput | care_logsUpsertWithWhereUniqueWithoutCaregiversInput[]
    createMany?: care_logsCreateManyCaregiversInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutCaregiversInput | care_logsUpdateWithWhereUniqueWithoutCaregiversInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutCaregiversInput | care_logsUpdateManyWithWhereWithoutCaregiversInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput = {
    create?: XOR<job_applicationsCreateWithoutCaregiversInput, job_applicationsUncheckedCreateWithoutCaregiversInput> | job_applicationsCreateWithoutCaregiversInput[] | job_applicationsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutCaregiversInput | job_applicationsCreateOrConnectWithoutCaregiversInput[]
    upsert?: job_applicationsUpsertWithWhereUniqueWithoutCaregiversInput | job_applicationsUpsertWithWhereUniqueWithoutCaregiversInput[]
    createMany?: job_applicationsCreateManyCaregiversInputEnvelope
    set?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    disconnect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    delete?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    update?: job_applicationsUpdateWithWhereUniqueWithoutCaregiversInput | job_applicationsUpdateWithWhereUniqueWithoutCaregiversInput[]
    updateMany?: job_applicationsUpdateManyWithWhereWithoutCaregiversInput | job_applicationsUpdateManyWithWhereWithoutCaregiversInput[]
    deleteMany?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
  }

  export type marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput = {
    create?: XOR<marketplace_jobsCreateWithoutCaregiversInput, marketplace_jobsUncheckedCreateWithoutCaregiversInput> | marketplace_jobsCreateWithoutCaregiversInput[] | marketplace_jobsUncheckedCreateWithoutCaregiversInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCaregiversInput | marketplace_jobsCreateOrConnectWithoutCaregiversInput[]
    upsert?: marketplace_jobsUpsertWithWhereUniqueWithoutCaregiversInput | marketplace_jobsUpsertWithWhereUniqueWithoutCaregiversInput[]
    createMany?: marketplace_jobsCreateManyCaregiversInputEnvelope
    set?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    disconnect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    delete?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    update?: marketplace_jobsUpdateWithWhereUniqueWithoutCaregiversInput | marketplace_jobsUpdateWithWhereUniqueWithoutCaregiversInput[]
    updateMany?: marketplace_jobsUpdateManyWithWhereWithoutCaregiversInput | marketplace_jobsUpdateManyWithWhereWithoutCaregiversInput[]
    deleteMany?: marketplace_jobsScalarWhereInput | marketplace_jobsScalarWhereInput[]
  }

  export type caregiversCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<caregiversCreateWithoutCompaniesInput, caregiversUncheckedCreateWithoutCompaniesInput> | caregiversCreateWithoutCompaniesInput[] | caregiversUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: caregiversCreateOrConnectWithoutCompaniesInput | caregiversCreateOrConnectWithoutCompaniesInput[]
    createMany?: caregiversCreateManyCompaniesInputEnvelope
    connect?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
  }

  export type jobsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<jobsCreateWithoutCompaniesInput, jobsUncheckedCreateWithoutCompaniesInput> | jobsCreateWithoutCompaniesInput[] | jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCompaniesInput | jobsCreateOrConnectWithoutCompaniesInput[]
    createMany?: jobsCreateManyCompaniesInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type marketplace_jobsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<marketplace_jobsCreateWithoutCompaniesInput, marketplace_jobsUncheckedCreateWithoutCompaniesInput> | marketplace_jobsCreateWithoutCompaniesInput[] | marketplace_jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCompaniesInput | marketplace_jobsCreateOrConnectWithoutCompaniesInput[]
    createMany?: marketplace_jobsCreateManyCompaniesInputEnvelope
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
  }

  export type packagesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<packagesCreateWithoutCompaniesInput, packagesUncheckedCreateWithoutCompaniesInput> | packagesCreateWithoutCompaniesInput[] | packagesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutCompaniesInput | packagesCreateOrConnectWithoutCompaniesInput[]
    createMany?: packagesCreateManyCompaniesInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type service_zonesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<service_zonesCreateWithoutCompaniesInput, service_zonesUncheckedCreateWithoutCompaniesInput> | service_zonesCreateWithoutCompaniesInput[] | service_zonesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: service_zonesCreateOrConnectWithoutCompaniesInput | service_zonesCreateOrConnectWithoutCompaniesInput[]
    createMany?: service_zonesCreateManyCompaniesInputEnvelope
    connect?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type caregiversUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<caregiversCreateWithoutCompaniesInput, caregiversUncheckedCreateWithoutCompaniesInput> | caregiversCreateWithoutCompaniesInput[] | caregiversUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: caregiversCreateOrConnectWithoutCompaniesInput | caregiversCreateOrConnectWithoutCompaniesInput[]
    createMany?: caregiversCreateManyCompaniesInputEnvelope
    connect?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
  }

  export type jobsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<jobsCreateWithoutCompaniesInput, jobsUncheckedCreateWithoutCompaniesInput> | jobsCreateWithoutCompaniesInput[] | jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCompaniesInput | jobsCreateOrConnectWithoutCompaniesInput[]
    createMany?: jobsCreateManyCompaniesInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type marketplace_jobsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<marketplace_jobsCreateWithoutCompaniesInput, marketplace_jobsUncheckedCreateWithoutCompaniesInput> | marketplace_jobsCreateWithoutCompaniesInput[] | marketplace_jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCompaniesInput | marketplace_jobsCreateOrConnectWithoutCompaniesInput[]
    createMany?: marketplace_jobsCreateManyCompaniesInputEnvelope
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
  }

  export type packagesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<packagesCreateWithoutCompaniesInput, packagesUncheckedCreateWithoutCompaniesInput> | packagesCreateWithoutCompaniesInput[] | packagesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutCompaniesInput | packagesCreateOrConnectWithoutCompaniesInput[]
    createMany?: packagesCreateManyCompaniesInputEnvelope
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
  }

  export type service_zonesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<service_zonesCreateWithoutCompaniesInput, service_zonesUncheckedCreateWithoutCompaniesInput> | service_zonesCreateWithoutCompaniesInput[] | service_zonesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: service_zonesCreateOrConnectWithoutCompaniesInput | service_zonesCreateOrConnectWithoutCompaniesInput[]
    createMany?: service_zonesCreateManyCompaniesInputEnvelope
    connect?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type EnumPayoutMethodFieldUpdateOperationsInput = {
    set?: $Enums.PayoutMethod
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type caregiversUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<caregiversCreateWithoutCompaniesInput, caregiversUncheckedCreateWithoutCompaniesInput> | caregiversCreateWithoutCompaniesInput[] | caregiversUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: caregiversCreateOrConnectWithoutCompaniesInput | caregiversCreateOrConnectWithoutCompaniesInput[]
    upsert?: caregiversUpsertWithWhereUniqueWithoutCompaniesInput | caregiversUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: caregiversCreateManyCompaniesInputEnvelope
    set?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    disconnect?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    delete?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    connect?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    update?: caregiversUpdateWithWhereUniqueWithoutCompaniesInput | caregiversUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: caregiversUpdateManyWithWhereWithoutCompaniesInput | caregiversUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: caregiversScalarWhereInput | caregiversScalarWhereInput[]
  }

  export type jobsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<jobsCreateWithoutCompaniesInput, jobsUncheckedCreateWithoutCompaniesInput> | jobsCreateWithoutCompaniesInput[] | jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCompaniesInput | jobsCreateOrConnectWithoutCompaniesInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutCompaniesInput | jobsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: jobsCreateManyCompaniesInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutCompaniesInput | jobsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutCompaniesInput | jobsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type marketplace_jobsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<marketplace_jobsCreateWithoutCompaniesInput, marketplace_jobsUncheckedCreateWithoutCompaniesInput> | marketplace_jobsCreateWithoutCompaniesInput[] | marketplace_jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCompaniesInput | marketplace_jobsCreateOrConnectWithoutCompaniesInput[]
    upsert?: marketplace_jobsUpsertWithWhereUniqueWithoutCompaniesInput | marketplace_jobsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: marketplace_jobsCreateManyCompaniesInputEnvelope
    set?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    disconnect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    delete?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    update?: marketplace_jobsUpdateWithWhereUniqueWithoutCompaniesInput | marketplace_jobsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: marketplace_jobsUpdateManyWithWhereWithoutCompaniesInput | marketplace_jobsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: marketplace_jobsScalarWhereInput | marketplace_jobsScalarWhereInput[]
  }

  export type packagesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<packagesCreateWithoutCompaniesInput, packagesUncheckedCreateWithoutCompaniesInput> | packagesCreateWithoutCompaniesInput[] | packagesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutCompaniesInput | packagesCreateOrConnectWithoutCompaniesInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutCompaniesInput | packagesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: packagesCreateManyCompaniesInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutCompaniesInput | packagesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutCompaniesInput | packagesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type service_zonesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<service_zonesCreateWithoutCompaniesInput, service_zonesUncheckedCreateWithoutCompaniesInput> | service_zonesCreateWithoutCompaniesInput[] | service_zonesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: service_zonesCreateOrConnectWithoutCompaniesInput | service_zonesCreateOrConnectWithoutCompaniesInput[]
    upsert?: service_zonesUpsertWithWhereUniqueWithoutCompaniesInput | service_zonesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: service_zonesCreateManyCompaniesInputEnvelope
    set?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    disconnect?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    delete?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    connect?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    update?: service_zonesUpdateWithWhereUniqueWithoutCompaniesInput | service_zonesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: service_zonesUpdateManyWithWhereWithoutCompaniesInput | service_zonesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: service_zonesScalarWhereInput | service_zonesScalarWhereInput[]
  }

  export type usersUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutCompaniesInput | usersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutCompaniesInput | usersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutCompaniesInput | usersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type caregiversUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<caregiversCreateWithoutCompaniesInput, caregiversUncheckedCreateWithoutCompaniesInput> | caregiversCreateWithoutCompaniesInput[] | caregiversUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: caregiversCreateOrConnectWithoutCompaniesInput | caregiversCreateOrConnectWithoutCompaniesInput[]
    upsert?: caregiversUpsertWithWhereUniqueWithoutCompaniesInput | caregiversUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: caregiversCreateManyCompaniesInputEnvelope
    set?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    disconnect?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    delete?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    connect?: caregiversWhereUniqueInput | caregiversWhereUniqueInput[]
    update?: caregiversUpdateWithWhereUniqueWithoutCompaniesInput | caregiversUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: caregiversUpdateManyWithWhereWithoutCompaniesInput | caregiversUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: caregiversScalarWhereInput | caregiversScalarWhereInput[]
  }

  export type jobsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<jobsCreateWithoutCompaniesInput, jobsUncheckedCreateWithoutCompaniesInput> | jobsCreateWithoutCompaniesInput[] | jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCompaniesInput | jobsCreateOrConnectWithoutCompaniesInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutCompaniesInput | jobsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: jobsCreateManyCompaniesInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutCompaniesInput | jobsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutCompaniesInput | jobsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type marketplace_jobsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<marketplace_jobsCreateWithoutCompaniesInput, marketplace_jobsUncheckedCreateWithoutCompaniesInput> | marketplace_jobsCreateWithoutCompaniesInput[] | marketplace_jobsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutCompaniesInput | marketplace_jobsCreateOrConnectWithoutCompaniesInput[]
    upsert?: marketplace_jobsUpsertWithWhereUniqueWithoutCompaniesInput | marketplace_jobsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: marketplace_jobsCreateManyCompaniesInputEnvelope
    set?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    disconnect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    delete?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    connect?: marketplace_jobsWhereUniqueInput | marketplace_jobsWhereUniqueInput[]
    update?: marketplace_jobsUpdateWithWhereUniqueWithoutCompaniesInput | marketplace_jobsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: marketplace_jobsUpdateManyWithWhereWithoutCompaniesInput | marketplace_jobsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: marketplace_jobsScalarWhereInput | marketplace_jobsScalarWhereInput[]
  }

  export type packagesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<packagesCreateWithoutCompaniesInput, packagesUncheckedCreateWithoutCompaniesInput> | packagesCreateWithoutCompaniesInput[] | packagesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: packagesCreateOrConnectWithoutCompaniesInput | packagesCreateOrConnectWithoutCompaniesInput[]
    upsert?: packagesUpsertWithWhereUniqueWithoutCompaniesInput | packagesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: packagesCreateManyCompaniesInputEnvelope
    set?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    disconnect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    delete?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    connect?: packagesWhereUniqueInput | packagesWhereUniqueInput[]
    update?: packagesUpdateWithWhereUniqueWithoutCompaniesInput | packagesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: packagesUpdateManyWithWhereWithoutCompaniesInput | packagesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: packagesScalarWhereInput | packagesScalarWhereInput[]
  }

  export type service_zonesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<service_zonesCreateWithoutCompaniesInput, service_zonesUncheckedCreateWithoutCompaniesInput> | service_zonesCreateWithoutCompaniesInput[] | service_zonesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: service_zonesCreateOrConnectWithoutCompaniesInput | service_zonesCreateOrConnectWithoutCompaniesInput[]
    upsert?: service_zonesUpsertWithWhereUniqueWithoutCompaniesInput | service_zonesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: service_zonesCreateManyCompaniesInputEnvelope
    set?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    disconnect?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    delete?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    connect?: service_zonesWhereUniqueInput | service_zonesWhereUniqueInput[]
    update?: service_zonesUpdateWithWhereUniqueWithoutCompaniesInput | service_zonesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: service_zonesUpdateManyWithWhereWithoutCompaniesInput | service_zonesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: service_zonesScalarWhereInput | service_zonesScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutCompaniesInput | usersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutCompaniesInput | usersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutCompaniesInput | usersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutDisputes_disputes_againstTousersInput = {
    create?: XOR<usersCreateWithoutDisputes_disputes_againstTousersInput, usersUncheckedCreateWithoutDisputes_disputes_againstTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutDisputes_disputes_againstTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutDisputes_disputes_raised_byTousersInput = {
    create?: XOR<usersCreateWithoutDisputes_disputes_raised_byTousersInput, usersUncheckedCreateWithoutDisputes_disputes_raised_byTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutDisputes_disputes_raised_byTousersInput
    connect?: usersWhereUniqueInput
  }

  export type jobsCreateNestedOneWithoutDisputesInput = {
    create?: XOR<jobsCreateWithoutDisputesInput, jobsUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: jobsCreateOrConnectWithoutDisputesInput
    connect?: jobsWhereUniqueInput
  }

  export type EnumDisputeTypeFieldUpdateOperationsInput = {
    set?: $Enums.DisputeType
  }

  export type EnumDisputeStatusFieldUpdateOperationsInput = {
    set?: $Enums.DisputeStatus
  }

  export type usersUpdateOneRequiredWithoutDisputes_disputes_againstTousersNestedInput = {
    create?: XOR<usersCreateWithoutDisputes_disputes_againstTousersInput, usersUncheckedCreateWithoutDisputes_disputes_againstTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutDisputes_disputes_againstTousersInput
    upsert?: usersUpsertWithoutDisputes_disputes_againstTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDisputes_disputes_againstTousersInput, usersUpdateWithoutDisputes_disputes_againstTousersInput>, usersUncheckedUpdateWithoutDisputes_disputes_againstTousersInput>
  }

  export type usersUpdateOneRequiredWithoutDisputes_disputes_raised_byTousersNestedInput = {
    create?: XOR<usersCreateWithoutDisputes_disputes_raised_byTousersInput, usersUncheckedCreateWithoutDisputes_disputes_raised_byTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutDisputes_disputes_raised_byTousersInput
    upsert?: usersUpsertWithoutDisputes_disputes_raised_byTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDisputes_disputes_raised_byTousersInput, usersUpdateWithoutDisputes_disputes_raised_byTousersInput>, usersUncheckedUpdateWithoutDisputes_disputes_raised_byTousersInput>
  }

  export type jobsUpdateOneRequiredWithoutDisputesNestedInput = {
    create?: XOR<jobsCreateWithoutDisputesInput, jobsUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: jobsCreateOrConnectWithoutDisputesInput
    upsert?: jobsUpsertWithoutDisputesInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutDisputesInput, jobsUpdateWithoutDisputesInput>, jobsUncheckedUpdateWithoutDisputesInput>
  }

  export type paymentsCreateNestedOneWithoutEscrowsInput = {
    create?: XOR<paymentsCreateWithoutEscrowsInput, paymentsUncheckedCreateWithoutEscrowsInput>
    connectOrCreate?: paymentsCreateOrConnectWithoutEscrowsInput
    connect?: paymentsWhereUniqueInput
  }

  export type paymentsUpdateOneRequiredWithoutEscrowsNestedInput = {
    create?: XOR<paymentsCreateWithoutEscrowsInput, paymentsUncheckedCreateWithoutEscrowsInput>
    connectOrCreate?: paymentsCreateOrConnectWithoutEscrowsInput
    upsert?: paymentsUpsertWithoutEscrowsInput
    connect?: paymentsWhereUniqueInput
    update?: XOR<XOR<paymentsUpdateToOneWithWhereWithoutEscrowsInput, paymentsUpdateWithoutEscrowsInput>, paymentsUncheckedUpdateWithoutEscrowsInput>
  }

  export type escrow_ledgerCreateNestedManyWithoutEscrow_recordsInput = {
    create?: XOR<escrow_ledgerCreateWithoutEscrow_recordsInput, escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput> | escrow_ledgerCreateWithoutEscrow_recordsInput[] | escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput[]
    connectOrCreate?: escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput | escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput[]
    createMany?: escrow_ledgerCreateManyEscrow_recordsInputEnvelope
    connect?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
  }

  export type escrow_ledgerUncheckedCreateNestedManyWithoutEscrow_recordsInput = {
    create?: XOR<escrow_ledgerCreateWithoutEscrow_recordsInput, escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput> | escrow_ledgerCreateWithoutEscrow_recordsInput[] | escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput[]
    connectOrCreate?: escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput | escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput[]
    createMany?: escrow_ledgerCreateManyEscrow_recordsInputEnvelope
    connect?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
  }

  export type escrow_ledgerUpdateManyWithoutEscrow_recordsNestedInput = {
    create?: XOR<escrow_ledgerCreateWithoutEscrow_recordsInput, escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput> | escrow_ledgerCreateWithoutEscrow_recordsInput[] | escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput[]
    connectOrCreate?: escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput | escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput[]
    upsert?: escrow_ledgerUpsertWithWhereUniqueWithoutEscrow_recordsInput | escrow_ledgerUpsertWithWhereUniqueWithoutEscrow_recordsInput[]
    createMany?: escrow_ledgerCreateManyEscrow_recordsInputEnvelope
    set?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    disconnect?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    delete?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    connect?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    update?: escrow_ledgerUpdateWithWhereUniqueWithoutEscrow_recordsInput | escrow_ledgerUpdateWithWhereUniqueWithoutEscrow_recordsInput[]
    updateMany?: escrow_ledgerUpdateManyWithWhereWithoutEscrow_recordsInput | escrow_ledgerUpdateManyWithWhereWithoutEscrow_recordsInput[]
    deleteMany?: escrow_ledgerScalarWhereInput | escrow_ledgerScalarWhereInput[]
  }

  export type escrow_ledgerUncheckedUpdateManyWithoutEscrow_recordsNestedInput = {
    create?: XOR<escrow_ledgerCreateWithoutEscrow_recordsInput, escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput> | escrow_ledgerCreateWithoutEscrow_recordsInput[] | escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput[]
    connectOrCreate?: escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput | escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput[]
    upsert?: escrow_ledgerUpsertWithWhereUniqueWithoutEscrow_recordsInput | escrow_ledgerUpsertWithWhereUniqueWithoutEscrow_recordsInput[]
    createMany?: escrow_ledgerCreateManyEscrow_recordsInputEnvelope
    set?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    disconnect?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    delete?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    connect?: escrow_ledgerWhereUniqueInput | escrow_ledgerWhereUniqueInput[]
    update?: escrow_ledgerUpdateWithWhereUniqueWithoutEscrow_recordsInput | escrow_ledgerUpdateWithWhereUniqueWithoutEscrow_recordsInput[]
    updateMany?: escrow_ledgerUpdateManyWithWhereWithoutEscrow_recordsInput | escrow_ledgerUpdateManyWithWhereWithoutEscrow_recordsInput[]
    deleteMany?: escrow_ledgerScalarWhereInput | escrow_ledgerScalarWhereInput[]
  }

  export type escrow_recordsCreateNestedOneWithoutLedger_entriesInput = {
    create?: XOR<escrow_recordsCreateWithoutLedger_entriesInput, escrow_recordsUncheckedCreateWithoutLedger_entriesInput>
    connectOrCreate?: escrow_recordsCreateOrConnectWithoutLedger_entriesInput
    connect?: escrow_recordsWhereUniqueInput
  }

  export type escrow_recordsUpdateOneRequiredWithoutLedger_entriesNestedInput = {
    create?: XOR<escrow_recordsCreateWithoutLedger_entriesInput, escrow_recordsUncheckedCreateWithoutLedger_entriesInput>
    connectOrCreate?: escrow_recordsCreateOrConnectWithoutLedger_entriesInput
    upsert?: escrow_recordsUpsertWithoutLedger_entriesInput
    connect?: escrow_recordsWhereUniqueInput
    update?: XOR<XOR<escrow_recordsUpdateToOneWithWhereWithoutLedger_entriesInput, escrow_recordsUpdateWithoutLedger_entriesInput>, escrow_recordsUncheckedUpdateWithoutLedger_entriesInput>
  }

  export type transaction_logsCreateNestedManyWithoutProvider_transactionsInput = {
    create?: XOR<transaction_logsCreateWithoutProvider_transactionsInput, transaction_logsUncheckedCreateWithoutProvider_transactionsInput> | transaction_logsCreateWithoutProvider_transactionsInput[] | transaction_logsUncheckedCreateWithoutProvider_transactionsInput[]
    connectOrCreate?: transaction_logsCreateOrConnectWithoutProvider_transactionsInput | transaction_logsCreateOrConnectWithoutProvider_transactionsInput[]
    createMany?: transaction_logsCreateManyProvider_transactionsInputEnvelope
    connect?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
  }

  export type transaction_logsUncheckedCreateNestedManyWithoutProvider_transactionsInput = {
    create?: XOR<transaction_logsCreateWithoutProvider_transactionsInput, transaction_logsUncheckedCreateWithoutProvider_transactionsInput> | transaction_logsCreateWithoutProvider_transactionsInput[] | transaction_logsUncheckedCreateWithoutProvider_transactionsInput[]
    connectOrCreate?: transaction_logsCreateOrConnectWithoutProvider_transactionsInput | transaction_logsCreateOrConnectWithoutProvider_transactionsInput[]
    createMany?: transaction_logsCreateManyProvider_transactionsInputEnvelope
    connect?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
  }

  export type transaction_logsUpdateManyWithoutProvider_transactionsNestedInput = {
    create?: XOR<transaction_logsCreateWithoutProvider_transactionsInput, transaction_logsUncheckedCreateWithoutProvider_transactionsInput> | transaction_logsCreateWithoutProvider_transactionsInput[] | transaction_logsUncheckedCreateWithoutProvider_transactionsInput[]
    connectOrCreate?: transaction_logsCreateOrConnectWithoutProvider_transactionsInput | transaction_logsCreateOrConnectWithoutProvider_transactionsInput[]
    upsert?: transaction_logsUpsertWithWhereUniqueWithoutProvider_transactionsInput | transaction_logsUpsertWithWhereUniqueWithoutProvider_transactionsInput[]
    createMany?: transaction_logsCreateManyProvider_transactionsInputEnvelope
    set?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    disconnect?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    delete?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    connect?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    update?: transaction_logsUpdateWithWhereUniqueWithoutProvider_transactionsInput | transaction_logsUpdateWithWhereUniqueWithoutProvider_transactionsInput[]
    updateMany?: transaction_logsUpdateManyWithWhereWithoutProvider_transactionsInput | transaction_logsUpdateManyWithWhereWithoutProvider_transactionsInput[]
    deleteMany?: transaction_logsScalarWhereInput | transaction_logsScalarWhereInput[]
  }

  export type transaction_logsUncheckedUpdateManyWithoutProvider_transactionsNestedInput = {
    create?: XOR<transaction_logsCreateWithoutProvider_transactionsInput, transaction_logsUncheckedCreateWithoutProvider_transactionsInput> | transaction_logsCreateWithoutProvider_transactionsInput[] | transaction_logsUncheckedCreateWithoutProvider_transactionsInput[]
    connectOrCreate?: transaction_logsCreateOrConnectWithoutProvider_transactionsInput | transaction_logsCreateOrConnectWithoutProvider_transactionsInput[]
    upsert?: transaction_logsUpsertWithWhereUniqueWithoutProvider_transactionsInput | transaction_logsUpsertWithWhereUniqueWithoutProvider_transactionsInput[]
    createMany?: transaction_logsCreateManyProvider_transactionsInputEnvelope
    set?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    disconnect?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    delete?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    connect?: transaction_logsWhereUniqueInput | transaction_logsWhereUniqueInput[]
    update?: transaction_logsUpdateWithWhereUniqueWithoutProvider_transactionsInput | transaction_logsUpdateWithWhereUniqueWithoutProvider_transactionsInput[]
    updateMany?: transaction_logsUpdateManyWithWhereWithoutProvider_transactionsInput | transaction_logsUpdateManyWithWhereWithoutProvider_transactionsInput[]
    deleteMany?: transaction_logsScalarWhereInput | transaction_logsScalarWhereInput[]
  }

  export type provider_transactionsCreateNestedOneWithoutLogsInput = {
    create?: XOR<provider_transactionsCreateWithoutLogsInput, provider_transactionsUncheckedCreateWithoutLogsInput>
    connectOrCreate?: provider_transactionsCreateOrConnectWithoutLogsInput
    connect?: provider_transactionsWhereUniqueInput
  }

  export type provider_transactionsUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<provider_transactionsCreateWithoutLogsInput, provider_transactionsUncheckedCreateWithoutLogsInput>
    connectOrCreate?: provider_transactionsCreateOrConnectWithoutLogsInput
    upsert?: provider_transactionsUpsertWithoutLogsInput
    connect?: provider_transactionsWhereUniqueInput
    update?: XOR<XOR<provider_transactionsUpdateToOneWithWhereWithoutLogsInput, provider_transactionsUpdateWithoutLogsInput>, provider_transactionsUncheckedUpdateWithoutLogsInput>
  }

  export type usersCreateNestedOneWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    create?: XOR<usersCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacks_feedbacks_to_user_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    create?: XOR<usersCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacks_feedbacks_from_user_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type usersUpdateOneRequiredWithoutFeedbacks_feedbacks_to_user_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacks_feedbacks_to_user_idTousersInput
    upsert?: usersUpsertWithoutFeedbacks_feedbacks_to_user_idTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFeedbacks_feedbacks_to_user_idTousersInput, usersUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput>, usersUncheckedUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput>
  }

  export type usersUpdateOneRequiredWithoutFeedbacks_feedbacks_from_user_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacks_feedbacks_from_user_idTousersInput
    upsert?: usersUpsertWithoutFeedbacks_feedbacks_from_user_idTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFeedbacks_feedbacks_from_user_idTousersInput, usersUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput>, usersUncheckedUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput>
  }

  export type patientsCreateNestedOneWithoutHealth_recordsInput = {
    create?: XOR<patientsCreateWithoutHealth_recordsInput, patientsUncheckedCreateWithoutHealth_recordsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutHealth_recordsInput
    connect?: patientsWhereUniqueInput
  }

  export type EnumHealthRecordTypeFieldUpdateOperationsInput = {
    set?: $Enums.HealthRecordType
  }

  export type patientsUpdateOneRequiredWithoutHealth_recordsNestedInput = {
    create?: XOR<patientsCreateWithoutHealth_recordsInput, patientsUncheckedCreateWithoutHealth_recordsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutHealth_recordsInput
    upsert?: patientsUpsertWithoutHealth_recordsInput
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutHealth_recordsInput, patientsUpdateWithoutHealth_recordsInput>, patientsUncheckedUpdateWithoutHealth_recordsInput>
  }

  export type usersCreateNestedOneWithoutJob_applicationsInput = {
    create?: XOR<usersCreateWithoutJob_applicationsInput, usersUncheckedCreateWithoutJob_applicationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutJob_applicationsInput
    connect?: usersWhereUniqueInput
  }

  export type caregiversCreateNestedOneWithoutJob_applicationsInput = {
    create?: XOR<caregiversCreateWithoutJob_applicationsInput, caregiversUncheckedCreateWithoutJob_applicationsInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutJob_applicationsInput
    connect?: caregiversWhereUniqueInput
  }

  export type marketplace_jobsCreateNestedOneWithoutJob_applicationsInput = {
    create?: XOR<marketplace_jobsCreateWithoutJob_applicationsInput, marketplace_jobsUncheckedCreateWithoutJob_applicationsInput>
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutJob_applicationsInput
    connect?: marketplace_jobsWhereUniqueInput
  }

  export type usersUpdateOneWithoutJob_applicationsNestedInput = {
    create?: XOR<usersCreateWithoutJob_applicationsInput, usersUncheckedCreateWithoutJob_applicationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutJob_applicationsInput
    upsert?: usersUpsertWithoutJob_applicationsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutJob_applicationsInput, usersUpdateWithoutJob_applicationsInput>, usersUncheckedUpdateWithoutJob_applicationsInput>
  }

  export type caregiversUpdateOneRequiredWithoutJob_applicationsNestedInput = {
    create?: XOR<caregiversCreateWithoutJob_applicationsInput, caregiversUncheckedCreateWithoutJob_applicationsInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutJob_applicationsInput
    upsert?: caregiversUpsertWithoutJob_applicationsInput
    connect?: caregiversWhereUniqueInput
    update?: XOR<XOR<caregiversUpdateToOneWithWhereWithoutJob_applicationsInput, caregiversUpdateWithoutJob_applicationsInput>, caregiversUncheckedUpdateWithoutJob_applicationsInput>
  }

  export type marketplace_jobsUpdateOneRequiredWithoutJob_applicationsNestedInput = {
    create?: XOR<marketplace_jobsCreateWithoutJob_applicationsInput, marketplace_jobsUncheckedCreateWithoutJob_applicationsInput>
    connectOrCreate?: marketplace_jobsCreateOrConnectWithoutJob_applicationsInput
    upsert?: marketplace_jobsUpsertWithoutJob_applicationsInput
    connect?: marketplace_jobsWhereUniqueInput
    update?: XOR<XOR<marketplace_jobsUpdateToOneWithWhereWithoutJob_applicationsInput, marketplace_jobsUpdateWithoutJob_applicationsInput>, marketplace_jobsUncheckedUpdateWithoutJob_applicationsInput>
  }

  export type assignmentsCreateNestedManyWithoutJobsInput = {
    create?: XOR<assignmentsCreateWithoutJobsInput, assignmentsUncheckedCreateWithoutJobsInput> | assignmentsCreateWithoutJobsInput[] | assignmentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutJobsInput | assignmentsCreateOrConnectWithoutJobsInput[]
    createMany?: assignmentsCreateManyJobsInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type care_logsCreateNestedManyWithoutJobsInput = {
    create?: XOR<care_logsCreateWithoutJobsInput, care_logsUncheckedCreateWithoutJobsInput> | care_logsCreateWithoutJobsInput[] | care_logsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutJobsInput | care_logsCreateOrConnectWithoutJobsInput[]
    createMany?: care_logsCreateManyJobsInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type disputesCreateNestedManyWithoutJobsInput = {
    create?: XOR<disputesCreateWithoutJobsInput, disputesUncheckedCreateWithoutJobsInput> | disputesCreateWithoutJobsInput[] | disputesUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutJobsInput | disputesCreateOrConnectWithoutJobsInput[]
    createMany?: disputesCreateManyJobsInputEnvelope
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutJobsInput = {
    create?: XOR<usersCreateWithoutJobsInput, usersUncheckedCreateWithoutJobsInput>
    connectOrCreate?: usersCreateOrConnectWithoutJobsInput
    connect?: usersWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutJobsInput = {
    create?: XOR<companiesCreateWithoutJobsInput, companiesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutJobsInput
    connect?: companiesWhereUniqueInput
  }

  export type patientsCreateNestedOneWithoutJobsInput = {
    create?: XOR<patientsCreateWithoutJobsInput, patientsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutJobsInput
    connect?: patientsWhereUniqueInput
  }

  export type packagesCreateNestedOneWithoutJobsInput = {
    create?: XOR<packagesCreateWithoutJobsInput, packagesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: packagesCreateOrConnectWithoutJobsInput
    connect?: packagesWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutJobsInput = {
    create?: XOR<paymentsCreateWithoutJobsInput, paymentsUncheckedCreateWithoutJobsInput> | paymentsCreateWithoutJobsInput[] | paymentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutJobsInput | paymentsCreateOrConnectWithoutJobsInput[]
    createMany?: paymentsCreateManyJobsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type assignmentsUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<assignmentsCreateWithoutJobsInput, assignmentsUncheckedCreateWithoutJobsInput> | assignmentsCreateWithoutJobsInput[] | assignmentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutJobsInput | assignmentsCreateOrConnectWithoutJobsInput[]
    createMany?: assignmentsCreateManyJobsInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type care_logsUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<care_logsCreateWithoutJobsInput, care_logsUncheckedCreateWithoutJobsInput> | care_logsCreateWithoutJobsInput[] | care_logsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutJobsInput | care_logsCreateOrConnectWithoutJobsInput[]
    createMany?: care_logsCreateManyJobsInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type disputesUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<disputesCreateWithoutJobsInput, disputesUncheckedCreateWithoutJobsInput> | disputesCreateWithoutJobsInput[] | disputesUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutJobsInput | disputesCreateOrConnectWithoutJobsInput[]
    createMany?: disputesCreateManyJobsInputEnvelope
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<paymentsCreateWithoutJobsInput, paymentsUncheckedCreateWithoutJobsInput> | paymentsCreateWithoutJobsInput[] | paymentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutJobsInput | paymentsCreateOrConnectWithoutJobsInput[]
    createMany?: paymentsCreateManyJobsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type assignmentsUpdateManyWithoutJobsNestedInput = {
    create?: XOR<assignmentsCreateWithoutJobsInput, assignmentsUncheckedCreateWithoutJobsInput> | assignmentsCreateWithoutJobsInput[] | assignmentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutJobsInput | assignmentsCreateOrConnectWithoutJobsInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutJobsInput | assignmentsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: assignmentsCreateManyJobsInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutJobsInput | assignmentsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutJobsInput | assignmentsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type care_logsUpdateManyWithoutJobsNestedInput = {
    create?: XOR<care_logsCreateWithoutJobsInput, care_logsUncheckedCreateWithoutJobsInput> | care_logsCreateWithoutJobsInput[] | care_logsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutJobsInput | care_logsCreateOrConnectWithoutJobsInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutJobsInput | care_logsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: care_logsCreateManyJobsInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutJobsInput | care_logsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutJobsInput | care_logsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type disputesUpdateManyWithoutJobsNestedInput = {
    create?: XOR<disputesCreateWithoutJobsInput, disputesUncheckedCreateWithoutJobsInput> | disputesCreateWithoutJobsInput[] | disputesUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutJobsInput | disputesCreateOrConnectWithoutJobsInput[]
    upsert?: disputesUpsertWithWhereUniqueWithoutJobsInput | disputesUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: disputesCreateManyJobsInputEnvelope
    set?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    disconnect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    delete?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    update?: disputesUpdateWithWhereUniqueWithoutJobsInput | disputesUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: disputesUpdateManyWithWhereWithoutJobsInput | disputesUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: disputesScalarWhereInput | disputesScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<usersCreateWithoutJobsInput, usersUncheckedCreateWithoutJobsInput>
    connectOrCreate?: usersCreateOrConnectWithoutJobsInput
    upsert?: usersUpsertWithoutJobsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutJobsInput, usersUpdateWithoutJobsInput>, usersUncheckedUpdateWithoutJobsInput>
  }

  export type companiesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<companiesCreateWithoutJobsInput, companiesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutJobsInput
    upsert?: companiesUpsertWithoutJobsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutJobsInput, companiesUpdateWithoutJobsInput>, companiesUncheckedUpdateWithoutJobsInput>
  }

  export type patientsUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<patientsCreateWithoutJobsInput, patientsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutJobsInput
    upsert?: patientsUpsertWithoutJobsInput
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutJobsInput, patientsUpdateWithoutJobsInput>, patientsUncheckedUpdateWithoutJobsInput>
  }

  export type packagesUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<packagesCreateWithoutJobsInput, packagesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: packagesCreateOrConnectWithoutJobsInput
    upsert?: packagesUpsertWithoutJobsInput
    connect?: packagesWhereUniqueInput
    update?: XOR<XOR<packagesUpdateToOneWithWhereWithoutJobsInput, packagesUpdateWithoutJobsInput>, packagesUncheckedUpdateWithoutJobsInput>
  }

  export type paymentsUpdateManyWithoutJobsNestedInput = {
    create?: XOR<paymentsCreateWithoutJobsInput, paymentsUncheckedCreateWithoutJobsInput> | paymentsCreateWithoutJobsInput[] | paymentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutJobsInput | paymentsCreateOrConnectWithoutJobsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutJobsInput | paymentsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: paymentsCreateManyJobsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutJobsInput | paymentsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutJobsInput | paymentsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type assignmentsUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<assignmentsCreateWithoutJobsInput, assignmentsUncheckedCreateWithoutJobsInput> | assignmentsCreateWithoutJobsInput[] | assignmentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutJobsInput | assignmentsCreateOrConnectWithoutJobsInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutJobsInput | assignmentsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: assignmentsCreateManyJobsInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutJobsInput | assignmentsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutJobsInput | assignmentsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type care_logsUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<care_logsCreateWithoutJobsInput, care_logsUncheckedCreateWithoutJobsInput> | care_logsCreateWithoutJobsInput[] | care_logsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutJobsInput | care_logsCreateOrConnectWithoutJobsInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutJobsInput | care_logsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: care_logsCreateManyJobsInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutJobsInput | care_logsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutJobsInput | care_logsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type disputesUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<disputesCreateWithoutJobsInput, disputesUncheckedCreateWithoutJobsInput> | disputesCreateWithoutJobsInput[] | disputesUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutJobsInput | disputesCreateOrConnectWithoutJobsInput[]
    upsert?: disputesUpsertWithWhereUniqueWithoutJobsInput | disputesUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: disputesCreateManyJobsInputEnvelope
    set?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    disconnect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    delete?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    update?: disputesUpdateWithWhereUniqueWithoutJobsInput | disputesUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: disputesUpdateManyWithWhereWithoutJobsInput | disputesUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: disputesScalarWhereInput | disputesScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<paymentsCreateWithoutJobsInput, paymentsUncheckedCreateWithoutJobsInput> | paymentsCreateWithoutJobsInput[] | paymentsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutJobsInput | paymentsCreateOrConnectWithoutJobsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutJobsInput | paymentsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: paymentsCreateManyJobsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutJobsInput | paymentsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutJobsInput | paymentsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type job_applicationsCreateNestedManyWithoutMarketplace_jobsInput = {
    create?: XOR<job_applicationsCreateWithoutMarketplace_jobsInput, job_applicationsUncheckedCreateWithoutMarketplace_jobsInput> | job_applicationsCreateWithoutMarketplace_jobsInput[] | job_applicationsUncheckedCreateWithoutMarketplace_jobsInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutMarketplace_jobsInput | job_applicationsCreateOrConnectWithoutMarketplace_jobsInput[]
    createMany?: job_applicationsCreateManyMarketplace_jobsInputEnvelope
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
  }

  export type caregiversCreateNestedOneWithoutMarketplace_jobsInput = {
    create?: XOR<caregiversCreateWithoutMarketplace_jobsInput, caregiversUncheckedCreateWithoutMarketplace_jobsInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutMarketplace_jobsInput
    connect?: caregiversWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutMarketplace_jobsInput = {
    create?: XOR<companiesCreateWithoutMarketplace_jobsInput, companiesUncheckedCreateWithoutMarketplace_jobsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutMarketplace_jobsInput
    connect?: companiesWhereUniqueInput
  }

  export type job_applicationsUncheckedCreateNestedManyWithoutMarketplace_jobsInput = {
    create?: XOR<job_applicationsCreateWithoutMarketplace_jobsInput, job_applicationsUncheckedCreateWithoutMarketplace_jobsInput> | job_applicationsCreateWithoutMarketplace_jobsInput[] | job_applicationsUncheckedCreateWithoutMarketplace_jobsInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutMarketplace_jobsInput | job_applicationsCreateOrConnectWithoutMarketplace_jobsInput[]
    createMany?: job_applicationsCreateManyMarketplace_jobsInputEnvelope
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
  }

  export type job_applicationsUpdateManyWithoutMarketplace_jobsNestedInput = {
    create?: XOR<job_applicationsCreateWithoutMarketplace_jobsInput, job_applicationsUncheckedCreateWithoutMarketplace_jobsInput> | job_applicationsCreateWithoutMarketplace_jobsInput[] | job_applicationsUncheckedCreateWithoutMarketplace_jobsInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutMarketplace_jobsInput | job_applicationsCreateOrConnectWithoutMarketplace_jobsInput[]
    upsert?: job_applicationsUpsertWithWhereUniqueWithoutMarketplace_jobsInput | job_applicationsUpsertWithWhereUniqueWithoutMarketplace_jobsInput[]
    createMany?: job_applicationsCreateManyMarketplace_jobsInputEnvelope
    set?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    disconnect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    delete?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    update?: job_applicationsUpdateWithWhereUniqueWithoutMarketplace_jobsInput | job_applicationsUpdateWithWhereUniqueWithoutMarketplace_jobsInput[]
    updateMany?: job_applicationsUpdateManyWithWhereWithoutMarketplace_jobsInput | job_applicationsUpdateManyWithWhereWithoutMarketplace_jobsInput[]
    deleteMany?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
  }

  export type caregiversUpdateOneWithoutMarketplace_jobsNestedInput = {
    create?: XOR<caregiversCreateWithoutMarketplace_jobsInput, caregiversUncheckedCreateWithoutMarketplace_jobsInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutMarketplace_jobsInput
    upsert?: caregiversUpsertWithoutMarketplace_jobsInput
    disconnect?: caregiversWhereInput | boolean
    delete?: caregiversWhereInput | boolean
    connect?: caregiversWhereUniqueInput
    update?: XOR<XOR<caregiversUpdateToOneWithWhereWithoutMarketplace_jobsInput, caregiversUpdateWithoutMarketplace_jobsInput>, caregiversUncheckedUpdateWithoutMarketplace_jobsInput>
  }

  export type companiesUpdateOneRequiredWithoutMarketplace_jobsNestedInput = {
    create?: XOR<companiesCreateWithoutMarketplace_jobsInput, companiesUncheckedCreateWithoutMarketplace_jobsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutMarketplace_jobsInput
    upsert?: companiesUpsertWithoutMarketplace_jobsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutMarketplace_jobsInput, companiesUpdateWithoutMarketplace_jobsInput>, companiesUncheckedUpdateWithoutMarketplace_jobsInput>
  }

  export type job_applicationsUncheckedUpdateManyWithoutMarketplace_jobsNestedInput = {
    create?: XOR<job_applicationsCreateWithoutMarketplace_jobsInput, job_applicationsUncheckedCreateWithoutMarketplace_jobsInput> | job_applicationsCreateWithoutMarketplace_jobsInput[] | job_applicationsUncheckedCreateWithoutMarketplace_jobsInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutMarketplace_jobsInput | job_applicationsCreateOrConnectWithoutMarketplace_jobsInput[]
    upsert?: job_applicationsUpsertWithWhereUniqueWithoutMarketplace_jobsInput | job_applicationsUpsertWithWhereUniqueWithoutMarketplace_jobsInput[]
    createMany?: job_applicationsCreateManyMarketplace_jobsInputEnvelope
    set?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    disconnect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    delete?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    update?: job_applicationsUpdateWithWhereUniqueWithoutMarketplace_jobsInput | job_applicationsUpdateWithWhereUniqueWithoutMarketplace_jobsInput[]
    updateMany?: job_applicationsUpdateManyWithWhereWithoutMarketplace_jobsInput | job_applicationsUpdateManyWithWhereWithoutMarketplace_jobsInput[]
    deleteMany?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type usersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type jobsCreateNestedManyWithoutPackagesInput = {
    create?: XOR<jobsCreateWithoutPackagesInput, jobsUncheckedCreateWithoutPackagesInput> | jobsCreateWithoutPackagesInput[] | jobsUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPackagesInput | jobsCreateOrConnectWithoutPackagesInput[]
    createMany?: jobsCreateManyPackagesInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type companiesCreateNestedOneWithoutPackagesInput = {
    create?: XOR<companiesCreateWithoutPackagesInput, companiesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutPackagesInput
    connect?: companiesWhereUniqueInput
  }

  export type jobsUncheckedCreateNestedManyWithoutPackagesInput = {
    create?: XOR<jobsCreateWithoutPackagesInput, jobsUncheckedCreateWithoutPackagesInput> | jobsCreateWithoutPackagesInput[] | jobsUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPackagesInput | jobsCreateOrConnectWithoutPackagesInput[]
    createMany?: jobsCreateManyPackagesInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type EnumPackageCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PackageCategory
  }

  export type jobsUpdateManyWithoutPackagesNestedInput = {
    create?: XOR<jobsCreateWithoutPackagesInput, jobsUncheckedCreateWithoutPackagesInput> | jobsCreateWithoutPackagesInput[] | jobsUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPackagesInput | jobsCreateOrConnectWithoutPackagesInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutPackagesInput | jobsUpsertWithWhereUniqueWithoutPackagesInput[]
    createMany?: jobsCreateManyPackagesInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutPackagesInput | jobsUpdateWithWhereUniqueWithoutPackagesInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutPackagesInput | jobsUpdateManyWithWhereWithoutPackagesInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type companiesUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<companiesCreateWithoutPackagesInput, companiesUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutPackagesInput
    upsert?: companiesUpsertWithoutPackagesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutPackagesInput, companiesUpdateWithoutPackagesInput>, companiesUncheckedUpdateWithoutPackagesInput>
  }

  export type jobsUncheckedUpdateManyWithoutPackagesNestedInput = {
    create?: XOR<jobsCreateWithoutPackagesInput, jobsUncheckedCreateWithoutPackagesInput> | jobsCreateWithoutPackagesInput[] | jobsUncheckedCreateWithoutPackagesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPackagesInput | jobsCreateOrConnectWithoutPackagesInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutPackagesInput | jobsUpsertWithWhereUniqueWithoutPackagesInput[]
    createMany?: jobsCreateManyPackagesInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutPackagesInput | jobsUpdateWithWhereUniqueWithoutPackagesInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutPackagesInput | jobsUpdateManyWithWhereWithoutPackagesInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type care_logsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<care_logsCreateWithoutPatientsInput, care_logsUncheckedCreateWithoutPatientsInput> | care_logsCreateWithoutPatientsInput[] | care_logsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutPatientsInput | care_logsCreateOrConnectWithoutPatientsInput[]
    createMany?: care_logsCreateManyPatientsInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type health_recordsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<health_recordsCreateWithoutPatientsInput, health_recordsUncheckedCreateWithoutPatientsInput> | health_recordsCreateWithoutPatientsInput[] | health_recordsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: health_recordsCreateOrConnectWithoutPatientsInput | health_recordsCreateOrConnectWithoutPatientsInput[]
    createMany?: health_recordsCreateManyPatientsInputEnvelope
    connect?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
  }

  export type jobsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<jobsCreateWithoutPatientsInput, jobsUncheckedCreateWithoutPatientsInput> | jobsCreateWithoutPatientsInput[] | jobsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPatientsInput | jobsCreateOrConnectWithoutPatientsInput[]
    createMany?: jobsCreateManyPatientsInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutPatientsInput = {
    create?: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPatientsInput
    connect?: usersWhereUniqueInput
  }

  export type care_logsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<care_logsCreateWithoutPatientsInput, care_logsUncheckedCreateWithoutPatientsInput> | care_logsCreateWithoutPatientsInput[] | care_logsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutPatientsInput | care_logsCreateOrConnectWithoutPatientsInput[]
    createMany?: care_logsCreateManyPatientsInputEnvelope
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
  }

  export type health_recordsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<health_recordsCreateWithoutPatientsInput, health_recordsUncheckedCreateWithoutPatientsInput> | health_recordsCreateWithoutPatientsInput[] | health_recordsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: health_recordsCreateOrConnectWithoutPatientsInput | health_recordsCreateOrConnectWithoutPatientsInput[]
    createMany?: health_recordsCreateManyPatientsInputEnvelope
    connect?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
  }

  export type jobsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<jobsCreateWithoutPatientsInput, jobsUncheckedCreateWithoutPatientsInput> | jobsCreateWithoutPatientsInput[] | jobsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPatientsInput | jobsCreateOrConnectWithoutPatientsInput[]
    createMany?: jobsCreateManyPatientsInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type EnumMobilityLevelFieldUpdateOperationsInput = {
    set?: $Enums.MobilityLevel
  }

  export type EnumCognitiveStatusFieldUpdateOperationsInput = {
    set?: $Enums.CognitiveStatus
  }

  export type care_logsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<care_logsCreateWithoutPatientsInput, care_logsUncheckedCreateWithoutPatientsInput> | care_logsCreateWithoutPatientsInput[] | care_logsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutPatientsInput | care_logsCreateOrConnectWithoutPatientsInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutPatientsInput | care_logsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: care_logsCreateManyPatientsInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutPatientsInput | care_logsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutPatientsInput | care_logsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type health_recordsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<health_recordsCreateWithoutPatientsInput, health_recordsUncheckedCreateWithoutPatientsInput> | health_recordsCreateWithoutPatientsInput[] | health_recordsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: health_recordsCreateOrConnectWithoutPatientsInput | health_recordsCreateOrConnectWithoutPatientsInput[]
    upsert?: health_recordsUpsertWithWhereUniqueWithoutPatientsInput | health_recordsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: health_recordsCreateManyPatientsInputEnvelope
    set?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    disconnect?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    delete?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    connect?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    update?: health_recordsUpdateWithWhereUniqueWithoutPatientsInput | health_recordsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: health_recordsUpdateManyWithWhereWithoutPatientsInput | health_recordsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: health_recordsScalarWhereInput | health_recordsScalarWhereInput[]
  }

  export type jobsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<jobsCreateWithoutPatientsInput, jobsUncheckedCreateWithoutPatientsInput> | jobsCreateWithoutPatientsInput[] | jobsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPatientsInput | jobsCreateOrConnectWithoutPatientsInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutPatientsInput | jobsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: jobsCreateManyPatientsInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutPatientsInput | jobsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutPatientsInput | jobsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPatientsInput
    upsert?: usersUpsertWithoutPatientsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPatientsInput, usersUpdateWithoutPatientsInput>, usersUncheckedUpdateWithoutPatientsInput>
  }

  export type care_logsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<care_logsCreateWithoutPatientsInput, care_logsUncheckedCreateWithoutPatientsInput> | care_logsCreateWithoutPatientsInput[] | care_logsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: care_logsCreateOrConnectWithoutPatientsInput | care_logsCreateOrConnectWithoutPatientsInput[]
    upsert?: care_logsUpsertWithWhereUniqueWithoutPatientsInput | care_logsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: care_logsCreateManyPatientsInputEnvelope
    set?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    disconnect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    delete?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    connect?: care_logsWhereUniqueInput | care_logsWhereUniqueInput[]
    update?: care_logsUpdateWithWhereUniqueWithoutPatientsInput | care_logsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: care_logsUpdateManyWithWhereWithoutPatientsInput | care_logsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
  }

  export type health_recordsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<health_recordsCreateWithoutPatientsInput, health_recordsUncheckedCreateWithoutPatientsInput> | health_recordsCreateWithoutPatientsInput[] | health_recordsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: health_recordsCreateOrConnectWithoutPatientsInput | health_recordsCreateOrConnectWithoutPatientsInput[]
    upsert?: health_recordsUpsertWithWhereUniqueWithoutPatientsInput | health_recordsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: health_recordsCreateManyPatientsInputEnvelope
    set?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    disconnect?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    delete?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    connect?: health_recordsWhereUniqueInput | health_recordsWhereUniqueInput[]
    update?: health_recordsUpdateWithWhereUniqueWithoutPatientsInput | health_recordsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: health_recordsUpdateManyWithWhereWithoutPatientsInput | health_recordsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: health_recordsScalarWhereInput | health_recordsScalarWhereInput[]
  }

  export type jobsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<jobsCreateWithoutPatientsInput, jobsUncheckedCreateWithoutPatientsInput> | jobsCreateWithoutPatientsInput[] | jobsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutPatientsInput | jobsCreateOrConnectWithoutPatientsInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutPatientsInput | jobsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: jobsCreateManyPatientsInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutPatientsInput | jobsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutPatientsInput | jobsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type escrowsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<escrowsCreateWithoutPaymentsInput, escrowsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: escrowsCreateOrConnectWithoutPaymentsInput
    connect?: escrowsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    connect?: usersWhereUniqueInput
  }

  export type jobsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<jobsCreateWithoutPaymentsInput, jobsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutPaymentsInput
    connect?: jobsWhereUniqueInput
  }

  export type escrowsUncheckedCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<escrowsCreateWithoutPaymentsInput, escrowsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: escrowsCreateOrConnectWithoutPaymentsInput
    connect?: escrowsWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type escrowsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<escrowsCreateWithoutPaymentsInput, escrowsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: escrowsCreateOrConnectWithoutPaymentsInput
    upsert?: escrowsUpsertWithoutPaymentsInput
    disconnect?: escrowsWhereInput | boolean
    delete?: escrowsWhereInput | boolean
    connect?: escrowsWhereUniqueInput
    update?: XOR<XOR<escrowsUpdateToOneWithWhereWithoutPaymentsInput, escrowsUpdateWithoutPaymentsInput>, escrowsUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    upsert?: usersUpsertWithoutPaymentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPaymentsInput, usersUpdateWithoutPaymentsInput>, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type jobsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<jobsCreateWithoutPaymentsInput, jobsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutPaymentsInput
    upsert?: jobsUpsertWithoutPaymentsInput
    disconnect?: jobsWhereInput | boolean
    delete?: jobsWhereInput | boolean
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutPaymentsInput, jobsUpdateWithoutPaymentsInput>, jobsUncheckedUpdateWithoutPaymentsInput>
  }

  export type escrowsUncheckedUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<escrowsCreateWithoutPaymentsInput, escrowsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: escrowsCreateOrConnectWithoutPaymentsInput
    upsert?: escrowsUpsertWithoutPaymentsInput
    disconnect?: escrowsWhereInput | boolean
    delete?: escrowsWhereInput | boolean
    connect?: escrowsWhereUniqueInput
    update?: XOR<XOR<escrowsUpdateToOneWithWhereWithoutPaymentsInput, escrowsUpdateWithoutPaymentsInput>, escrowsUncheckedUpdateWithoutPaymentsInput>
  }

  export type companiesCreateNestedOneWithoutService_zonesInput = {
    create?: XOR<companiesCreateWithoutService_zonesInput, companiesUncheckedCreateWithoutService_zonesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutService_zonesInput
    connect?: companiesWhereUniqueInput
  }

  export type companiesUpdateOneRequiredWithoutService_zonesNestedInput = {
    create?: XOR<companiesCreateWithoutService_zonesInput, companiesUncheckedCreateWithoutService_zonesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutService_zonesInput
    upsert?: companiesUpsertWithoutService_zonesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutService_zonesInput, companiesUpdateWithoutService_zonesInput>, companiesUncheckedUpdateWithoutService_zonesInput>
  }

  export type usersCreateNestedOneWithoutUser_devicesInput = {
    create?: XOR<usersCreateWithoutUser_devicesInput, usersUncheckedCreateWithoutUser_devicesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_devicesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_devicesNestedInput = {
    create?: XOR<usersCreateWithoutUser_devicesInput, usersUncheckedCreateWithoutUser_devicesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_devicesInput
    upsert?: usersUpsertWithoutUser_devicesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_devicesInput, usersUpdateWithoutUser_devicesInput>, usersUncheckedUpdateWithoutUser_devicesInput>
  }

  export type usersCreateNestedOneWithoutVerification_codesInput = {
    create?: XOR<usersCreateWithoutVerification_codesInput, usersUncheckedCreateWithoutVerification_codesInput>
    connectOrCreate?: usersCreateOrConnectWithoutVerification_codesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutVerification_codesNestedInput = {
    create?: XOR<usersCreateWithoutVerification_codesInput, usersUncheckedCreateWithoutVerification_codesInput>
    connectOrCreate?: usersCreateOrConnectWithoutVerification_codesInput
    upsert?: usersUpsertWithoutVerification_codesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVerification_codesInput, usersUpdateWithoutVerification_codesInput>, usersUncheckedUpdateWithoutVerification_codesInput>
  }

  export type audit_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type caregiversCreateNestedOneWithoutUsersInput = {
    create?: XOR<caregiversCreateWithoutUsersInput, caregiversUncheckedCreateWithoutUsersInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutUsersInput
    connect?: caregiversWhereUniqueInput
  }

  export type disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_againstTousersInput, disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput> | disputesCreateWithoutUsers_disputes_againstTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput | disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_againstTousersInputEnvelope
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
  }

  export type disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput> | disputesCreateWithoutUsers_disputes_raised_byTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput | disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_raised_byTousersInputEnvelope
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
  }

  export type feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_to_user_idTousersInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_from_user_idTousersInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type job_applicationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<job_applicationsCreateWithoutUsersInput, job_applicationsUncheckedCreateWithoutUsersInput> | job_applicationsCreateWithoutUsersInput[] | job_applicationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutUsersInput | job_applicationsCreateOrConnectWithoutUsersInput[]
    createMany?: job_applicationsCreateManyUsersInputEnvelope
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
  }

  export type jobsCreateNestedManyWithoutUsersInput = {
    create?: XOR<jobsCreateWithoutUsersInput, jobsUncheckedCreateWithoutUsersInput> | jobsCreateWithoutUsersInput[] | jobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutUsersInput | jobsCreateOrConnectWithoutUsersInput[]
    createMany?: jobsCreateManyUsersInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type patientsCreateNestedManyWithoutUsersInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type user_devicesCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_devicesCreateWithoutUsersInput, user_devicesUncheckedCreateWithoutUsersInput> | user_devicesCreateWithoutUsersInput[] | user_devicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_devicesCreateOrConnectWithoutUsersInput | user_devicesCreateOrConnectWithoutUsersInput[]
    createMany?: user_devicesCreateManyUsersInputEnvelope
    connect?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
  }

  export type verification_codesCreateNestedManyWithoutUsersInput = {
    create?: XOR<verification_codesCreateWithoutUsersInput, verification_codesUncheckedCreateWithoutUsersInput> | verification_codesCreateWithoutUsersInput[] | verification_codesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: verification_codesCreateOrConnectWithoutUsersInput | verification_codesCreateOrConnectWithoutUsersInput[]
    createMany?: verification_codesCreateManyUsersInputEnvelope
    connect?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
  }

  export type companiesCreateNestedOneWithoutUsersInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    connect?: companiesWhereUniqueInput
  }

  export type audit_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
  }

  export type caregiversUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<caregiversCreateWithoutUsersInput, caregiversUncheckedCreateWithoutUsersInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutUsersInput
    connect?: caregiversWhereUniqueInput
  }

  export type disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_againstTousersInput, disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput> | disputesCreateWithoutUsers_disputes_againstTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput | disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_againstTousersInputEnvelope
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
  }

  export type disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput> | disputesCreateWithoutUsers_disputes_raised_byTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput | disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_raised_byTousersInputEnvelope
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
  }

  export type feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_to_user_idTousersInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_from_user_idTousersInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type job_applicationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<job_applicationsCreateWithoutUsersInput, job_applicationsUncheckedCreateWithoutUsersInput> | job_applicationsCreateWithoutUsersInput[] | job_applicationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutUsersInput | job_applicationsCreateOrConnectWithoutUsersInput[]
    createMany?: job_applicationsCreateManyUsersInputEnvelope
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
  }

  export type jobsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<jobsCreateWithoutUsersInput, jobsUncheckedCreateWithoutUsersInput> | jobsCreateWithoutUsersInput[] | jobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutUsersInput | jobsCreateOrConnectWithoutUsersInput[]
    createMany?: jobsCreateManyUsersInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type patientsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type user_devicesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_devicesCreateWithoutUsersInput, user_devicesUncheckedCreateWithoutUsersInput> | user_devicesCreateWithoutUsersInput[] | user_devicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_devicesCreateOrConnectWithoutUsersInput | user_devicesCreateOrConnectWithoutUsersInput[]
    createMany?: user_devicesCreateManyUsersInputEnvelope
    connect?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
  }

  export type verification_codesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<verification_codesCreateWithoutUsersInput, verification_codesUncheckedCreateWithoutUsersInput> | verification_codesCreateWithoutUsersInput[] | verification_codesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: verification_codesCreateOrConnectWithoutUsersInput | verification_codesCreateOrConnectWithoutUsersInput[]
    createMany?: verification_codesCreateManyUsersInputEnvelope
    connect?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type audit_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type caregiversUpdateOneWithoutUsersNestedInput = {
    create?: XOR<caregiversCreateWithoutUsersInput, caregiversUncheckedCreateWithoutUsersInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutUsersInput
    upsert?: caregiversUpsertWithoutUsersInput
    disconnect?: caregiversWhereInput | boolean
    delete?: caregiversWhereInput | boolean
    connect?: caregiversWhereUniqueInput
    update?: XOR<XOR<caregiversUpdateToOneWithWhereWithoutUsersInput, caregiversUpdateWithoutUsersInput>, caregiversUncheckedUpdateWithoutUsersInput>
  }

  export type disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_againstTousersInput, disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput> | disputesCreateWithoutUsers_disputes_againstTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput | disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput[]
    upsert?: disputesUpsertWithWhereUniqueWithoutUsers_disputes_againstTousersInput | disputesUpsertWithWhereUniqueWithoutUsers_disputes_againstTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_againstTousersInputEnvelope
    set?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    disconnect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    delete?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    update?: disputesUpdateWithWhereUniqueWithoutUsers_disputes_againstTousersInput | disputesUpdateWithWhereUniqueWithoutUsers_disputes_againstTousersInput[]
    updateMany?: disputesUpdateManyWithWhereWithoutUsers_disputes_againstTousersInput | disputesUpdateManyWithWhereWithoutUsers_disputes_againstTousersInput[]
    deleteMany?: disputesScalarWhereInput | disputesScalarWhereInput[]
  }

  export type disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput> | disputesCreateWithoutUsers_disputes_raised_byTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput | disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput[]
    upsert?: disputesUpsertWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput | disputesUpsertWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_raised_byTousersInputEnvelope
    set?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    disconnect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    delete?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    update?: disputesUpdateWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput | disputesUpdateWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput[]
    updateMany?: disputesUpdateManyWithWhereWithoutUsers_disputes_raised_byTousersInput | disputesUpdateManyWithWhereWithoutUsers_disputes_raised_byTousersInput[]
    deleteMany?: disputesScalarWhereInput | disputesScalarWhereInput[]
  }

  export type feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_to_user_idTousersInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_to_user_idTousersInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_from_user_idTousersInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_from_user_idTousersInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type job_applicationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<job_applicationsCreateWithoutUsersInput, job_applicationsUncheckedCreateWithoutUsersInput> | job_applicationsCreateWithoutUsersInput[] | job_applicationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutUsersInput | job_applicationsCreateOrConnectWithoutUsersInput[]
    upsert?: job_applicationsUpsertWithWhereUniqueWithoutUsersInput | job_applicationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: job_applicationsCreateManyUsersInputEnvelope
    set?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    disconnect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    delete?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    update?: job_applicationsUpdateWithWhereUniqueWithoutUsersInput | job_applicationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: job_applicationsUpdateManyWithWhereWithoutUsersInput | job_applicationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
  }

  export type jobsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<jobsCreateWithoutUsersInput, jobsUncheckedCreateWithoutUsersInput> | jobsCreateWithoutUsersInput[] | jobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutUsersInput | jobsCreateOrConnectWithoutUsersInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutUsersInput | jobsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: jobsCreateManyUsersInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutUsersInput | jobsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutUsersInput | jobsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type patientsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    upsert?: patientsUpsertWithWhereUniqueWithoutUsersInput | patientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    set?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    disconnect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    delete?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    update?: patientsUpdateWithWhereUniqueWithoutUsersInput | patientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: patientsUpdateManyWithWhereWithoutUsersInput | patientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: patientsScalarWhereInput | patientsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type user_devicesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_devicesCreateWithoutUsersInput, user_devicesUncheckedCreateWithoutUsersInput> | user_devicesCreateWithoutUsersInput[] | user_devicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_devicesCreateOrConnectWithoutUsersInput | user_devicesCreateOrConnectWithoutUsersInput[]
    upsert?: user_devicesUpsertWithWhereUniqueWithoutUsersInput | user_devicesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_devicesCreateManyUsersInputEnvelope
    set?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    disconnect?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    delete?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    connect?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    update?: user_devicesUpdateWithWhereUniqueWithoutUsersInput | user_devicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_devicesUpdateManyWithWhereWithoutUsersInput | user_devicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_devicesScalarWhereInput | user_devicesScalarWhereInput[]
  }

  export type verification_codesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<verification_codesCreateWithoutUsersInput, verification_codesUncheckedCreateWithoutUsersInput> | verification_codesCreateWithoutUsersInput[] | verification_codesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: verification_codesCreateOrConnectWithoutUsersInput | verification_codesCreateOrConnectWithoutUsersInput[]
    upsert?: verification_codesUpsertWithWhereUniqueWithoutUsersInput | verification_codesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: verification_codesCreateManyUsersInputEnvelope
    set?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    disconnect?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    delete?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    connect?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    update?: verification_codesUpdateWithWhereUniqueWithoutUsersInput | verification_codesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: verification_codesUpdateManyWithWhereWithoutUsersInput | verification_codesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: verification_codesScalarWhereInput | verification_codesScalarWhereInput[]
  }

  export type companiesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    upsert?: companiesUpsertWithoutUsersInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutUsersInput, companiesUpdateWithoutUsersInput>, companiesUncheckedUpdateWithoutUsersInput>
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput> | audit_logsCreateWithoutUsersInput[] | audit_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: audit_logsCreateOrConnectWithoutUsersInput | audit_logsCreateOrConnectWithoutUsersInput[]
    upsert?: audit_logsUpsertWithWhereUniqueWithoutUsersInput | audit_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: audit_logsCreateManyUsersInputEnvelope
    set?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    disconnect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    delete?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    connect?: audit_logsWhereUniqueInput | audit_logsWhereUniqueInput[]
    update?: audit_logsUpdateWithWhereUniqueWithoutUsersInput | audit_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: audit_logsUpdateManyWithWhereWithoutUsersInput | audit_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
  }

  export type caregiversUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<caregiversCreateWithoutUsersInput, caregiversUncheckedCreateWithoutUsersInput>
    connectOrCreate?: caregiversCreateOrConnectWithoutUsersInput
    upsert?: caregiversUpsertWithoutUsersInput
    disconnect?: caregiversWhereInput | boolean
    delete?: caregiversWhereInput | boolean
    connect?: caregiversWhereUniqueInput
    update?: XOR<XOR<caregiversUpdateToOneWithWhereWithoutUsersInput, caregiversUpdateWithoutUsersInput>, caregiversUncheckedUpdateWithoutUsersInput>
  }

  export type disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_againstTousersInput, disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput> | disputesCreateWithoutUsers_disputes_againstTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput | disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput[]
    upsert?: disputesUpsertWithWhereUniqueWithoutUsers_disputes_againstTousersInput | disputesUpsertWithWhereUniqueWithoutUsers_disputes_againstTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_againstTousersInputEnvelope
    set?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    disconnect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    delete?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    update?: disputesUpdateWithWhereUniqueWithoutUsers_disputes_againstTousersInput | disputesUpdateWithWhereUniqueWithoutUsers_disputes_againstTousersInput[]
    updateMany?: disputesUpdateManyWithWhereWithoutUsers_disputes_againstTousersInput | disputesUpdateManyWithWhereWithoutUsers_disputes_againstTousersInput[]
    deleteMany?: disputesScalarWhereInput | disputesScalarWhereInput[]
  }

  export type disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput = {
    create?: XOR<disputesCreateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput> | disputesCreateWithoutUsers_disputes_raised_byTousersInput[] | disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput[]
    connectOrCreate?: disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput | disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput[]
    upsert?: disputesUpsertWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput | disputesUpsertWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput[]
    createMany?: disputesCreateManyUsers_disputes_raised_byTousersInputEnvelope
    set?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    disconnect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    delete?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    connect?: disputesWhereUniqueInput | disputesWhereUniqueInput[]
    update?: disputesUpdateWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput | disputesUpdateWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput[]
    updateMany?: disputesUpdateManyWithWhereWithoutUsers_disputes_raised_byTousersInput | disputesUpdateManyWithWhereWithoutUsers_disputes_raised_byTousersInput[]
    deleteMany?: disputesScalarWhereInput | disputesScalarWhereInput[]
  }

  export type feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_to_user_idTousersInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_to_user_idTousersInput | feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_to_user_idTousersInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput = {
    create?: XOR<feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput> | feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput[] | feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput[]
    createMany?: feedbacksCreateManyUsers_feedbacks_from_user_idTousersInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_from_user_idTousersInput | feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_from_user_idTousersInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type job_applicationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<job_applicationsCreateWithoutUsersInput, job_applicationsUncheckedCreateWithoutUsersInput> | job_applicationsCreateWithoutUsersInput[] | job_applicationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: job_applicationsCreateOrConnectWithoutUsersInput | job_applicationsCreateOrConnectWithoutUsersInput[]
    upsert?: job_applicationsUpsertWithWhereUniqueWithoutUsersInput | job_applicationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: job_applicationsCreateManyUsersInputEnvelope
    set?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    disconnect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    delete?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    connect?: job_applicationsWhereUniqueInput | job_applicationsWhereUniqueInput[]
    update?: job_applicationsUpdateWithWhereUniqueWithoutUsersInput | job_applicationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: job_applicationsUpdateManyWithWhereWithoutUsersInput | job_applicationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
  }

  export type jobsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<jobsCreateWithoutUsersInput, jobsUncheckedCreateWithoutUsersInput> | jobsCreateWithoutUsersInput[] | jobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutUsersInput | jobsCreateOrConnectWithoutUsersInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutUsersInput | jobsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: jobsCreateManyUsersInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutUsersInput | jobsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutUsersInput | jobsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type patientsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    upsert?: patientsUpsertWithWhereUniqueWithoutUsersInput | patientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    set?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    disconnect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    delete?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    update?: patientsUpdateWithWhereUniqueWithoutUsersInput | patientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: patientsUpdateManyWithWhereWithoutUsersInput | patientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: patientsScalarWhereInput | patientsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type user_devicesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_devicesCreateWithoutUsersInput, user_devicesUncheckedCreateWithoutUsersInput> | user_devicesCreateWithoutUsersInput[] | user_devicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_devicesCreateOrConnectWithoutUsersInput | user_devicesCreateOrConnectWithoutUsersInput[]
    upsert?: user_devicesUpsertWithWhereUniqueWithoutUsersInput | user_devicesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_devicesCreateManyUsersInputEnvelope
    set?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    disconnect?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    delete?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    connect?: user_devicesWhereUniqueInput | user_devicesWhereUniqueInput[]
    update?: user_devicesUpdateWithWhereUniqueWithoutUsersInput | user_devicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_devicesUpdateManyWithWhereWithoutUsersInput | user_devicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_devicesScalarWhereInput | user_devicesScalarWhereInput[]
  }

  export type verification_codesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<verification_codesCreateWithoutUsersInput, verification_codesUncheckedCreateWithoutUsersInput> | verification_codesCreateWithoutUsersInput[] | verification_codesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: verification_codesCreateOrConnectWithoutUsersInput | verification_codesCreateOrConnectWithoutUsersInput[]
    upsert?: verification_codesUpsertWithWhereUniqueWithoutUsersInput | verification_codesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: verification_codesCreateManyUsersInputEnvelope
    set?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    disconnect?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    delete?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    connect?: verification_codesWhereUniqueInput | verification_codesWhereUniqueInput[]
    update?: verification_codesUpdateWithWhereUniqueWithoutUsersInput | verification_codesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: verification_codesUpdateManyWithWhereWithoutUsersInput | verification_codesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: verification_codesScalarWhereInput | verification_codesScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAssignmentRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleFilter<$PrismaModel> | $Enums.AssignmentRole
  }

  export type NestedEnumAssignmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusFilter<$PrismaModel> | $Enums.AssignmentStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumAssignmentRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentRole | EnumAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentRole[] | ListEnumAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentRoleWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentRoleFilter<$PrismaModel>
    _max?: NestedEnumAssignmentRoleFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentStatus | EnumAssignmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentStatus[] | ListEnumAssignmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAssignmentStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCareLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CareLogType | EnumCareLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareLogTypeFilter<$PrismaModel> | $Enums.CareLogType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCareLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CareLogType | EnumCareLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CareLogType[] | ListEnumCareLogTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCareLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.CareLogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCareLogTypeFilter<$PrismaModel>
    _max?: NestedEnumCareLogTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumBackgroundCheckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCheckStatus | EnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCheckStatusFilter<$PrismaModel> | $Enums.BackgroundCheckStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumBackgroundCheckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackgroundCheckStatus | EnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BackgroundCheckStatus[] | ListEnumBackgroundCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBackgroundCheckStatusWithAggregatesFilter<$PrismaModel> | $Enums.BackgroundCheckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackgroundCheckStatusFilter<$PrismaModel>
    _max?: NestedEnumBackgroundCheckStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPayoutMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodFilter<$PrismaModel> | $Enums.PayoutMethod
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumPayoutMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutMethod | EnumPayoutMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutMethod[] | ListEnumPayoutMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutMethodWithAggregatesFilter<$PrismaModel> | $Enums.PayoutMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutMethodFilter<$PrismaModel>
    _max?: NestedEnumPayoutMethodFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedEnumDisputeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeFilter<$PrismaModel> | $Enums.DisputeType
  }

  export type NestedEnumDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusFilter<$PrismaModel> | $Enums.DisputeStatus
  }

  export type NestedEnumDisputeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeWithAggregatesFilter<$PrismaModel> | $Enums.DisputeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeTypeFilter<$PrismaModel>
    _max?: NestedEnumDisputeTypeFilter<$PrismaModel>
  }

  export type NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumDisputeStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumHealthRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthRecordType | EnumHealthRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthRecordTypeFilter<$PrismaModel> | $Enums.HealthRecordType
  }

  export type NestedEnumHealthRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthRecordType | EnumHealthRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthRecordType[] | ListEnumHealthRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.HealthRecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumHealthRecordTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPackageCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageCategory | EnumPackageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageCategoryFilter<$PrismaModel> | $Enums.PackageCategory
  }

  export type NestedEnumPackageCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackageCategory | EnumPackageCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PackageCategory[] | ListEnumPackageCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPackageCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PackageCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPackageCategoryFilter<$PrismaModel>
    _max?: NestedEnumPackageCategoryFilter<$PrismaModel>
  }

  export type NestedEnumMobilityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.MobilityLevel | EnumMobilityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMobilityLevelFilter<$PrismaModel> | $Enums.MobilityLevel
  }

  export type NestedEnumCognitiveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CognitiveStatus | EnumCognitiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCognitiveStatusFilter<$PrismaModel> | $Enums.CognitiveStatus
  }

  export type NestedEnumMobilityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MobilityLevel | EnumMobilityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MobilityLevel[] | ListEnumMobilityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMobilityLevelWithAggregatesFilter<$PrismaModel> | $Enums.MobilityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMobilityLevelFilter<$PrismaModel>
    _max?: NestedEnumMobilityLevelFilter<$PrismaModel>
  }

  export type NestedEnumCognitiveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CognitiveStatus | EnumCognitiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CognitiveStatus[] | ListEnumCognitiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCognitiveStatusWithAggregatesFilter<$PrismaModel> | $Enums.CognitiveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCognitiveStatusFilter<$PrismaModel>
    _max?: NestedEnumCognitiveStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type caregiversCreateWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_caregiver_idTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutCaregiversInput
    companies?: companiesCreateNestedOneWithoutCaregiversInput
    users: usersCreateNestedOneWithoutCaregiversInput
    job_applications?: job_applicationsCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    id?: string
    userId: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutCaregiversInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversCreateOrConnectWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    where: caregiversWhereUniqueInput
    create: XOR<caregiversCreateWithoutAssignments_assignments_replaced_byTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_replaced_byTocaregiversInput>
  }

  export type caregiversCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutCaregiversInput
    companies?: companiesCreateNestedOneWithoutCaregiversInput
    users: usersCreateNestedOneWithoutCaregiversInput
    job_applications?: job_applicationsCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    id?: string
    userId: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutCaregiversInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversCreateOrConnectWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    where: caregiversWhereUniqueInput
    create: XOR<caregiversCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput>
  }

  export type jobsCreateWithoutAssignmentsInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutAssignmentsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutAssignmentsInput, jobsUncheckedCreateWithoutAssignmentsInput>
  }

  export type care_logsCreateWithoutAssignmentsInput = {
    id?: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
    patients: patientsCreateNestedOneWithoutCare_logsInput
    caregivers: caregiversCreateNestedOneWithoutCare_logsInput
    jobs: jobsCreateNestedOneWithoutCare_logsInput
  }

  export type care_logsUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    job_id: string
    caregiver_id: string
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type care_logsCreateOrConnectWithoutAssignmentsInput = {
    where: care_logsWhereUniqueInput
    create: XOR<care_logsCreateWithoutAssignmentsInput, care_logsUncheckedCreateWithoutAssignmentsInput>
  }

  export type care_logsCreateManyAssignmentsInputEnvelope = {
    data: care_logsCreateManyAssignmentsInput | care_logsCreateManyAssignmentsInput[]
    skipDuplicates?: boolean
  }

  export type caregiversUpsertWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    update: XOR<caregiversUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput, caregiversUncheckedUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput>
    create: XOR<caregiversCreateWithoutAssignments_assignments_replaced_byTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_replaced_byTocaregiversInput>
    where?: caregiversWhereInput
  }

  export type caregiversUpdateToOneWithWhereWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    where?: caregiversWhereInput
    data: XOR<caregiversUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput, caregiversUncheckedUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput>
  }

  export type caregiversUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutCaregiversNestedInput
    companies?: companiesUpdateOneWithoutCaregiversNestedInput
    users?: usersUpdateOneRequiredWithoutCaregiversNestedInput
    job_applications?: job_applicationsUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateWithoutAssignments_assignments_replaced_byTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutCaregiversNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUpsertWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    update: XOR<caregiversUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput, caregiversUncheckedUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput>
    create: XOR<caregiversCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput, caregiversUncheckedCreateWithoutAssignments_assignments_caregiver_idTocaregiversInput>
    where?: caregiversWhereInput
  }

  export type caregiversUpdateToOneWithWhereWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    where?: caregiversWhereInput
    data: XOR<caregiversUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput, caregiversUncheckedUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput>
  }

  export type caregiversUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutCaregiversNestedInput
    companies?: companiesUpdateOneWithoutCaregiversNestedInput
    users?: usersUpdateOneRequiredWithoutCaregiversNestedInput
    job_applications?: job_applicationsUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateWithoutAssignments_assignments_caregiver_idTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutCaregiversNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type jobsUpsertWithoutAssignmentsInput = {
    update: XOR<jobsUpdateWithoutAssignmentsInput, jobsUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<jobsCreateWithoutAssignmentsInput, jobsUncheckedCreateWithoutAssignmentsInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutAssignmentsInput, jobsUncheckedUpdateWithoutAssignmentsInput>
  }

  export type jobsUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type care_logsUpsertWithWhereUniqueWithoutAssignmentsInput = {
    where: care_logsWhereUniqueInput
    update: XOR<care_logsUpdateWithoutAssignmentsInput, care_logsUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<care_logsCreateWithoutAssignmentsInput, care_logsUncheckedCreateWithoutAssignmentsInput>
  }

  export type care_logsUpdateWithWhereUniqueWithoutAssignmentsInput = {
    where: care_logsWhereUniqueInput
    data: XOR<care_logsUpdateWithoutAssignmentsInput, care_logsUncheckedUpdateWithoutAssignmentsInput>
  }

  export type care_logsUpdateManyWithWhereWithoutAssignmentsInput = {
    where: care_logsScalarWhereInput
    data: XOR<care_logsUpdateManyMutationInput, care_logsUncheckedUpdateManyWithoutAssignmentsInput>
  }

  export type care_logsScalarWhereInput = {
    AND?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
    OR?: care_logsScalarWhereInput[]
    NOT?: care_logsScalarWhereInput | care_logsScalarWhereInput[]
    id?: StringFilter<"care_logs"> | string
    job_id?: StringFilter<"care_logs"> | string
    assignment_id?: StringNullableFilter<"care_logs"> | string | null
    caregiver_id?: StringFilter<"care_logs"> | string
    patient_id?: StringFilter<"care_logs"> | string
    log_type?: EnumCareLogTypeFilter<"care_logs"> | $Enums.CareLogType
    timestamp?: DateTimeFilter<"care_logs"> | Date | string
    location_lat?: DecimalNullableFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableFilter<"care_logs"> | Decimal | DecimalJsLike | number | string | null
    data?: JsonFilter<"care_logs">
    notes?: StringNullableFilter<"care_logs"> | string | null
    photo_urls?: JsonNullableFilter<"care_logs">
    guardian_notified?: BoolFilter<"care_logs"> | boolean
    createdAt?: DateTimeFilter<"care_logs"> | Date | string
  }

  export type usersCreateWithoutAudit_logsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAudit_logsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAudit_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
  }

  export type usersUpsertWithoutAudit_logsInput = {
    update: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
    create: XOR<usersCreateWithoutAudit_logsInput, usersUncheckedCreateWithoutAudit_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAudit_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAudit_logsInput, usersUncheckedUpdateWithoutAudit_logsInput>
  }

  export type usersUpdateWithoutAudit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAudit_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type patientsCreateWithoutCare_logsInput = {
    id?: string
    user_id?: string | null
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    health_records?: health_recordsCreateNestedManyWithoutPatientsInput
    jobs?: jobsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutCare_logsInput = {
    id?: string
    user_id?: string | null
    guardian_id: string
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    health_records?: health_recordsUncheckedCreateNestedManyWithoutPatientsInput
    jobs?: jobsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutCare_logsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutCare_logsInput, patientsUncheckedCreateWithoutCare_logsInput>
  }

  export type caregiversCreateWithoutCare_logsInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    companies?: companiesCreateNestedOneWithoutCaregiversInput
    users: usersCreateNestedOneWithoutCaregiversInput
    job_applications?: job_applicationsCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateWithoutCare_logsInput = {
    id?: string
    userId: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversCreateOrConnectWithoutCare_logsInput = {
    where: caregiversWhereUniqueInput
    create: XOR<caregiversCreateWithoutCare_logsInput, caregiversUncheckedCreateWithoutCare_logsInput>
  }

  export type assignmentsCreateWithoutCare_logsInput = {
    id?: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversCreateNestedOneWithoutAssignments_assignments_replaced_byTocaregiversInput
    caregivers_assignments_caregiver_idTocaregivers: caregiversCreateNestedOneWithoutAssignments_assignments_caregiver_idTocaregiversInput
    jobs: jobsCreateNestedOneWithoutAssignmentsInput
  }

  export type assignmentsUncheckedCreateWithoutCare_logsInput = {
    id?: string
    job_id: string
    caregiver_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replaced_by?: string | null
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type assignmentsCreateOrConnectWithoutCare_logsInput = {
    where: assignmentsWhereUniqueInput
    create: XOR<assignmentsCreateWithoutCare_logsInput, assignmentsUncheckedCreateWithoutCare_logsInput>
  }

  export type jobsCreateWithoutCare_logsInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutCare_logsInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutCare_logsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutCare_logsInput, jobsUncheckedCreateWithoutCare_logsInput>
  }

  export type patientsUpsertWithoutCare_logsInput = {
    update: XOR<patientsUpdateWithoutCare_logsInput, patientsUncheckedUpdateWithoutCare_logsInput>
    create: XOR<patientsCreateWithoutCare_logsInput, patientsUncheckedCreateWithoutCare_logsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutCare_logsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutCare_logsInput, patientsUncheckedUpdateWithoutCare_logsInput>
  }

  export type patientsUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    health_records?: health_recordsUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    health_records?: health_recordsUncheckedUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type caregiversUpsertWithoutCare_logsInput = {
    update: XOR<caregiversUpdateWithoutCare_logsInput, caregiversUncheckedUpdateWithoutCare_logsInput>
    create: XOR<caregiversCreateWithoutCare_logsInput, caregiversUncheckedCreateWithoutCare_logsInput>
    where?: caregiversWhereInput
  }

  export type caregiversUpdateToOneWithWhereWithoutCare_logsInput = {
    where?: caregiversWhereInput
    data: XOR<caregiversUpdateWithoutCare_logsInput, caregiversUncheckedUpdateWithoutCare_logsInput>
  }

  export type caregiversUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    companies?: companiesUpdateOneWithoutCaregiversNestedInput
    users?: usersUpdateOneRequiredWithoutCaregiversNestedInput
    job_applications?: job_applicationsUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type assignmentsUpsertWithoutCare_logsInput = {
    update: XOR<assignmentsUpdateWithoutCare_logsInput, assignmentsUncheckedUpdateWithoutCare_logsInput>
    create: XOR<assignmentsCreateWithoutCare_logsInput, assignmentsUncheckedCreateWithoutCare_logsInput>
    where?: assignmentsWhereInput
  }

  export type assignmentsUpdateToOneWithWhereWithoutCare_logsInput = {
    where?: assignmentsWhereInput
    data: XOR<assignmentsUpdateWithoutCare_logsInput, assignmentsUncheckedUpdateWithoutCare_logsInput>
  }

  export type assignmentsUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversUpdateOneWithoutAssignments_assignments_replaced_byTocaregiversNestedInput
    caregivers_assignments_caregiver_idTocaregivers?: caregiversUpdateOneRequiredWithoutAssignments_assignments_caregiver_idTocaregiversNestedInput
    jobs?: jobsUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replaced_by?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsUpsertWithoutCare_logsInput = {
    update: XOR<jobsUpdateWithoutCare_logsInput, jobsUncheckedUpdateWithoutCare_logsInput>
    create: XOR<jobsCreateWithoutCare_logsInput, jobsUncheckedCreateWithoutCare_logsInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutCare_logsInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutCare_logsInput, jobsUncheckedUpdateWithoutCare_logsInput>
  }

  export type jobsUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutCare_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    id?: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers_assignments_caregiver_idTocaregivers: caregiversCreateNestedOneWithoutAssignments_assignments_caregiver_idTocaregiversInput
    jobs: jobsCreateNestedOneWithoutAssignmentsInput
    care_logs?: care_logsCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    id?: string
    job_id: string
    caregiver_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsCreateOrConnectWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    where: assignmentsWhereUniqueInput
    create: XOR<assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput>
  }

  export type assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInputEnvelope = {
    data: assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInput | assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInput[]
    skipDuplicates?: boolean
  }

  export type assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    id?: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversCreateNestedOneWithoutAssignments_assignments_replaced_byTocaregiversInput
    jobs: jobsCreateNestedOneWithoutAssignmentsInput
    care_logs?: care_logsCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    id?: string
    job_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replaced_by?: string | null
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsCreateOrConnectWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    where: assignmentsWhereUniqueInput
    create: XOR<assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput>
  }

  export type assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInputEnvelope = {
    data: assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInput | assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInput[]
    skipDuplicates?: boolean
  }

  export type care_logsCreateWithoutCaregiversInput = {
    id?: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
    patients: patientsCreateNestedOneWithoutCare_logsInput
    assignments?: assignmentsCreateNestedOneWithoutCare_logsInput
    jobs: jobsCreateNestedOneWithoutCare_logsInput
  }

  export type care_logsUncheckedCreateWithoutCaregiversInput = {
    id?: string
    job_id: string
    assignment_id?: string | null
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type care_logsCreateOrConnectWithoutCaregiversInput = {
    where: care_logsWhereUniqueInput
    create: XOR<care_logsCreateWithoutCaregiversInput, care_logsUncheckedCreateWithoutCaregiversInput>
  }

  export type care_logsCreateManyCaregiversInputEnvelope = {
    data: care_logsCreateManyCaregiversInput | care_logsCreateManyCaregiversInput[]
    skipDuplicates?: boolean
  }

  export type companiesCreateWithoutCaregiversInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    jobs?: jobsCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCompaniesInput
    packages?: packagesCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCaregiversInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    jobs?: jobsUncheckedCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCompaniesInput
    packages?: packagesUncheckedCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCaregiversInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCaregiversInput, companiesUncheckedCreateWithoutCaregiversInput>
  }

  export type usersCreateWithoutCaregiversInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCaregiversInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCaregiversInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCaregiversInput, usersUncheckedCreateWithoutCaregiversInput>
  }

  export type job_applicationsCreateWithoutCaregiversInput = {
    id?: string
    coverLetter?: string | null
    status?: string
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
    users?: usersCreateNestedOneWithoutJob_applicationsInput
    marketplace_jobs: marketplace_jobsCreateNestedOneWithoutJob_applicationsInput
  }

  export type job_applicationsUncheckedCreateWithoutCaregiversInput = {
    id?: string
    marketplace_job_id: string
    coverLetter?: string | null
    status?: string
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type job_applicationsCreateOrConnectWithoutCaregiversInput = {
    where: job_applicationsWhereUniqueInput
    create: XOR<job_applicationsCreateWithoutCaregiversInput, job_applicationsUncheckedCreateWithoutCaregiversInput>
  }

  export type job_applicationsCreateManyCaregiversInputEnvelope = {
    data: job_applicationsCreateManyCaregiversInput | job_applicationsCreateManyCaregiversInput[]
    skipDuplicates?: boolean
  }

  export type marketplace_jobsCreateWithoutCaregiversInput = {
    id?: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_applications?: job_applicationsCreateNestedManyWithoutMarketplace_jobsInput
    companies: companiesCreateNestedOneWithoutMarketplace_jobsInput
  }

  export type marketplace_jobsUncheckedCreateWithoutCaregiversInput = {
    id?: string
    company_id: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutMarketplace_jobsInput
  }

  export type marketplace_jobsCreateOrConnectWithoutCaregiversInput = {
    where: marketplace_jobsWhereUniqueInput
    create: XOR<marketplace_jobsCreateWithoutCaregiversInput, marketplace_jobsUncheckedCreateWithoutCaregiversInput>
  }

  export type marketplace_jobsCreateManyCaregiversInputEnvelope = {
    data: marketplace_jobsCreateManyCaregiversInput | marketplace_jobsCreateManyCaregiversInput[]
    skipDuplicates?: boolean
  }

  export type assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    where: assignmentsWhereUniqueInput
    update: XOR<assignmentsUpdateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedUpdateWithoutCaregivers_assignments_replaced_byTocaregiversInput>
    create: XOR<assignmentsCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_replaced_byTocaregiversInput>
  }

  export type assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    where: assignmentsWhereUniqueInput
    data: XOR<assignmentsUpdateWithoutCaregivers_assignments_replaced_byTocaregiversInput, assignmentsUncheckedUpdateWithoutCaregivers_assignments_replaced_byTocaregiversInput>
  }

  export type assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    where: assignmentsScalarWhereInput
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversInput>
  }

  export type assignmentsScalarWhereInput = {
    AND?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
    OR?: assignmentsScalarWhereInput[]
    NOT?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
    id?: StringFilter<"assignments"> | string
    job_id?: StringFilter<"assignments"> | string
    caregiver_id?: StringFilter<"assignments"> | string
    role?: EnumAssignmentRoleFilter<"assignments"> | $Enums.AssignmentRole
    shift_start_time?: StringFilter<"assignments"> | string
    shift_end_time?: StringFilter<"assignments"> | string
    days_of_week?: JsonFilter<"assignments">
    status?: EnumAssignmentStatusFilter<"assignments"> | $Enums.AssignmentStatus
    replaced_by?: StringNullableFilter<"assignments"> | string | null
    replacement_reason?: StringNullableFilter<"assignments"> | string | null
    created_at?: DateTimeFilter<"assignments"> | Date | string
    updated_at?: DateTimeFilter<"assignments"> | Date | string
  }

  export type assignmentsUpsertWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    where: assignmentsWhereUniqueInput
    update: XOR<assignmentsUpdateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedUpdateWithoutCaregivers_assignments_caregiver_idTocaregiversInput>
    create: XOR<assignmentsCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedCreateWithoutCaregivers_assignments_caregiver_idTocaregiversInput>
  }

  export type assignmentsUpdateWithWhereUniqueWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    where: assignmentsWhereUniqueInput
    data: XOR<assignmentsUpdateWithoutCaregivers_assignments_caregiver_idTocaregiversInput, assignmentsUncheckedUpdateWithoutCaregivers_assignments_caregiver_idTocaregiversInput>
  }

  export type assignmentsUpdateManyWithWhereWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    where: assignmentsScalarWhereInput
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput>
  }

  export type care_logsUpsertWithWhereUniqueWithoutCaregiversInput = {
    where: care_logsWhereUniqueInput
    update: XOR<care_logsUpdateWithoutCaregiversInput, care_logsUncheckedUpdateWithoutCaregiversInput>
    create: XOR<care_logsCreateWithoutCaregiversInput, care_logsUncheckedCreateWithoutCaregiversInput>
  }

  export type care_logsUpdateWithWhereUniqueWithoutCaregiversInput = {
    where: care_logsWhereUniqueInput
    data: XOR<care_logsUpdateWithoutCaregiversInput, care_logsUncheckedUpdateWithoutCaregiversInput>
  }

  export type care_logsUpdateManyWithWhereWithoutCaregiversInput = {
    where: care_logsScalarWhereInput
    data: XOR<care_logsUpdateManyMutationInput, care_logsUncheckedUpdateManyWithoutCaregiversInput>
  }

  export type companiesUpsertWithoutCaregiversInput = {
    update: XOR<companiesUpdateWithoutCaregiversInput, companiesUncheckedUpdateWithoutCaregiversInput>
    create: XOR<companiesCreateWithoutCaregiversInput, companiesUncheckedCreateWithoutCaregiversInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCaregiversInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCaregiversInput, companiesUncheckedUpdateWithoutCaregiversInput>
  }

  export type companiesUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type usersUpsertWithoutCaregiversInput = {
    update: XOR<usersUpdateWithoutCaregiversInput, usersUncheckedUpdateWithoutCaregiversInput>
    create: XOR<usersCreateWithoutCaregiversInput, usersUncheckedCreateWithoutCaregiversInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCaregiversInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCaregiversInput, usersUncheckedUpdateWithoutCaregiversInput>
  }

  export type usersUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type job_applicationsUpsertWithWhereUniqueWithoutCaregiversInput = {
    where: job_applicationsWhereUniqueInput
    update: XOR<job_applicationsUpdateWithoutCaregiversInput, job_applicationsUncheckedUpdateWithoutCaregiversInput>
    create: XOR<job_applicationsCreateWithoutCaregiversInput, job_applicationsUncheckedCreateWithoutCaregiversInput>
  }

  export type job_applicationsUpdateWithWhereUniqueWithoutCaregiversInput = {
    where: job_applicationsWhereUniqueInput
    data: XOR<job_applicationsUpdateWithoutCaregiversInput, job_applicationsUncheckedUpdateWithoutCaregiversInput>
  }

  export type job_applicationsUpdateManyWithWhereWithoutCaregiversInput = {
    where: job_applicationsScalarWhereInput
    data: XOR<job_applicationsUpdateManyMutationInput, job_applicationsUncheckedUpdateManyWithoutCaregiversInput>
  }

  export type job_applicationsScalarWhereInput = {
    AND?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
    OR?: job_applicationsScalarWhereInput[]
    NOT?: job_applicationsScalarWhereInput | job_applicationsScalarWhereInput[]
    id?: StringFilter<"job_applications"> | string
    marketplace_job_id?: StringFilter<"job_applications"> | string
    caregiver_id?: StringFilter<"job_applications"> | string
    coverLetter?: StringNullableFilter<"job_applications"> | string | null
    status?: StringFilter<"job_applications"> | string
    reviewed_by?: StringNullableFilter<"job_applications"> | string | null
    reviewed_at?: DateTimeNullableFilter<"job_applications"> | Date | string | null
    review_notes?: StringNullableFilter<"job_applications"> | string | null
    created_at?: DateTimeFilter<"job_applications"> | Date | string
  }

  export type marketplace_jobsUpsertWithWhereUniqueWithoutCaregiversInput = {
    where: marketplace_jobsWhereUniqueInput
    update: XOR<marketplace_jobsUpdateWithoutCaregiversInput, marketplace_jobsUncheckedUpdateWithoutCaregiversInput>
    create: XOR<marketplace_jobsCreateWithoutCaregiversInput, marketplace_jobsUncheckedCreateWithoutCaregiversInput>
  }

  export type marketplace_jobsUpdateWithWhereUniqueWithoutCaregiversInput = {
    where: marketplace_jobsWhereUniqueInput
    data: XOR<marketplace_jobsUpdateWithoutCaregiversInput, marketplace_jobsUncheckedUpdateWithoutCaregiversInput>
  }

  export type marketplace_jobsUpdateManyWithWhereWithoutCaregiversInput = {
    where: marketplace_jobsScalarWhereInput
    data: XOR<marketplace_jobsUpdateManyMutationInput, marketplace_jobsUncheckedUpdateManyWithoutCaregiversInput>
  }

  export type marketplace_jobsScalarWhereInput = {
    AND?: marketplace_jobsScalarWhereInput | marketplace_jobsScalarWhereInput[]
    OR?: marketplace_jobsScalarWhereInput[]
    NOT?: marketplace_jobsScalarWhereInput | marketplace_jobsScalarWhereInput[]
    id?: StringFilter<"marketplace_jobs"> | string
    company_id?: StringFilter<"marketplace_jobs"> | string
    title?: StringFilter<"marketplace_jobs"> | string
    description?: StringFilter<"marketplace_jobs"> | string
    location?: StringFilter<"marketplace_jobs"> | string
    required_skills?: JsonFilter<"marketplace_jobs">
    start_date?: DateTimeFilter<"marketplace_jobs"> | Date | string
    duration_days?: IntFilter<"marketplace_jobs"> | number
    hours_per_day?: IntFilter<"marketplace_jobs"> | number
    offered_rate?: DecimalFilter<"marketplace_jobs"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"marketplace_jobs"> | string
    applications_count?: IntFilter<"marketplace_jobs"> | number
    filled_by?: StringNullableFilter<"marketplace_jobs"> | string | null
    filled_at?: DateTimeNullableFilter<"marketplace_jobs"> | Date | string | null
    created_at?: DateTimeFilter<"marketplace_jobs"> | Date | string
    updated_at?: DateTimeFilter<"marketplace_jobs"> | Date | string
  }

  export type caregiversCreateWithoutCompaniesInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutCaregiversInput
    users: usersCreateNestedOneWithoutCaregiversInput
    job_applications?: job_applicationsCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateWithoutCompaniesInput = {
    id?: string
    userId: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutCaregiversInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversCreateOrConnectWithoutCompaniesInput = {
    where: caregiversWhereUniqueInput
    create: XOR<caregiversCreateWithoutCompaniesInput, caregiversUncheckedCreateWithoutCompaniesInput>
  }

  export type caregiversCreateManyCompaniesInputEnvelope = {
    data: caregiversCreateManyCompaniesInput | caregiversCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type jobsCreateWithoutCompaniesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutCompaniesInput = {
    id?: string
    package_id: string
    patient_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutCompaniesInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutCompaniesInput, jobsUncheckedCreateWithoutCompaniesInput>
  }

  export type jobsCreateManyCompaniesInputEnvelope = {
    data: jobsCreateManyCompaniesInput | jobsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type marketplace_jobsCreateWithoutCompaniesInput = {
    id?: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_applications?: job_applicationsCreateNestedManyWithoutMarketplace_jobsInput
    caregivers?: caregiversCreateNestedOneWithoutMarketplace_jobsInput
  }

  export type marketplace_jobsUncheckedCreateWithoutCompaniesInput = {
    id?: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_by?: string | null
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutMarketplace_jobsInput
  }

  export type marketplace_jobsCreateOrConnectWithoutCompaniesInput = {
    where: marketplace_jobsWhereUniqueInput
    create: XOR<marketplace_jobsCreateWithoutCompaniesInput, marketplace_jobsUncheckedCreateWithoutCompaniesInput>
  }

  export type marketplace_jobsCreateManyCompaniesInputEnvelope = {
    data: marketplace_jobsCreateManyCompaniesInput | marketplace_jobsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type packagesCreateWithoutCompaniesInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
    jobs?: jobsCreateNestedManyWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutCompaniesInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
    jobs?: jobsUncheckedCreateNestedManyWithoutPackagesInput
  }

  export type packagesCreateOrConnectWithoutCompaniesInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutCompaniesInput, packagesUncheckedCreateWithoutCompaniesInput>
  }

  export type packagesCreateManyCompaniesInputEnvelope = {
    data: packagesCreateManyCompaniesInput | packagesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type service_zonesCreateWithoutCompaniesInput = {
    id?: string
    zone_name: string
    region_code: string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_zonesUncheckedCreateWithoutCompaniesInput = {
    id?: string
    zone_name: string
    region_code: string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_zonesCreateOrConnectWithoutCompaniesInput = {
    where: service_zonesWhereUniqueInput
    create: XOR<service_zonesCreateWithoutCompaniesInput, service_zonesUncheckedCreateWithoutCompaniesInput>
  }

  export type service_zonesCreateManyCompaniesInputEnvelope = {
    data: service_zonesCreateManyCompaniesInput | service_zonesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutCompaniesInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCompaniesInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
  }

  export type usersCreateManyCompaniesInputEnvelope = {
    data: usersCreateManyCompaniesInput | usersCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type caregiversUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: caregiversWhereUniqueInput
    update: XOR<caregiversUpdateWithoutCompaniesInput, caregiversUncheckedUpdateWithoutCompaniesInput>
    create: XOR<caregiversCreateWithoutCompaniesInput, caregiversUncheckedCreateWithoutCompaniesInput>
  }

  export type caregiversUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: caregiversWhereUniqueInput
    data: XOR<caregiversUpdateWithoutCompaniesInput, caregiversUncheckedUpdateWithoutCompaniesInput>
  }

  export type caregiversUpdateManyWithWhereWithoutCompaniesInput = {
    where: caregiversScalarWhereInput
    data: XOR<caregiversUpdateManyMutationInput, caregiversUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type caregiversScalarWhereInput = {
    AND?: caregiversScalarWhereInput | caregiversScalarWhereInput[]
    OR?: caregiversScalarWhereInput[]
    NOT?: caregiversScalarWhereInput | caregiversScalarWhereInput[]
    id?: StringFilter<"caregivers"> | string
    userId?: StringFilter<"caregivers"> | string
    company_id?: StringNullableFilter<"caregivers"> | string | null
    nid?: StringFilter<"caregivers"> | string
    nid_url?: StringFilter<"caregivers"> | string
    photo_url?: StringFilter<"caregivers"> | string
    date_of_birth?: DateTimeFilter<"caregivers"> | Date | string
    gender?: EnumGenderFilter<"caregivers"> | $Enums.Gender
    address?: StringFilter<"caregivers"> | string
    location_lat?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    location_lng?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    skills?: JsonFilter<"caregivers">
    certifications?: JsonNullableFilter<"caregivers">
    experience_years?: IntFilter<"caregivers"> | number
    languages?: JsonFilter<"caregivers">
    availabilityCalendar?: JsonNullableFilter<"caregivers">
    hourly_rate?: DecimalNullableFilter<"caregivers"> | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFilter<"caregivers"> | $Enums.BackgroundCheckStatus
    background_check_date?: DateTimeNullableFilter<"caregivers"> | Date | string | null
    rating_avg?: DecimalFilter<"caregivers"> | Decimal | DecimalJsLike | number | string
    rating_count?: IntFilter<"caregivers"> | number
    total_jobs_completed?: IntFilter<"caregivers"> | number
    is_available?: BoolFilter<"caregivers"> | boolean
    is_verified?: BoolFilter<"caregivers"> | boolean
    verification_notes?: StringNullableFilter<"caregivers"> | string | null
    deleted_at?: DateTimeNullableFilter<"caregivers"> | Date | string | null
    created_at?: DateTimeFilter<"caregivers"> | Date | string
    updated_at?: DateTimeFilter<"caregivers"> | Date | string
  }

  export type jobsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: jobsWhereUniqueInput
    update: XOR<jobsUpdateWithoutCompaniesInput, jobsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<jobsCreateWithoutCompaniesInput, jobsUncheckedCreateWithoutCompaniesInput>
  }

  export type jobsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: jobsWhereUniqueInput
    data: XOR<jobsUpdateWithoutCompaniesInput, jobsUncheckedUpdateWithoutCompaniesInput>
  }

  export type jobsUpdateManyWithWhereWithoutCompaniesInput = {
    where: jobsScalarWhereInput
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type jobsScalarWhereInput = {
    AND?: jobsScalarWhereInput | jobsScalarWhereInput[]
    OR?: jobsScalarWhereInput[]
    NOT?: jobsScalarWhereInput | jobsScalarWhereInput[]
    id?: StringFilter<"jobs"> | string
    package_id?: StringFilter<"jobs"> | string
    patient_id?: StringFilter<"jobs"> | string
    company_id?: StringFilter<"jobs"> | string
    guardian_id?: StringFilter<"jobs"> | string
    start_date?: DateTimeFilter<"jobs"> | Date | string
    end_date?: DateTimeFilter<"jobs"> | Date | string
    status?: EnumJobStatusFilter<"jobs"> | $Enums.JobStatus
    total_price?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFilter<"jobs"> | Decimal | DecimalJsLike | number | string
    special_instructions?: StringNullableFilter<"jobs"> | string | null
    completion_notes?: StringNullableFilter<"jobs"> | string | null
    cancelled_reason?: StringNullableFilter<"jobs"> | string | null
    cancelled_at?: DateTimeNullableFilter<"jobs"> | Date | string | null
    cancelled_by?: StringNullableFilter<"jobs"> | string | null
    created_at?: DateTimeFilter<"jobs"> | Date | string
    updated_at?: DateTimeFilter<"jobs"> | Date | string
  }

  export type marketplace_jobsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: marketplace_jobsWhereUniqueInput
    update: XOR<marketplace_jobsUpdateWithoutCompaniesInput, marketplace_jobsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<marketplace_jobsCreateWithoutCompaniesInput, marketplace_jobsUncheckedCreateWithoutCompaniesInput>
  }

  export type marketplace_jobsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: marketplace_jobsWhereUniqueInput
    data: XOR<marketplace_jobsUpdateWithoutCompaniesInput, marketplace_jobsUncheckedUpdateWithoutCompaniesInput>
  }

  export type marketplace_jobsUpdateManyWithWhereWithoutCompaniesInput = {
    where: marketplace_jobsScalarWhereInput
    data: XOR<marketplace_jobsUpdateManyMutationInput, marketplace_jobsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type packagesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: packagesWhereUniqueInput
    update: XOR<packagesUpdateWithoutCompaniesInput, packagesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<packagesCreateWithoutCompaniesInput, packagesUncheckedCreateWithoutCompaniesInput>
  }

  export type packagesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: packagesWhereUniqueInput
    data: XOR<packagesUpdateWithoutCompaniesInput, packagesUncheckedUpdateWithoutCompaniesInput>
  }

  export type packagesUpdateManyWithWhereWithoutCompaniesInput = {
    where: packagesScalarWhereInput
    data: XOR<packagesUpdateManyMutationInput, packagesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type packagesScalarWhereInput = {
    AND?: packagesScalarWhereInput | packagesScalarWhereInput[]
    OR?: packagesScalarWhereInput[]
    NOT?: packagesScalarWhereInput | packagesScalarWhereInput[]
    id?: StringFilter<"packages"> | string
    company_id?: StringFilter<"packages"> | string
    name?: StringFilter<"packages"> | string
    description?: StringFilter<"packages"> | string
    category?: EnumPackageCategoryFilter<"packages"> | $Enums.PackageCategory
    price?: DecimalFilter<"packages"> | Decimal | DecimalJsLike | number | string
    duration_days?: IntFilter<"packages"> | number
    hours_per_day?: IntFilter<"packages"> | number
    inclusions?: JsonFilter<"packages">
    exclusions?: JsonNullableFilter<"packages">
    caregiver_count?: IntFilter<"packages"> | number
    is_active?: BoolFilter<"packages"> | boolean
    min_advance_days?: IntFilter<"packages"> | number
    created_at?: DateTimeFilter<"packages"> | Date | string
    updated_at?: DateTimeFilter<"packages"> | Date | string
  }

  export type service_zonesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: service_zonesWhereUniqueInput
    update: XOR<service_zonesUpdateWithoutCompaniesInput, service_zonesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<service_zonesCreateWithoutCompaniesInput, service_zonesUncheckedCreateWithoutCompaniesInput>
  }

  export type service_zonesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: service_zonesWhereUniqueInput
    data: XOR<service_zonesUpdateWithoutCompaniesInput, service_zonesUncheckedUpdateWithoutCompaniesInput>
  }

  export type service_zonesUpdateManyWithWhereWithoutCompaniesInput = {
    where: service_zonesScalarWhereInput
    data: XOR<service_zonesUpdateManyMutationInput, service_zonesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type service_zonesScalarWhereInput = {
    AND?: service_zonesScalarWhereInput | service_zonesScalarWhereInput[]
    OR?: service_zonesScalarWhereInput[]
    NOT?: service_zonesScalarWhereInput | service_zonesScalarWhereInput[]
    id?: StringFilter<"service_zones"> | string
    company_id?: StringFilter<"service_zones"> | string
    zone_name?: StringFilter<"service_zones"> | string
    region_code?: StringFilter<"service_zones"> | string
    boundary_geojson?: JsonNullableFilter<"service_zones">
    is_active?: BoolFilter<"service_zones"> | boolean
    created_at?: DateTimeFilter<"service_zones"> | Date | string
    updated_at?: DateTimeFilter<"service_zones"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutCompaniesInput, usersUncheckedUpdateWithoutCompaniesInput>
    create: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutCompaniesInput, usersUncheckedUpdateWithoutCompaniesInput>
  }

  export type usersUpdateManyWithWhereWithoutCompaniesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: StringFilter<"users"> | string
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    phone?: StringFilter<"users"> | string
    email?: StringNullableFilter<"users"> | string | null
    password_hash?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    language?: StringFilter<"users"> | string
    kyc_status?: EnumKYCStatusFilter<"users"> | $Enums.KYCStatus
    kyc_document_url?: StringNullableFilter<"users"> | string | null
    mfa_enabled?: BoolFilter<"users"> | boolean
    mfa_secret?: StringNullableFilter<"users"> | string | null
    last_login_at?: DateTimeNullableFilter<"users"> | Date | string | null
    is_active?: BoolFilter<"users"> | boolean
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    company_id?: StringNullableFilter<"users"> | string | null
  }

  export type usersCreateWithoutDisputes_disputes_againstTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutDisputes_disputes_againstTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutDisputes_disputes_againstTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDisputes_disputes_againstTousersInput, usersUncheckedCreateWithoutDisputes_disputes_againstTousersInput>
  }

  export type usersCreateWithoutDisputes_disputes_raised_byTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutDisputes_disputes_raised_byTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutDisputes_disputes_raised_byTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDisputes_disputes_raised_byTousersInput, usersUncheckedCreateWithoutDisputes_disputes_raised_byTousersInput>
  }

  export type jobsCreateWithoutDisputesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutDisputesInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutDisputesInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutDisputesInput, jobsUncheckedCreateWithoutDisputesInput>
  }

  export type usersUpsertWithoutDisputes_disputes_againstTousersInput = {
    update: XOR<usersUpdateWithoutDisputes_disputes_againstTousersInput, usersUncheckedUpdateWithoutDisputes_disputes_againstTousersInput>
    create: XOR<usersCreateWithoutDisputes_disputes_againstTousersInput, usersUncheckedCreateWithoutDisputes_disputes_againstTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDisputes_disputes_againstTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDisputes_disputes_againstTousersInput, usersUncheckedUpdateWithoutDisputes_disputes_againstTousersInput>
  }

  export type usersUpdateWithoutDisputes_disputes_againstTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutDisputes_disputes_againstTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutDisputes_disputes_raised_byTousersInput = {
    update: XOR<usersUpdateWithoutDisputes_disputes_raised_byTousersInput, usersUncheckedUpdateWithoutDisputes_disputes_raised_byTousersInput>
    create: XOR<usersCreateWithoutDisputes_disputes_raised_byTousersInput, usersUncheckedCreateWithoutDisputes_disputes_raised_byTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDisputes_disputes_raised_byTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDisputes_disputes_raised_byTousersInput, usersUncheckedUpdateWithoutDisputes_disputes_raised_byTousersInput>
  }

  export type usersUpdateWithoutDisputes_disputes_raised_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutDisputes_disputes_raised_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type jobsUpsertWithoutDisputesInput = {
    update: XOR<jobsUpdateWithoutDisputesInput, jobsUncheckedUpdateWithoutDisputesInput>
    create: XOR<jobsCreateWithoutDisputesInput, jobsUncheckedCreateWithoutDisputesInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutDisputesInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutDisputesInput, jobsUncheckedUpdateWithoutDisputesInput>
  }

  export type jobsUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type paymentsCreateWithoutEscrowsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutPaymentsInput
    jobs?: jobsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutEscrowsInput = {
    id?: string
    job_id?: string | null
    payer_id: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type paymentsCreateOrConnectWithoutEscrowsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutEscrowsInput, paymentsUncheckedCreateWithoutEscrowsInput>
  }

  export type paymentsUpsertWithoutEscrowsInput = {
    update: XOR<paymentsUpdateWithoutEscrowsInput, paymentsUncheckedUpdateWithoutEscrowsInput>
    create: XOR<paymentsCreateWithoutEscrowsInput, paymentsUncheckedCreateWithoutEscrowsInput>
    where?: paymentsWhereInput
  }

  export type paymentsUpdateToOneWithWhereWithoutEscrowsInput = {
    where?: paymentsWhereInput
    data: XOR<paymentsUpdateWithoutEscrowsInput, paymentsUncheckedUpdateWithoutEscrowsInput>
  }

  export type paymentsUpdateWithoutEscrowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutPaymentsNestedInput
    jobs?: jobsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutEscrowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    payer_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_ledgerCreateWithoutEscrow_recordsInput = {
    id?: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput = {
    id?: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_ledgerCreateOrConnectWithoutEscrow_recordsInput = {
    where: escrow_ledgerWhereUniqueInput
    create: XOR<escrow_ledgerCreateWithoutEscrow_recordsInput, escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput>
  }

  export type escrow_ledgerCreateManyEscrow_recordsInputEnvelope = {
    data: escrow_ledgerCreateManyEscrow_recordsInput | escrow_ledgerCreateManyEscrow_recordsInput[]
    skipDuplicates?: boolean
  }

  export type escrow_ledgerUpsertWithWhereUniqueWithoutEscrow_recordsInput = {
    where: escrow_ledgerWhereUniqueInput
    update: XOR<escrow_ledgerUpdateWithoutEscrow_recordsInput, escrow_ledgerUncheckedUpdateWithoutEscrow_recordsInput>
    create: XOR<escrow_ledgerCreateWithoutEscrow_recordsInput, escrow_ledgerUncheckedCreateWithoutEscrow_recordsInput>
  }

  export type escrow_ledgerUpdateWithWhereUniqueWithoutEscrow_recordsInput = {
    where: escrow_ledgerWhereUniqueInput
    data: XOR<escrow_ledgerUpdateWithoutEscrow_recordsInput, escrow_ledgerUncheckedUpdateWithoutEscrow_recordsInput>
  }

  export type escrow_ledgerUpdateManyWithWhereWithoutEscrow_recordsInput = {
    where: escrow_ledgerScalarWhereInput
    data: XOR<escrow_ledgerUpdateManyMutationInput, escrow_ledgerUncheckedUpdateManyWithoutEscrow_recordsInput>
  }

  export type escrow_ledgerScalarWhereInput = {
    AND?: escrow_ledgerScalarWhereInput | escrow_ledgerScalarWhereInput[]
    OR?: escrow_ledgerScalarWhereInput[]
    NOT?: escrow_ledgerScalarWhereInput | escrow_ledgerScalarWhereInput[]
    id?: StringFilter<"escrow_ledger"> | string
    escrow_id?: StringFilter<"escrow_ledger"> | string
    action?: StringFilter<"escrow_ledger"> | string
    amount?: DecimalFilter<"escrow_ledger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"escrow_ledger"> | string | null
    created_at?: DateTimeFilter<"escrow_ledger"> | Date | string
    updated_at?: DateTimeFilter<"escrow_ledger"> | Date | string
  }

  export type escrow_recordsCreateWithoutLedger_entriesInput = {
    id?: string
    external_ref?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_recordsUncheckedCreateWithoutLedger_entriesInput = {
    id?: string
    external_ref?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_recordsCreateOrConnectWithoutLedger_entriesInput = {
    where: escrow_recordsWhereUniqueInput
    create: XOR<escrow_recordsCreateWithoutLedger_entriesInput, escrow_recordsUncheckedCreateWithoutLedger_entriesInput>
  }

  export type escrow_recordsUpsertWithoutLedger_entriesInput = {
    update: XOR<escrow_recordsUpdateWithoutLedger_entriesInput, escrow_recordsUncheckedUpdateWithoutLedger_entriesInput>
    create: XOR<escrow_recordsCreateWithoutLedger_entriesInput, escrow_recordsUncheckedCreateWithoutLedger_entriesInput>
    where?: escrow_recordsWhereInput
  }

  export type escrow_recordsUpdateToOneWithWhereWithoutLedger_entriesInput = {
    where?: escrow_recordsWhereInput
    data: XOR<escrow_recordsUpdateWithoutLedger_entriesInput, escrow_recordsUncheckedUpdateWithoutLedger_entriesInput>
  }

  export type escrow_recordsUpdateWithoutLedger_entriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_ref?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_recordsUncheckedUpdateWithoutLedger_entriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    external_ref?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaction_logsCreateWithoutProvider_transactionsInput = {
    id?: string
    action: string
    previous_status?: string | null
    new_status: string
    note?: string | null
    created_at?: Date | string
  }

  export type transaction_logsUncheckedCreateWithoutProvider_transactionsInput = {
    id?: string
    action: string
    previous_status?: string | null
    new_status: string
    note?: string | null
    created_at?: Date | string
  }

  export type transaction_logsCreateOrConnectWithoutProvider_transactionsInput = {
    where: transaction_logsWhereUniqueInput
    create: XOR<transaction_logsCreateWithoutProvider_transactionsInput, transaction_logsUncheckedCreateWithoutProvider_transactionsInput>
  }

  export type transaction_logsCreateManyProvider_transactionsInputEnvelope = {
    data: transaction_logsCreateManyProvider_transactionsInput | transaction_logsCreateManyProvider_transactionsInput[]
    skipDuplicates?: boolean
  }

  export type transaction_logsUpsertWithWhereUniqueWithoutProvider_transactionsInput = {
    where: transaction_logsWhereUniqueInput
    update: XOR<transaction_logsUpdateWithoutProvider_transactionsInput, transaction_logsUncheckedUpdateWithoutProvider_transactionsInput>
    create: XOR<transaction_logsCreateWithoutProvider_transactionsInput, transaction_logsUncheckedCreateWithoutProvider_transactionsInput>
  }

  export type transaction_logsUpdateWithWhereUniqueWithoutProvider_transactionsInput = {
    where: transaction_logsWhereUniqueInput
    data: XOR<transaction_logsUpdateWithoutProvider_transactionsInput, transaction_logsUncheckedUpdateWithoutProvider_transactionsInput>
  }

  export type transaction_logsUpdateManyWithWhereWithoutProvider_transactionsInput = {
    where: transaction_logsScalarWhereInput
    data: XOR<transaction_logsUpdateManyMutationInput, transaction_logsUncheckedUpdateManyWithoutProvider_transactionsInput>
  }

  export type transaction_logsScalarWhereInput = {
    AND?: transaction_logsScalarWhereInput | transaction_logsScalarWhereInput[]
    OR?: transaction_logsScalarWhereInput[]
    NOT?: transaction_logsScalarWhereInput | transaction_logsScalarWhereInput[]
    id?: StringFilter<"transaction_logs"> | string
    provider_transaction_id?: StringFilter<"transaction_logs"> | string
    action?: StringFilter<"transaction_logs"> | string
    previous_status?: StringNullableFilter<"transaction_logs"> | string | null
    new_status?: StringFilter<"transaction_logs"> | string
    note?: StringNullableFilter<"transaction_logs"> | string | null
    created_at?: DateTimeFilter<"transaction_logs"> | Date | string
  }

  export type provider_transactionsCreateWithoutLogsInput = {
    id?: string
    provider: string
    provider_tx_id: string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type provider_transactionsUncheckedCreateWithoutLogsInput = {
    id?: string
    provider: string
    provider_tx_id: string
    status: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type provider_transactionsCreateOrConnectWithoutLogsInput = {
    where: provider_transactionsWhereUniqueInput
    create: XOR<provider_transactionsCreateWithoutLogsInput, provider_transactionsUncheckedCreateWithoutLogsInput>
  }

  export type provider_transactionsUpsertWithoutLogsInput = {
    update: XOR<provider_transactionsUpdateWithoutLogsInput, provider_transactionsUncheckedUpdateWithoutLogsInput>
    create: XOR<provider_transactionsCreateWithoutLogsInput, provider_transactionsUncheckedCreateWithoutLogsInput>
    where?: provider_transactionsWhereInput
  }

  export type provider_transactionsUpdateToOneWithWhereWithoutLogsInput = {
    where?: provider_transactionsWhereInput
    data: XOR<provider_transactionsUpdateWithoutLogsInput, provider_transactionsUncheckedUpdateWithoutLogsInput>
  }

  export type provider_transactionsUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_tx_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type provider_transactionsUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_tx_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    escrow_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput>
  }

  export type usersCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput>
  }

  export type usersUpsertWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    update: XOR<usersUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput, usersUncheckedUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput>
    create: XOR<usersCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_to_user_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput, usersUncheckedUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput>
  }

  export type usersUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFeedbacks_feedbacks_to_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    update: XOR<usersUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput, usersUncheckedUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput>
    create: XOR<usersCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput, usersUncheckedCreateWithoutFeedbacks_feedbacks_from_user_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput, usersUncheckedUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput>
  }

  export type usersUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFeedbacks_feedbacks_from_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type patientsCreateWithoutHealth_recordsInput = {
    id?: string
    user_id?: string | null
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsCreateNestedManyWithoutPatientsInput
    jobs?: jobsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutHealth_recordsInput = {
    id?: string
    user_id?: string | null
    guardian_id: string
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutPatientsInput
    jobs?: jobsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutHealth_recordsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutHealth_recordsInput, patientsUncheckedCreateWithoutHealth_recordsInput>
  }

  export type patientsUpsertWithoutHealth_recordsInput = {
    update: XOR<patientsUpdateWithoutHealth_recordsInput, patientsUncheckedUpdateWithoutHealth_recordsInput>
    create: XOR<patientsCreateWithoutHealth_recordsInput, patientsUncheckedCreateWithoutHealth_recordsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutHealth_recordsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutHealth_recordsInput, patientsUncheckedUpdateWithoutHealth_recordsInput>
  }

  export type patientsUpdateWithoutHealth_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutHealth_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type usersCreateWithoutJob_applicationsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutJob_applicationsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutJob_applicationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutJob_applicationsInput, usersUncheckedCreateWithoutJob_applicationsInput>
  }

  export type caregiversCreateWithoutJob_applicationsInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutCaregiversInput
    companies?: companiesCreateNestedOneWithoutCaregiversInput
    users: usersCreateNestedOneWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateWithoutJob_applicationsInput = {
    id?: string
    userId: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversCreateOrConnectWithoutJob_applicationsInput = {
    where: caregiversWhereUniqueInput
    create: XOR<caregiversCreateWithoutJob_applicationsInput, caregiversUncheckedCreateWithoutJob_applicationsInput>
  }

  export type marketplace_jobsCreateWithoutJob_applicationsInput = {
    id?: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedOneWithoutMarketplace_jobsInput
    companies: companiesCreateNestedOneWithoutMarketplace_jobsInput
  }

  export type marketplace_jobsUncheckedCreateWithoutJob_applicationsInput = {
    id?: string
    company_id: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_by?: string | null
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type marketplace_jobsCreateOrConnectWithoutJob_applicationsInput = {
    where: marketplace_jobsWhereUniqueInput
    create: XOR<marketplace_jobsCreateWithoutJob_applicationsInput, marketplace_jobsUncheckedCreateWithoutJob_applicationsInput>
  }

  export type usersUpsertWithoutJob_applicationsInput = {
    update: XOR<usersUpdateWithoutJob_applicationsInput, usersUncheckedUpdateWithoutJob_applicationsInput>
    create: XOR<usersCreateWithoutJob_applicationsInput, usersUncheckedCreateWithoutJob_applicationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutJob_applicationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutJob_applicationsInput, usersUncheckedUpdateWithoutJob_applicationsInput>
  }

  export type usersUpdateWithoutJob_applicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutJob_applicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type caregiversUpsertWithoutJob_applicationsInput = {
    update: XOR<caregiversUpdateWithoutJob_applicationsInput, caregiversUncheckedUpdateWithoutJob_applicationsInput>
    create: XOR<caregiversCreateWithoutJob_applicationsInput, caregiversUncheckedCreateWithoutJob_applicationsInput>
    where?: caregiversWhereInput
  }

  export type caregiversUpdateToOneWithWhereWithoutJob_applicationsInput = {
    where?: caregiversWhereInput
    data: XOR<caregiversUpdateWithoutJob_applicationsInput, caregiversUncheckedUpdateWithoutJob_applicationsInput>
  }

  export type caregiversUpdateWithoutJob_applicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutCaregiversNestedInput
    companies?: companiesUpdateOneWithoutCaregiversNestedInput
    users?: usersUpdateOneRequiredWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateWithoutJob_applicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type marketplace_jobsUpsertWithoutJob_applicationsInput = {
    update: XOR<marketplace_jobsUpdateWithoutJob_applicationsInput, marketplace_jobsUncheckedUpdateWithoutJob_applicationsInput>
    create: XOR<marketplace_jobsCreateWithoutJob_applicationsInput, marketplace_jobsUncheckedCreateWithoutJob_applicationsInput>
    where?: marketplace_jobsWhereInput
  }

  export type marketplace_jobsUpdateToOneWithWhereWithoutJob_applicationsInput = {
    where?: marketplace_jobsWhereInput
    data: XOR<marketplace_jobsUpdateWithoutJob_applicationsInput, marketplace_jobsUncheckedUpdateWithoutJob_applicationsInput>
  }

  export type marketplace_jobsUpdateWithoutJob_applicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateOneWithoutMarketplace_jobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutMarketplace_jobsNestedInput
  }

  export type marketplace_jobsUncheckedUpdateWithoutJob_applicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_by?: NullableStringFieldUpdateOperationsInput | string | null
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentsCreateWithoutJobsInput = {
    id?: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversCreateNestedOneWithoutAssignments_assignments_replaced_byTocaregiversInput
    caregivers_assignments_caregiver_idTocaregivers: caregiversCreateNestedOneWithoutAssignments_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsUncheckedCreateWithoutJobsInput = {
    id?: string
    caregiver_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replaced_by?: string | null
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutAssignmentsInput
  }

  export type assignmentsCreateOrConnectWithoutJobsInput = {
    where: assignmentsWhereUniqueInput
    create: XOR<assignmentsCreateWithoutJobsInput, assignmentsUncheckedCreateWithoutJobsInput>
  }

  export type assignmentsCreateManyJobsInputEnvelope = {
    data: assignmentsCreateManyJobsInput | assignmentsCreateManyJobsInput[]
    skipDuplicates?: boolean
  }

  export type care_logsCreateWithoutJobsInput = {
    id?: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
    patients: patientsCreateNestedOneWithoutCare_logsInput
    caregivers: caregiversCreateNestedOneWithoutCare_logsInput
    assignments?: assignmentsCreateNestedOneWithoutCare_logsInput
  }

  export type care_logsUncheckedCreateWithoutJobsInput = {
    id?: string
    assignment_id?: string | null
    caregiver_id: string
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type care_logsCreateOrConnectWithoutJobsInput = {
    where: care_logsWhereUniqueInput
    create: XOR<care_logsCreateWithoutJobsInput, care_logsUncheckedCreateWithoutJobsInput>
  }

  export type care_logsCreateManyJobsInputEnvelope = {
    data: care_logsCreateManyJobsInput | care_logsCreateManyJobsInput[]
    skipDuplicates?: boolean
  }

  export type disputesCreateWithoutJobsInput = {
    id?: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users_disputes_againstTousers: usersCreateNestedOneWithoutDisputes_disputes_againstTousersInput
    users_disputes_raised_byTousers: usersCreateNestedOneWithoutDisputes_disputes_raised_byTousersInput
  }

  export type disputesUncheckedCreateWithoutJobsInput = {
    id?: string
    raised_by: string
    against: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type disputesCreateOrConnectWithoutJobsInput = {
    where: disputesWhereUniqueInput
    create: XOR<disputesCreateWithoutJobsInput, disputesUncheckedCreateWithoutJobsInput>
  }

  export type disputesCreateManyJobsInputEnvelope = {
    data: disputesCreateManyJobsInput | disputesCreateManyJobsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutJobsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutJobsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutJobsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutJobsInput, usersUncheckedCreateWithoutJobsInput>
  }

  export type companiesCreateWithoutJobsInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCompaniesInput
    packages?: packagesCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutJobsInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversUncheckedCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCompaniesInput
    packages?: packagesUncheckedCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutJobsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutJobsInput, companiesUncheckedCreateWithoutJobsInput>
  }

  export type patientsCreateWithoutJobsInput = {
    id?: string
    user_id?: string | null
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsCreateNestedManyWithoutPatientsInput
    health_records?: health_recordsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutJobsInput = {
    id?: string
    user_id?: string | null
    guardian_id: string
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutPatientsInput
    health_records?: health_recordsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutJobsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutJobsInput, patientsUncheckedCreateWithoutJobsInput>
  }

  export type packagesCreateWithoutJobsInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
    companies: companiesCreateNestedOneWithoutPackagesInput
  }

  export type packagesUncheckedCreateWithoutJobsInput = {
    id?: string
    company_id: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type packagesCreateOrConnectWithoutJobsInput = {
    where: packagesWhereUniqueInput
    create: XOR<packagesCreateWithoutJobsInput, packagesUncheckedCreateWithoutJobsInput>
  }

  export type paymentsCreateWithoutJobsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    escrows?: escrowsCreateNestedOneWithoutPaymentsInput
    users: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutJobsInput = {
    id?: string
    payer_id: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    escrows?: escrowsUncheckedCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsCreateOrConnectWithoutJobsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutJobsInput, paymentsUncheckedCreateWithoutJobsInput>
  }

  export type paymentsCreateManyJobsInputEnvelope = {
    data: paymentsCreateManyJobsInput | paymentsCreateManyJobsInput[]
    skipDuplicates?: boolean
  }

  export type assignmentsUpsertWithWhereUniqueWithoutJobsInput = {
    where: assignmentsWhereUniqueInput
    update: XOR<assignmentsUpdateWithoutJobsInput, assignmentsUncheckedUpdateWithoutJobsInput>
    create: XOR<assignmentsCreateWithoutJobsInput, assignmentsUncheckedCreateWithoutJobsInput>
  }

  export type assignmentsUpdateWithWhereUniqueWithoutJobsInput = {
    where: assignmentsWhereUniqueInput
    data: XOR<assignmentsUpdateWithoutJobsInput, assignmentsUncheckedUpdateWithoutJobsInput>
  }

  export type assignmentsUpdateManyWithWhereWithoutJobsInput = {
    where: assignmentsScalarWhereInput
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyWithoutJobsInput>
  }

  export type care_logsUpsertWithWhereUniqueWithoutJobsInput = {
    where: care_logsWhereUniqueInput
    update: XOR<care_logsUpdateWithoutJobsInput, care_logsUncheckedUpdateWithoutJobsInput>
    create: XOR<care_logsCreateWithoutJobsInput, care_logsUncheckedCreateWithoutJobsInput>
  }

  export type care_logsUpdateWithWhereUniqueWithoutJobsInput = {
    where: care_logsWhereUniqueInput
    data: XOR<care_logsUpdateWithoutJobsInput, care_logsUncheckedUpdateWithoutJobsInput>
  }

  export type care_logsUpdateManyWithWhereWithoutJobsInput = {
    where: care_logsScalarWhereInput
    data: XOR<care_logsUpdateManyMutationInput, care_logsUncheckedUpdateManyWithoutJobsInput>
  }

  export type disputesUpsertWithWhereUniqueWithoutJobsInput = {
    where: disputesWhereUniqueInput
    update: XOR<disputesUpdateWithoutJobsInput, disputesUncheckedUpdateWithoutJobsInput>
    create: XOR<disputesCreateWithoutJobsInput, disputesUncheckedCreateWithoutJobsInput>
  }

  export type disputesUpdateWithWhereUniqueWithoutJobsInput = {
    where: disputesWhereUniqueInput
    data: XOR<disputesUpdateWithoutJobsInput, disputesUncheckedUpdateWithoutJobsInput>
  }

  export type disputesUpdateManyWithWhereWithoutJobsInput = {
    where: disputesScalarWhereInput
    data: XOR<disputesUpdateManyMutationInput, disputesUncheckedUpdateManyWithoutJobsInput>
  }

  export type disputesScalarWhereInput = {
    AND?: disputesScalarWhereInput | disputesScalarWhereInput[]
    OR?: disputesScalarWhereInput[]
    NOT?: disputesScalarWhereInput | disputesScalarWhereInput[]
    id?: StringFilter<"disputes"> | string
    job_id?: StringFilter<"disputes"> | string
    raised_by?: StringFilter<"disputes"> | string
    against?: StringFilter<"disputes"> | string
    dispute_type?: EnumDisputeTypeFilter<"disputes"> | $Enums.DisputeType
    description?: StringFilter<"disputes"> | string
    evidence_urls?: JsonNullableFilter<"disputes">
    status?: EnumDisputeStatusFilter<"disputes"> | $Enums.DisputeStatus
    assigned_moderator?: StringNullableFilter<"disputes"> | string | null
    resolution?: StringNullableFilter<"disputes"> | string | null
    resolution_action?: StringNullableFilter<"disputes"> | string | null
    resolved_at?: DateTimeNullableFilter<"disputes"> | Date | string | null
    createdAt?: DateTimeFilter<"disputes"> | Date | string
    updatedAt?: DateTimeFilter<"disputes"> | Date | string
  }

  export type usersUpsertWithoutJobsInput = {
    update: XOR<usersUpdateWithoutJobsInput, usersUncheckedUpdateWithoutJobsInput>
    create: XOR<usersCreateWithoutJobsInput, usersUncheckedCreateWithoutJobsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutJobsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutJobsInput, usersUncheckedUpdateWithoutJobsInput>
  }

  export type usersUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type companiesUpsertWithoutJobsInput = {
    update: XOR<companiesUpdateWithoutJobsInput, companiesUncheckedUpdateWithoutJobsInput>
    create: XOR<companiesCreateWithoutJobsInput, companiesUncheckedCreateWithoutJobsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutJobsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutJobsInput, companiesUncheckedUpdateWithoutJobsInput>
  }

  export type companiesUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUncheckedUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type patientsUpsertWithoutJobsInput = {
    update: XOR<patientsUpdateWithoutJobsInput, patientsUncheckedUpdateWithoutJobsInput>
    create: XOR<patientsCreateWithoutJobsInput, patientsUncheckedCreateWithoutJobsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutJobsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutJobsInput, patientsUncheckedUpdateWithoutJobsInput>
  }

  export type patientsUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUpdateManyWithoutPatientsNestedInput
    health_records?: health_recordsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutPatientsNestedInput
    health_records?: health_recordsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type packagesUpsertWithoutJobsInput = {
    update: XOR<packagesUpdateWithoutJobsInput, packagesUncheckedUpdateWithoutJobsInput>
    create: XOR<packagesCreateWithoutJobsInput, packagesUncheckedCreateWithoutJobsInput>
    where?: packagesWhereInput
  }

  export type packagesUpdateToOneWithWhereWithoutJobsInput = {
    where?: packagesWhereInput
    data: XOR<packagesUpdateWithoutJobsInput, packagesUncheckedUpdateWithoutJobsInput>
  }

  export type packagesUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpsertWithWhereUniqueWithoutJobsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutJobsInput, paymentsUncheckedUpdateWithoutJobsInput>
    create: XOR<paymentsCreateWithoutJobsInput, paymentsUncheckedCreateWithoutJobsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutJobsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutJobsInput, paymentsUncheckedUpdateWithoutJobsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutJobsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutJobsInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: StringFilter<"payments"> | string
    job_id?: StringNullableFilter<"payments"> | string | null
    payer_id?: StringFilter<"payments"> | string
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    transaction_id?: StringFilter<"payments"> | string
    status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    invoice_number?: StringFilter<"payments"> | string
    invoice_url?: StringNullableFilter<"payments"> | string | null
    receipt_url?: StringNullableFilter<"payments"> | string | null
    paid_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    refund_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    refund_reason?: StringNullableFilter<"payments"> | string | null
    gatewayResponse?: JsonNullableFilter<"payments">
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeFilter<"payments"> | Date | string
  }

  export type job_applicationsCreateWithoutMarketplace_jobsInput = {
    id?: string
    coverLetter?: string | null
    status?: string
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
    users?: usersCreateNestedOneWithoutJob_applicationsInput
    caregivers: caregiversCreateNestedOneWithoutJob_applicationsInput
  }

  export type job_applicationsUncheckedCreateWithoutMarketplace_jobsInput = {
    id?: string
    caregiver_id: string
    coverLetter?: string | null
    status?: string
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type job_applicationsCreateOrConnectWithoutMarketplace_jobsInput = {
    where: job_applicationsWhereUniqueInput
    create: XOR<job_applicationsCreateWithoutMarketplace_jobsInput, job_applicationsUncheckedCreateWithoutMarketplace_jobsInput>
  }

  export type job_applicationsCreateManyMarketplace_jobsInputEnvelope = {
    data: job_applicationsCreateManyMarketplace_jobsInput | job_applicationsCreateManyMarketplace_jobsInput[]
    skipDuplicates?: boolean
  }

  export type caregiversCreateWithoutMarketplace_jobsInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutCaregiversInput
    companies?: companiesCreateNestedOneWithoutCaregiversInput
    users: usersCreateNestedOneWithoutCaregiversInput
    job_applications?: job_applicationsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateWithoutMarketplace_jobsInput = {
    id?: string
    userId: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutCaregiversInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversCreateOrConnectWithoutMarketplace_jobsInput = {
    where: caregiversWhereUniqueInput
    create: XOR<caregiversCreateWithoutMarketplace_jobsInput, caregiversUncheckedCreateWithoutMarketplace_jobsInput>
  }

  export type companiesCreateWithoutMarketplace_jobsInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedManyWithoutCompaniesInput
    jobs?: jobsCreateNestedManyWithoutCompaniesInput
    packages?: packagesCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutMarketplace_jobsInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversUncheckedCreateNestedManyWithoutCompaniesInput
    jobs?: jobsUncheckedCreateNestedManyWithoutCompaniesInput
    packages?: packagesUncheckedCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutMarketplace_jobsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutMarketplace_jobsInput, companiesUncheckedCreateWithoutMarketplace_jobsInput>
  }

  export type job_applicationsUpsertWithWhereUniqueWithoutMarketplace_jobsInput = {
    where: job_applicationsWhereUniqueInput
    update: XOR<job_applicationsUpdateWithoutMarketplace_jobsInput, job_applicationsUncheckedUpdateWithoutMarketplace_jobsInput>
    create: XOR<job_applicationsCreateWithoutMarketplace_jobsInput, job_applicationsUncheckedCreateWithoutMarketplace_jobsInput>
  }

  export type job_applicationsUpdateWithWhereUniqueWithoutMarketplace_jobsInput = {
    where: job_applicationsWhereUniqueInput
    data: XOR<job_applicationsUpdateWithoutMarketplace_jobsInput, job_applicationsUncheckedUpdateWithoutMarketplace_jobsInput>
  }

  export type job_applicationsUpdateManyWithWhereWithoutMarketplace_jobsInput = {
    where: job_applicationsScalarWhereInput
    data: XOR<job_applicationsUpdateManyMutationInput, job_applicationsUncheckedUpdateManyWithoutMarketplace_jobsInput>
  }

  export type caregiversUpsertWithoutMarketplace_jobsInput = {
    update: XOR<caregiversUpdateWithoutMarketplace_jobsInput, caregiversUncheckedUpdateWithoutMarketplace_jobsInput>
    create: XOR<caregiversCreateWithoutMarketplace_jobsInput, caregiversUncheckedCreateWithoutMarketplace_jobsInput>
    where?: caregiversWhereInput
  }

  export type caregiversUpdateToOneWithWhereWithoutMarketplace_jobsInput = {
    where?: caregiversWhereInput
    data: XOR<caregiversUpdateWithoutMarketplace_jobsInput, caregiversUncheckedUpdateWithoutMarketplace_jobsInput>
  }

  export type caregiversUpdateWithoutMarketplace_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutCaregiversNestedInput
    companies?: companiesUpdateOneWithoutCaregiversNestedInput
    users?: usersUpdateOneRequiredWithoutCaregiversNestedInput
    job_applications?: job_applicationsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateWithoutMarketplace_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutCaregiversNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type companiesUpsertWithoutMarketplace_jobsInput = {
    update: XOR<companiesUpdateWithoutMarketplace_jobsInput, companiesUncheckedUpdateWithoutMarketplace_jobsInput>
    create: XOR<companiesCreateWithoutMarketplace_jobsInput, companiesUncheckedCreateWithoutMarketplace_jobsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutMarketplace_jobsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutMarketplace_jobsInput, companiesUncheckedUpdateWithoutMarketplace_jobsInput>
  }

  export type companiesUpdateWithoutMarketplace_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutMarketplace_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUncheckedUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type usersCreateWithoutNotificationsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type jobsCreateWithoutPackagesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutPackagesInput = {
    id?: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutPackagesInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutPackagesInput, jobsUncheckedCreateWithoutPackagesInput>
  }

  export type jobsCreateManyPackagesInputEnvelope = {
    data: jobsCreateManyPackagesInput | jobsCreateManyPackagesInput[]
    skipDuplicates?: boolean
  }

  export type companiesCreateWithoutPackagesInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedManyWithoutCompaniesInput
    jobs?: jobsCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutPackagesInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversUncheckedCreateNestedManyWithoutCompaniesInput
    jobs?: jobsUncheckedCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutPackagesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutPackagesInput, companiesUncheckedCreateWithoutPackagesInput>
  }

  export type jobsUpsertWithWhereUniqueWithoutPackagesInput = {
    where: jobsWhereUniqueInput
    update: XOR<jobsUpdateWithoutPackagesInput, jobsUncheckedUpdateWithoutPackagesInput>
    create: XOR<jobsCreateWithoutPackagesInput, jobsUncheckedCreateWithoutPackagesInput>
  }

  export type jobsUpdateWithWhereUniqueWithoutPackagesInput = {
    where: jobsWhereUniqueInput
    data: XOR<jobsUpdateWithoutPackagesInput, jobsUncheckedUpdateWithoutPackagesInput>
  }

  export type jobsUpdateManyWithWhereWithoutPackagesInput = {
    where: jobsScalarWhereInput
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyWithoutPackagesInput>
  }

  export type companiesUpsertWithoutPackagesInput = {
    update: XOR<companiesUpdateWithoutPackagesInput, companiesUncheckedUpdateWithoutPackagesInput>
    create: XOR<companiesCreateWithoutPackagesInput, companiesUncheckedCreateWithoutPackagesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutPackagesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutPackagesInput, companiesUncheckedUpdateWithoutPackagesInput>
  }

  export type companiesUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUncheckedUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type care_logsCreateWithoutPatientsInput = {
    id?: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
    caregivers: caregiversCreateNestedOneWithoutCare_logsInput
    assignments?: assignmentsCreateNestedOneWithoutCare_logsInput
    jobs: jobsCreateNestedOneWithoutCare_logsInput
  }

  export type care_logsUncheckedCreateWithoutPatientsInput = {
    id?: string
    job_id: string
    assignment_id?: string | null
    caregiver_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type care_logsCreateOrConnectWithoutPatientsInput = {
    where: care_logsWhereUniqueInput
    create: XOR<care_logsCreateWithoutPatientsInput, care_logsUncheckedCreateWithoutPatientsInput>
  }

  export type care_logsCreateManyPatientsInputEnvelope = {
    data: care_logsCreateManyPatientsInput | care_logsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type health_recordsCreateWithoutPatientsInput = {
    id?: string
    record_type: $Enums.HealthRecordType
    title: string
    description?: string | null
    file_url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: string | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    is_archived?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type health_recordsUncheckedCreateWithoutPatientsInput = {
    id?: string
    record_type: $Enums.HealthRecordType
    title: string
    description?: string | null
    file_url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: string | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    is_archived?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type health_recordsCreateOrConnectWithoutPatientsInput = {
    where: health_recordsWhereUniqueInput
    create: XOR<health_recordsCreateWithoutPatientsInput, health_recordsUncheckedCreateWithoutPatientsInput>
  }

  export type health_recordsCreateManyPatientsInputEnvelope = {
    data: health_recordsCreateManyPatientsInput | health_recordsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type jobsCreateWithoutPatientsInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutPatientsInput = {
    id?: string
    package_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutPatientsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutPatientsInput, jobsUncheckedCreateWithoutPatientsInput>
  }

  export type jobsCreateManyPatientsInputEnvelope = {
    data: jobsCreateManyPatientsInput | jobsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutPatientsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPatientsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPatientsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
  }

  export type care_logsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: care_logsWhereUniqueInput
    update: XOR<care_logsUpdateWithoutPatientsInput, care_logsUncheckedUpdateWithoutPatientsInput>
    create: XOR<care_logsCreateWithoutPatientsInput, care_logsUncheckedCreateWithoutPatientsInput>
  }

  export type care_logsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: care_logsWhereUniqueInput
    data: XOR<care_logsUpdateWithoutPatientsInput, care_logsUncheckedUpdateWithoutPatientsInput>
  }

  export type care_logsUpdateManyWithWhereWithoutPatientsInput = {
    where: care_logsScalarWhereInput
    data: XOR<care_logsUpdateManyMutationInput, care_logsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type health_recordsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: health_recordsWhereUniqueInput
    update: XOR<health_recordsUpdateWithoutPatientsInput, health_recordsUncheckedUpdateWithoutPatientsInput>
    create: XOR<health_recordsCreateWithoutPatientsInput, health_recordsUncheckedCreateWithoutPatientsInput>
  }

  export type health_recordsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: health_recordsWhereUniqueInput
    data: XOR<health_recordsUpdateWithoutPatientsInput, health_recordsUncheckedUpdateWithoutPatientsInput>
  }

  export type health_recordsUpdateManyWithWhereWithoutPatientsInput = {
    where: health_recordsScalarWhereInput
    data: XOR<health_recordsUpdateManyMutationInput, health_recordsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type health_recordsScalarWhereInput = {
    AND?: health_recordsScalarWhereInput | health_recordsScalarWhereInput[]
    OR?: health_recordsScalarWhereInput[]
    NOT?: health_recordsScalarWhereInput | health_recordsScalarWhereInput[]
    id?: StringFilter<"health_records"> | string
    patient_id?: StringFilter<"health_records"> | string
    record_type?: EnumHealthRecordTypeFilter<"health_records"> | $Enums.HealthRecordType
    title?: StringFilter<"health_records"> | string
    description?: StringNullableFilter<"health_records"> | string | null
    file_url?: StringNullableFilter<"health_records"> | string | null
    metadata?: JsonNullableFilter<"health_records">
    uploaded_by?: StringNullableFilter<"health_records"> | string | null
    valid_from?: DateTimeNullableFilter<"health_records"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"health_records"> | Date | string | null
    is_archived?: BoolFilter<"health_records"> | boolean
    created_at?: DateTimeFilter<"health_records"> | Date | string
    updated_at?: DateTimeFilter<"health_records"> | Date | string
  }

  export type jobsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: jobsWhereUniqueInput
    update: XOR<jobsUpdateWithoutPatientsInput, jobsUncheckedUpdateWithoutPatientsInput>
    create: XOR<jobsCreateWithoutPatientsInput, jobsUncheckedCreateWithoutPatientsInput>
  }

  export type jobsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: jobsWhereUniqueInput
    data: XOR<jobsUpdateWithoutPatientsInput, jobsUncheckedUpdateWithoutPatientsInput>
  }

  export type jobsUpdateManyWithWhereWithoutPatientsInput = {
    where: jobsScalarWhereInput
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type usersUpsertWithoutPatientsInput = {
    update: XOR<usersUpdateWithoutPatientsInput, usersUncheckedUpdateWithoutPatientsInput>
    create: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPatientsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPatientsInput, usersUncheckedUpdateWithoutPatientsInput>
  }

  export type usersUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type escrowsCreateWithoutPaymentsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrowsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    status?: string
    released_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrowsCreateOrConnectWithoutPaymentsInput = {
    where: escrowsWhereUniqueInput
    create: XOR<escrowsCreateWithoutPaymentsInput, escrowsUncheckedCreateWithoutPaymentsInput>
  }

  export type usersCreateWithoutPaymentsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPaymentsInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPaymentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
  }

  export type jobsCreateWithoutPaymentsInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    users: usersCreateNestedOneWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutPaymentsInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutPaymentsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutPaymentsInput, jobsUncheckedCreateWithoutPaymentsInput>
  }

  export type escrowsUpsertWithoutPaymentsInput = {
    update: XOR<escrowsUpdateWithoutPaymentsInput, escrowsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<escrowsCreateWithoutPaymentsInput, escrowsUncheckedCreateWithoutPaymentsInput>
    where?: escrowsWhereInput
  }

  export type escrowsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: escrowsWhereInput
    data: XOR<escrowsUpdateWithoutPaymentsInput, escrowsUncheckedUpdateWithoutPaymentsInput>
  }

  export type escrowsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrowsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    released_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutPaymentsInput = {
    update: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type jobsUpsertWithoutPaymentsInput = {
    update: XOR<jobsUpdateWithoutPaymentsInput, jobsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<jobsCreateWithoutPaymentsInput, jobsUncheckedCreateWithoutPaymentsInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutPaymentsInput, jobsUncheckedUpdateWithoutPaymentsInput>
  }

  export type jobsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type companiesCreateWithoutService_zonesInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedManyWithoutCompaniesInput
    jobs?: jobsCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCompaniesInput
    packages?: packagesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutService_zonesInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversUncheckedCreateNestedManyWithoutCompaniesInput
    jobs?: jobsUncheckedCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCompaniesInput
    packages?: packagesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutService_zonesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutService_zonesInput, companiesUncheckedCreateWithoutService_zonesInput>
  }

  export type companiesUpsertWithoutService_zonesInput = {
    update: XOR<companiesUpdateWithoutService_zonesInput, companiesUncheckedUpdateWithoutService_zonesInput>
    create: XOR<companiesCreateWithoutService_zonesInput, companiesUncheckedCreateWithoutService_zonesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutService_zonesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutService_zonesInput, companiesUncheckedUpdateWithoutService_zonesInput>
  }

  export type companiesUpdateWithoutService_zonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutService_zonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUncheckedUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type usersCreateWithoutUser_devicesInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_devicesInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    verification_codes?: verification_codesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_devicesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_devicesInput, usersUncheckedCreateWithoutUser_devicesInput>
  }

  export type usersUpsertWithoutUser_devicesInput = {
    update: XOR<usersUpdateWithoutUser_devicesInput, usersUncheckedUpdateWithoutUser_devicesInput>
    create: XOR<usersCreateWithoutUser_devicesInput, usersUncheckedCreateWithoutUser_devicesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_devicesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_devicesInput, usersUncheckedUpdateWithoutUser_devicesInput>
  }

  export type usersUpdateWithoutUser_devicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_devicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutVerification_codesInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    audit_logs?: audit_logsCreateNestedManyWithoutUsersInput
    caregivers?: caregiversCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsCreateNestedManyWithoutUsersInput
    jobs?: jobsCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVerification_codesInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    company_id?: string | null
    audit_logs?: audit_logsUncheckedCreateNestedManyWithoutUsersInput
    caregivers?: caregiversUncheckedCreateNestedOneWithoutUsersInput
    disputes_disputes_againstTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_againstTousersInput
    disputes_disputes_raised_byTousers?: disputesUncheckedCreateNestedManyWithoutUsers_disputes_raised_byTousersInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_to_user_idTousersInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedCreateNestedManyWithoutUsers_feedbacks_from_user_idTousersInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutUsersInput
    jobs?: jobsUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    user_devices?: user_devicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVerification_codesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVerification_codesInput, usersUncheckedCreateWithoutVerification_codesInput>
  }

  export type usersUpsertWithoutVerification_codesInput = {
    update: XOR<usersUpdateWithoutVerification_codesInput, usersUncheckedUpdateWithoutVerification_codesInput>
    create: XOR<usersCreateWithoutVerification_codesInput, usersUncheckedCreateWithoutVerification_codesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVerification_codesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVerification_codesInput, usersUncheckedUpdateWithoutVerification_codesInput>
  }

  export type usersUpdateWithoutVerification_codesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVerification_codesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type audit_logsCreateWithoutUsersInput = {
    id?: string
    actor_role?: string | null
    action_type: string
    entity_type: string
    entity_id: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string
  }

  export type audit_logsUncheckedCreateWithoutUsersInput = {
    id?: string
    actor_role?: string | null
    action_type: string
    entity_type: string
    entity_id: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string
  }

  export type audit_logsCreateOrConnectWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsCreateManyUsersInputEnvelope = {
    data: audit_logsCreateManyUsersInput | audit_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type caregiversCreateWithoutUsersInput = {
    id?: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsCreateNestedManyWithoutCaregiversInput
    companies?: companiesCreateNestedOneWithoutCaregiversInput
    job_applications?: job_applicationsCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversUncheckedCreateWithoutUsersInput = {
    id?: string
    company_id?: string | null
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_replaced_byTocaregiversInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedCreateNestedManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutCaregiversInput
    job_applications?: job_applicationsUncheckedCreateNestedManyWithoutCaregiversInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCaregiversInput
  }

  export type caregiversCreateOrConnectWithoutUsersInput = {
    where: caregiversWhereUniqueInput
    create: XOR<caregiversCreateWithoutUsersInput, caregiversUncheckedCreateWithoutUsersInput>
  }

  export type disputesCreateWithoutUsers_disputes_againstTousersInput = {
    id?: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users_disputes_raised_byTousers: usersCreateNestedOneWithoutDisputes_disputes_raised_byTousersInput
    jobs: jobsCreateNestedOneWithoutDisputesInput
  }

  export type disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput = {
    id?: string
    job_id: string
    raised_by: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type disputesCreateOrConnectWithoutUsers_disputes_againstTousersInput = {
    where: disputesWhereUniqueInput
    create: XOR<disputesCreateWithoutUsers_disputes_againstTousersInput, disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput>
  }

  export type disputesCreateManyUsers_disputes_againstTousersInputEnvelope = {
    data: disputesCreateManyUsers_disputes_againstTousersInput | disputesCreateManyUsers_disputes_againstTousersInput[]
    skipDuplicates?: boolean
  }

  export type disputesCreateWithoutUsers_disputes_raised_byTousersInput = {
    id?: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users_disputes_againstTousers: usersCreateNestedOneWithoutDisputes_disputes_againstTousersInput
    jobs: jobsCreateNestedOneWithoutDisputesInput
  }

  export type disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput = {
    id?: string
    job_id: string
    against: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type disputesCreateOrConnectWithoutUsers_disputes_raised_byTousersInput = {
    where: disputesWhereUniqueInput
    create: XOR<disputesCreateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput>
  }

  export type disputesCreateManyUsers_disputes_raised_byTousersInputEnvelope = {
    data: disputesCreateManyUsers_disputes_raised_byTousersInput | disputesCreateManyUsers_disputes_raised_byTousersInput[]
    skipDuplicates?: boolean
  }

  export type feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput = {
    id?: string
    job_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users_feedbacks_from_user_idTousers: usersCreateNestedOneWithoutFeedbacks_feedbacks_from_user_idTousersInput
  }

  export type feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput = {
    id?: string
    job_id: string
    from_user_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbacksCreateOrConnectWithoutUsers_feedbacks_to_user_idTousersInput = {
    where: feedbacksWhereUniqueInput
    create: XOR<feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput>
  }

  export type feedbacksCreateManyUsers_feedbacks_to_user_idTousersInputEnvelope = {
    data: feedbacksCreateManyUsers_feedbacks_to_user_idTousersInput | feedbacksCreateManyUsers_feedbacks_to_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput = {
    id?: string
    job_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users_feedbacks_to_user_idTousers: usersCreateNestedOneWithoutFeedbacks_feedbacks_to_user_idTousersInput
  }

  export type feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput = {
    id?: string
    job_id: string
    to_user_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbacksCreateOrConnectWithoutUsers_feedbacks_from_user_idTousersInput = {
    where: feedbacksWhereUniqueInput
    create: XOR<feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput>
  }

  export type feedbacksCreateManyUsers_feedbacks_from_user_idTousersInputEnvelope = {
    data: feedbacksCreateManyUsers_feedbacks_from_user_idTousersInput | feedbacksCreateManyUsers_feedbacks_from_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type job_applicationsCreateWithoutUsersInput = {
    id?: string
    coverLetter?: string | null
    status?: string
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
    caregivers: caregiversCreateNestedOneWithoutJob_applicationsInput
    marketplace_jobs: marketplace_jobsCreateNestedOneWithoutJob_applicationsInput
  }

  export type job_applicationsUncheckedCreateWithoutUsersInput = {
    id?: string
    marketplace_job_id: string
    caregiver_id: string
    coverLetter?: string | null
    status?: string
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type job_applicationsCreateOrConnectWithoutUsersInput = {
    where: job_applicationsWhereUniqueInput
    create: XOR<job_applicationsCreateWithoutUsersInput, job_applicationsUncheckedCreateWithoutUsersInput>
  }

  export type job_applicationsCreateManyUsersInputEnvelope = {
    data: job_applicationsCreateManyUsersInput | job_applicationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type jobsCreateWithoutUsersInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsCreateNestedManyWithoutJobsInput
    care_logs?: care_logsCreateNestedManyWithoutJobsInput
    disputes?: disputesCreateNestedManyWithoutJobsInput
    companies: companiesCreateNestedOneWithoutJobsInput
    patients: patientsCreateNestedOneWithoutJobsInput
    packages: packagesCreateNestedOneWithoutJobsInput
    payments?: paymentsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutUsersInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    assignments?: assignmentsUncheckedCreateNestedManyWithoutJobsInput
    care_logs?: care_logsUncheckedCreateNestedManyWithoutJobsInput
    disputes?: disputesUncheckedCreateNestedManyWithoutJobsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutUsersInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutUsersInput, jobsUncheckedCreateWithoutUsersInput>
  }

  export type jobsCreateManyUsersInputEnvelope = {
    data: jobsCreateManyUsersInput | jobsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsersInput = {
    id?: string
    type: $Enums.NotificationType
    channel: string
    title?: string | null
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    error_message?: string | null
    createdAt?: Date | string
  }

  export type notificationsUncheckedCreateWithoutUsersInput = {
    id?: string
    type: $Enums.NotificationType
    channel: string
    title?: string | null
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    error_message?: string | null
    createdAt?: Date | string
  }

  export type notificationsCreateOrConnectWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsCreateManyUsersInputEnvelope = {
    data: notificationsCreateManyUsersInput | notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type patientsCreateWithoutUsersInput = {
    id?: string
    user_id?: string | null
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsCreateNestedManyWithoutPatientsInput
    health_records?: health_recordsCreateNestedManyWithoutPatientsInput
    jobs?: jobsCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutUsersInput = {
    id?: string
    user_id?: string | null
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    care_logs?: care_logsUncheckedCreateNestedManyWithoutPatientsInput
    health_records?: health_recordsUncheckedCreateNestedManyWithoutPatientsInput
    jobs?: jobsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutUsersInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput>
  }

  export type patientsCreateManyUsersInputEnvelope = {
    data: patientsCreateManyUsersInput | patientsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutUsersInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    escrows?: escrowsCreateNestedOneWithoutPaymentsInput
    jobs?: jobsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutUsersInput = {
    id?: string
    job_id?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    escrows?: escrowsUncheckedCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsCreateOrConnectWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsCreateManyUsersInputEnvelope = {
    data: paymentsCreateManyUsersInput | paymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_devicesCreateWithoutUsersInput = {
    id?: string
    device_id: string
    fcm_token: string
    platform: string
    app_version?: string | null
    is_active?: boolean
    last_seen_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_devicesUncheckedCreateWithoutUsersInput = {
    id?: string
    device_id: string
    fcm_token: string
    platform: string
    app_version?: string | null
    is_active?: boolean
    last_seen_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_devicesCreateOrConnectWithoutUsersInput = {
    where: user_devicesWhereUniqueInput
    create: XOR<user_devicesCreateWithoutUsersInput, user_devicesUncheckedCreateWithoutUsersInput>
  }

  export type user_devicesCreateManyUsersInputEnvelope = {
    data: user_devicesCreateManyUsersInput | user_devicesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type verification_codesCreateWithoutUsersInput = {
    id?: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type verification_codesUncheckedCreateWithoutUsersInput = {
    id?: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type verification_codesCreateOrConnectWithoutUsersInput = {
    where: verification_codesWhereUniqueInput
    create: XOR<verification_codesCreateWithoutUsersInput, verification_codesUncheckedCreateWithoutUsersInput>
  }

  export type verification_codesCreateManyUsersInputEnvelope = {
    data: verification_codesCreateManyUsersInput | verification_codesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type companiesCreateWithoutUsersInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversCreateNestedManyWithoutCompaniesInput
    jobs?: jobsCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsCreateNestedManyWithoutCompaniesInput
    packages?: packagesCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutUsersInput = {
    id?: string
    userId: string
    company_name: string
    trade_license: string
    trade_license_url?: string | null
    tin?: string | null
    contact_person: string
    contact_phone: string
    contact_email?: string | null
    address: string
    logo_url?: string | null
    description?: string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method: $Enums.PayoutMethod
    payout_account: string
    commission_rate?: Decimal | DecimalJsLike | number | string
    subscription_tier?: $Enums.SubscriptionTier
    subscription_expires_at?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    caregivers?: caregiversUncheckedCreateNestedManyWithoutCompaniesInput
    jobs?: jobsUncheckedCreateNestedManyWithoutCompaniesInput
    marketplace_jobs?: marketplace_jobsUncheckedCreateNestedManyWithoutCompaniesInput
    packages?: packagesUncheckedCreateNestedManyWithoutCompaniesInput
    service_zones?: service_zonesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutUsersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    update: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<audit_logsCreateWithoutUsersInput, audit_logsUncheckedCreateWithoutUsersInput>
  }

  export type audit_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: audit_logsWhereUniqueInput
    data: XOR<audit_logsUpdateWithoutUsersInput, audit_logsUncheckedUpdateWithoutUsersInput>
  }

  export type audit_logsUpdateManyWithWhereWithoutUsersInput = {
    where: audit_logsScalarWhereInput
    data: XOR<audit_logsUpdateManyMutationInput, audit_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type audit_logsScalarWhereInput = {
    AND?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    OR?: audit_logsScalarWhereInput[]
    NOT?: audit_logsScalarWhereInput | audit_logsScalarWhereInput[]
    id?: StringFilter<"audit_logs"> | string
    actor_id?: StringNullableFilter<"audit_logs"> | string | null
    actor_role?: StringNullableFilter<"audit_logs"> | string | null
    action_type?: StringFilter<"audit_logs"> | string
    entity_type?: StringFilter<"audit_logs"> | string
    entity_id?: StringFilter<"audit_logs"> | string
    changes?: JsonNullableFilter<"audit_logs">
    ip_address?: StringNullableFilter<"audit_logs"> | string | null
    user_agent?: StringNullableFilter<"audit_logs"> | string | null
    timestamp?: DateTimeFilter<"audit_logs"> | Date | string
  }

  export type caregiversUpsertWithoutUsersInput = {
    update: XOR<caregiversUpdateWithoutUsersInput, caregiversUncheckedUpdateWithoutUsersInput>
    create: XOR<caregiversCreateWithoutUsersInput, caregiversUncheckedCreateWithoutUsersInput>
    where?: caregiversWhereInput
  }

  export type caregiversUpdateToOneWithWhereWithoutUsersInput = {
    where?: caregiversWhereInput
    data: XOR<caregiversUpdateWithoutUsersInput, caregiversUncheckedUpdateWithoutUsersInput>
  }

  export type caregiversUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutCaregiversNestedInput
    companies?: companiesUpdateOneWithoutCaregiversNestedInput
    job_applications?: job_applicationsUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: NullableStringFieldUpdateOperationsInput | string | null
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutCaregiversNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type disputesUpsertWithWhereUniqueWithoutUsers_disputes_againstTousersInput = {
    where: disputesWhereUniqueInput
    update: XOR<disputesUpdateWithoutUsers_disputes_againstTousersInput, disputesUncheckedUpdateWithoutUsers_disputes_againstTousersInput>
    create: XOR<disputesCreateWithoutUsers_disputes_againstTousersInput, disputesUncheckedCreateWithoutUsers_disputes_againstTousersInput>
  }

  export type disputesUpdateWithWhereUniqueWithoutUsers_disputes_againstTousersInput = {
    where: disputesWhereUniqueInput
    data: XOR<disputesUpdateWithoutUsers_disputes_againstTousersInput, disputesUncheckedUpdateWithoutUsers_disputes_againstTousersInput>
  }

  export type disputesUpdateManyWithWhereWithoutUsers_disputes_againstTousersInput = {
    where: disputesScalarWhereInput
    data: XOR<disputesUpdateManyMutationInput, disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersInput>
  }

  export type disputesUpsertWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput = {
    where: disputesWhereUniqueInput
    update: XOR<disputesUpdateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedUpdateWithoutUsers_disputes_raised_byTousersInput>
    create: XOR<disputesCreateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedCreateWithoutUsers_disputes_raised_byTousersInput>
  }

  export type disputesUpdateWithWhereUniqueWithoutUsers_disputes_raised_byTousersInput = {
    where: disputesWhereUniqueInput
    data: XOR<disputesUpdateWithoutUsers_disputes_raised_byTousersInput, disputesUncheckedUpdateWithoutUsers_disputes_raised_byTousersInput>
  }

  export type disputesUpdateManyWithWhereWithoutUsers_disputes_raised_byTousersInput = {
    where: disputesScalarWhereInput
    data: XOR<disputesUpdateManyMutationInput, disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersInput>
  }

  export type feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput = {
    where: feedbacksWhereUniqueInput
    update: XOR<feedbacksUpdateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedUpdateWithoutUsers_feedbacks_to_user_idTousersInput>
    create: XOR<feedbacksCreateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_to_user_idTousersInput>
  }

  export type feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_to_user_idTousersInput = {
    where: feedbacksWhereUniqueInput
    data: XOR<feedbacksUpdateWithoutUsers_feedbacks_to_user_idTousersInput, feedbacksUncheckedUpdateWithoutUsers_feedbacks_to_user_idTousersInput>
  }

  export type feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_to_user_idTousersInput = {
    where: feedbacksScalarWhereInput
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersInput>
  }

  export type feedbacksScalarWhereInput = {
    AND?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
    OR?: feedbacksScalarWhereInput[]
    NOT?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
    id?: StringFilter<"feedbacks"> | string
    job_id?: StringFilter<"feedbacks"> | string
    from_user_id?: StringFilter<"feedbacks"> | string
    to_user_id?: StringFilter<"feedbacks"> | string
    reviewee_type?: EnumFeedbackTypeFilter<"feedbacks"> | $Enums.FeedbackType
    rating?: IntFilter<"feedbacks"> | number
    tags?: JsonNullableFilter<"feedbacks">
    comments?: StringNullableFilter<"feedbacks"> | string | null
    is_public?: BoolFilter<"feedbacks"> | boolean
    company_response?: StringNullableFilter<"feedbacks"> | string | null
    responded_at?: DateTimeNullableFilter<"feedbacks"> | Date | string | null
    flagged_inappropriate?: BoolFilter<"feedbacks"> | boolean
    createdAt?: DateTimeFilter<"feedbacks"> | Date | string
    updatedAt?: DateTimeFilter<"feedbacks"> | Date | string
  }

  export type feedbacksUpsertWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput = {
    where: feedbacksWhereUniqueInput
    update: XOR<feedbacksUpdateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedUpdateWithoutUsers_feedbacks_from_user_idTousersInput>
    create: XOR<feedbacksCreateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedCreateWithoutUsers_feedbacks_from_user_idTousersInput>
  }

  export type feedbacksUpdateWithWhereUniqueWithoutUsers_feedbacks_from_user_idTousersInput = {
    where: feedbacksWhereUniqueInput
    data: XOR<feedbacksUpdateWithoutUsers_feedbacks_from_user_idTousersInput, feedbacksUncheckedUpdateWithoutUsers_feedbacks_from_user_idTousersInput>
  }

  export type feedbacksUpdateManyWithWhereWithoutUsers_feedbacks_from_user_idTousersInput = {
    where: feedbacksScalarWhereInput
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersInput>
  }

  export type job_applicationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: job_applicationsWhereUniqueInput
    update: XOR<job_applicationsUpdateWithoutUsersInput, job_applicationsUncheckedUpdateWithoutUsersInput>
    create: XOR<job_applicationsCreateWithoutUsersInput, job_applicationsUncheckedCreateWithoutUsersInput>
  }

  export type job_applicationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: job_applicationsWhereUniqueInput
    data: XOR<job_applicationsUpdateWithoutUsersInput, job_applicationsUncheckedUpdateWithoutUsersInput>
  }

  export type job_applicationsUpdateManyWithWhereWithoutUsersInput = {
    where: job_applicationsScalarWhereInput
    data: XOR<job_applicationsUpdateManyMutationInput, job_applicationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type jobsUpsertWithWhereUniqueWithoutUsersInput = {
    where: jobsWhereUniqueInput
    update: XOR<jobsUpdateWithoutUsersInput, jobsUncheckedUpdateWithoutUsersInput>
    create: XOR<jobsCreateWithoutUsersInput, jobsUncheckedCreateWithoutUsersInput>
  }

  export type jobsUpdateWithWhereUniqueWithoutUsersInput = {
    where: jobsWhereUniqueInput
    data: XOR<jobsUpdateWithoutUsersInput, jobsUncheckedUpdateWithoutUsersInput>
  }

  export type jobsUpdateManyWithWhereWithoutUsersInput = {
    where: jobsScalarWhereInput
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: StringFilter<"notifications"> | string
    userId?: StringFilter<"notifications"> | string
    type?: EnumNotificationTypeFilter<"notifications"> | $Enums.NotificationType
    channel?: StringFilter<"notifications"> | string
    title?: StringNullableFilter<"notifications"> | string | null
    body?: StringFilter<"notifications"> | string
    data?: JsonNullableFilter<"notifications">
    status?: EnumNotificationStatusFilter<"notifications"> | $Enums.NotificationStatus
    sent_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    delivered_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    error_message?: StringNullableFilter<"notifications"> | string | null
    createdAt?: DateTimeFilter<"notifications"> | Date | string
  }

  export type patientsUpsertWithWhereUniqueWithoutUsersInput = {
    where: patientsWhereUniqueInput
    update: XOR<patientsUpdateWithoutUsersInput, patientsUncheckedUpdateWithoutUsersInput>
    create: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput>
  }

  export type patientsUpdateWithWhereUniqueWithoutUsersInput = {
    where: patientsWhereUniqueInput
    data: XOR<patientsUpdateWithoutUsersInput, patientsUncheckedUpdateWithoutUsersInput>
  }

  export type patientsUpdateManyWithWhereWithoutUsersInput = {
    where: patientsScalarWhereInput
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyWithoutUsersInput>
  }

  export type patientsScalarWhereInput = {
    AND?: patientsScalarWhereInput | patientsScalarWhereInput[]
    OR?: patientsScalarWhereInput[]
    NOT?: patientsScalarWhereInput | patientsScalarWhereInput[]
    id?: StringFilter<"patients"> | string
    user_id?: StringNullableFilter<"patients"> | string | null
    guardian_id?: StringFilter<"patients"> | string
    name?: StringFilter<"patients"> | string
    date_of_birth?: DateTimeFilter<"patients"> | Date | string
    gender?: EnumGenderFilter<"patients"> | $Enums.Gender
    blood_group?: StringNullableFilter<"patients"> | string | null
    address?: StringFilter<"patients"> | string
    emergency_contact_name?: StringFilter<"patients"> | string
    emergency_contact_phone?: StringFilter<"patients"> | string
    primaryConditions?: JsonNullableFilter<"patients">
    allergies?: StringNullableFilter<"patients"> | string | null
    mobility_level?: EnumMobilityLevelFilter<"patients"> | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFilter<"patients"> | $Enums.CognitiveStatus
    photoUrl?: StringNullableFilter<"patients"> | string | null
    consent_data_sharing?: BoolFilter<"patients"> | boolean
    consent_marketing?: BoolFilter<"patients"> | boolean
    deletedAt?: DateTimeNullableFilter<"patients"> | Date | string | null
    createdAt?: DateTimeFilter<"patients"> | Date | string
    updatedAt?: DateTimeFilter<"patients"> | Date | string
  }

  export type paymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
  }

  export type paymentsUpdateManyWithWhereWithoutUsersInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_devicesUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_devicesWhereUniqueInput
    update: XOR<user_devicesUpdateWithoutUsersInput, user_devicesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_devicesCreateWithoutUsersInput, user_devicesUncheckedCreateWithoutUsersInput>
  }

  export type user_devicesUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_devicesWhereUniqueInput
    data: XOR<user_devicesUpdateWithoutUsersInput, user_devicesUncheckedUpdateWithoutUsersInput>
  }

  export type user_devicesUpdateManyWithWhereWithoutUsersInput = {
    where: user_devicesScalarWhereInput
    data: XOR<user_devicesUpdateManyMutationInput, user_devicesUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_devicesScalarWhereInput = {
    AND?: user_devicesScalarWhereInput | user_devicesScalarWhereInput[]
    OR?: user_devicesScalarWhereInput[]
    NOT?: user_devicesScalarWhereInput | user_devicesScalarWhereInput[]
    id?: StringFilter<"user_devices"> | string
    user_id?: StringFilter<"user_devices"> | string
    device_id?: StringFilter<"user_devices"> | string
    fcm_token?: StringFilter<"user_devices"> | string
    platform?: StringFilter<"user_devices"> | string
    app_version?: StringNullableFilter<"user_devices"> | string | null
    is_active?: BoolFilter<"user_devices"> | boolean
    last_seen_at?: DateTimeFilter<"user_devices"> | Date | string
    created_at?: DateTimeFilter<"user_devices"> | Date | string
    updated_at?: DateTimeFilter<"user_devices"> | Date | string
  }

  export type verification_codesUpsertWithWhereUniqueWithoutUsersInput = {
    where: verification_codesWhereUniqueInput
    update: XOR<verification_codesUpdateWithoutUsersInput, verification_codesUncheckedUpdateWithoutUsersInput>
    create: XOR<verification_codesCreateWithoutUsersInput, verification_codesUncheckedCreateWithoutUsersInput>
  }

  export type verification_codesUpdateWithWhereUniqueWithoutUsersInput = {
    where: verification_codesWhereUniqueInput
    data: XOR<verification_codesUpdateWithoutUsersInput, verification_codesUncheckedUpdateWithoutUsersInput>
  }

  export type verification_codesUpdateManyWithWhereWithoutUsersInput = {
    where: verification_codesScalarWhereInput
    data: XOR<verification_codesUpdateManyMutationInput, verification_codesUncheckedUpdateManyWithoutUsersInput>
  }

  export type verification_codesScalarWhereInput = {
    AND?: verification_codesScalarWhereInput | verification_codesScalarWhereInput[]
    OR?: verification_codesScalarWhereInput[]
    NOT?: verification_codesScalarWhereInput | verification_codesScalarWhereInput[]
    id?: StringFilter<"verification_codes"> | string
    userId?: StringFilter<"verification_codes"> | string
    code?: StringFilter<"verification_codes"> | string
    type?: StringFilter<"verification_codes"> | string
    expiresAt?: DateTimeFilter<"verification_codes"> | Date | string
    isUsed?: BoolFilter<"verification_codes"> | boolean
    usedAt?: DateTimeNullableFilter<"verification_codes"> | Date | string | null
    createdAt?: DateTimeFilter<"verification_codes"> | Date | string
    updatedAt?: DateTimeFilter<"verification_codes"> | Date | string
  }

  export type companiesUpsertWithoutUsersInput = {
    update: XOR<companiesUpdateWithoutUsersInput, companiesUncheckedUpdateWithoutUsersInput>
    create: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutUsersInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutUsersInput, companiesUncheckedUpdateWithoutUsersInput>
  }

  export type companiesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    trade_license?: StringFieldUpdateOperationsInput | string
    trade_license_url?: NullableStringFieldUpdateOperationsInput | string | null
    tin?: NullableStringFieldUpdateOperationsInput | string | null
    contact_person?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    specializations?: NullableJsonNullValueInput | InputJsonValue
    payout_method?: EnumPayoutMethodFieldUpdateOperationsInput | $Enums.PayoutMethod
    payout_account?: StringFieldUpdateOperationsInput | string
    commission_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subscription_tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscription_expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUncheckedUpdateManyWithoutCompaniesNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCompaniesNestedInput
    packages?: packagesUncheckedUpdateManyWithoutCompaniesNestedInput
    service_zones?: service_zonesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type care_logsCreateManyAssignmentsInput = {
    id?: string
    job_id: string
    caregiver_id: string
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type care_logsUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: patientsUpdateOneRequiredWithoutCare_logsNestedInput
    caregivers?: caregiversUpdateOneRequiredWithoutCare_logsNestedInput
    jobs?: jobsUpdateOneRequiredWithoutCare_logsNestedInput
  }

  export type care_logsUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsUncheckedUpdateManyWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentsCreateManyCaregivers_assignments_replaced_byTocaregiversInput = {
    id?: string
    job_id: string
    caregiver_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type assignmentsCreateManyCaregivers_assignments_caregiver_idTocaregiversInput = {
    id?: string
    job_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replaced_by?: string | null
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type care_logsCreateManyCaregiversInput = {
    id?: string
    job_id: string
    assignment_id?: string | null
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type job_applicationsCreateManyCaregiversInput = {
    id?: string
    marketplace_job_id: string
    coverLetter?: string | null
    status?: string
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type marketplace_jobsCreateManyCaregiversInput = {
    id?: string
    company_id: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type assignmentsUpdateWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers_assignments_caregiver_idTocaregivers?: caregiversUpdateOneRequiredWithoutAssignments_assignments_caregiver_idTocaregiversNestedInput
    jobs?: jobsUpdateOneRequiredWithoutAssignmentsNestedInput
    care_logs?: care_logsUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentsUpdateWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversUpdateOneWithoutAssignments_assignments_replaced_byTocaregiversNestedInput
    jobs?: jobsUpdateOneRequiredWithoutAssignmentsNestedInput
    care_logs?: care_logsUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replaced_by?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replaced_by?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: patientsUpdateOneRequiredWithoutCare_logsNestedInput
    assignments?: assignmentsUpdateOneWithoutCare_logsNestedInput
    jobs?: jobsUpdateOneRequiredWithoutCare_logsNestedInput
  }

  export type care_logsUncheckedUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsUncheckedUpdateManyWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutJob_applicationsNestedInput
    marketplace_jobs?: marketplace_jobsUpdateOneRequiredWithoutJob_applicationsNestedInput
  }

  export type job_applicationsUncheckedUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplace_job_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsUncheckedUpdateManyWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplace_job_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type marketplace_jobsUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_applications?: job_applicationsUpdateManyWithoutMarketplace_jobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutMarketplace_jobsNestedInput
  }

  export type marketplace_jobsUncheckedUpdateWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_applications?: job_applicationsUncheckedUpdateManyWithoutMarketplace_jobsNestedInput
  }

  export type marketplace_jobsUncheckedUpdateManyWithoutCaregiversInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type caregiversCreateManyCompaniesInput = {
    id?: string
    userId: string
    nid: string
    nid_url: string
    photo_url: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    address: string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    skills: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: Decimal | DecimalJsLike | number | string | null
    background_check_status?: $Enums.BackgroundCheckStatus
    background_check_date?: Date | string | null
    rating_avg?: Decimal | DecimalJsLike | number | string
    rating_count?: number
    total_jobs_completed?: number
    is_available?: boolean
    is_verified?: boolean
    verification_notes?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type jobsCreateManyCompaniesInput = {
    id?: string
    package_id: string
    patient_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type marketplace_jobsCreateManyCompaniesInput = {
    id?: string
    title: string
    description: string
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    start_date: Date | string
    duration_days: number
    hours_per_day: number
    offered_rate: Decimal | DecimalJsLike | number | string
    status?: string
    applications_count?: number
    filled_by?: string | null
    filled_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type packagesCreateManyCompaniesInput = {
    id?: string
    name: string
    description: string
    category: $Enums.PackageCategory
    price: Decimal | DecimalJsLike | number | string
    duration_days: number
    hours_per_day: number
    inclusions: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: number
    is_active?: boolean
    min_advance_days?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type service_zonesCreateManyCompaniesInput = {
    id?: string
    zone_name: string
    region_code: string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type usersCreateManyCompaniesInput = {
    id?: string
    role: $Enums.UserRole
    phone: string
    email?: string | null
    password_hash: string
    name: string
    language?: string
    kyc_status?: $Enums.KYCStatus
    kyc_document_url?: string | null
    mfa_enabled?: boolean
    mfa_secret?: string | null
    last_login_at?: Date | string | null
    is_active?: boolean
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type caregiversUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutCaregiversNestedInput
    users?: usersUpdateOneRequiredWithoutCaregiversNestedInput
    job_applications?: job_applicationsUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments_assignments_replaced_byTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_replaced_byTocaregiversNestedInput
    assignments_assignments_caregiver_idTocaregivers?: assignmentsUncheckedUpdateManyWithoutCaregivers_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutCaregiversNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutCaregiversNestedInput
    marketplace_jobs?: marketplace_jobsUncheckedUpdateManyWithoutCaregiversNestedInput
  }

  export type caregiversUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    nid?: StringFieldUpdateOperationsInput | string
    nid_url?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    address?: StringFieldUpdateOperationsInput | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    skills?: JsonNullValueInput | InputJsonValue
    certifications?: NullableJsonNullValueInput | InputJsonValue
    experience_years?: IntFieldUpdateOperationsInput | number
    languages?: JsonNullValueInput | InputJsonValue
    availabilityCalendar?: NullableJsonNullValueInput | InputJsonValue
    hourly_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    background_check_status?: EnumBackgroundCheckStatusFieldUpdateOperationsInput | $Enums.BackgroundCheckStatus
    background_check_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rating_avg?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rating_count?: IntFieldUpdateOperationsInput | number
    total_jobs_completed?: IntFieldUpdateOperationsInput | number
    is_available?: BoolFieldUpdateOperationsInput | boolean
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_notes?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type marketplace_jobsUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_applications?: job_applicationsUpdateManyWithoutMarketplace_jobsNestedInput
    caregivers?: caregiversUpdateOneWithoutMarketplace_jobsNestedInput
  }

  export type marketplace_jobsUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_by?: NullableStringFieldUpdateOperationsInput | string | null
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    job_applications?: job_applicationsUncheckedUpdateManyWithoutMarketplace_jobsNestedInput
  }

  export type marketplace_jobsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    offered_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    applications_count?: IntFieldUpdateOperationsInput | number
    filled_by?: NullableStringFieldUpdateOperationsInput | string | null
    filled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type packagesUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUpdateManyWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUncheckedUpdateManyWithoutPackagesNestedInput
  }

  export type packagesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumPackageCategoryFieldUpdateOperationsInput | $Enums.PackageCategory
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration_days?: IntFieldUpdateOperationsInput | number
    hours_per_day?: IntFieldUpdateOperationsInput | number
    inclusions?: JsonNullValueInput | InputJsonValue
    exclusions?: NullableJsonNullValueInput | InputJsonValue
    caregiver_count?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    min_advance_days?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_zonesUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone_name?: StringFieldUpdateOperationsInput | string
    region_code?: StringFieldUpdateOperationsInput | string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_zonesUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone_name?: StringFieldUpdateOperationsInput | string
    region_code?: StringFieldUpdateOperationsInput | string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type service_zonesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    zone_name?: StringFieldUpdateOperationsInput | string
    region_code?: StringFieldUpdateOperationsInput | string
    boundary_geojson?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUpdateManyWithoutUsersNestedInput
    jobs?: jobsUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    audit_logs?: audit_logsUncheckedUpdateManyWithoutUsersNestedInput
    caregivers?: caregiversUncheckedUpdateOneWithoutUsersNestedInput
    disputes_disputes_againstTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersNestedInput
    disputes_disputes_raised_byTousers?: disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersNestedInput
    feedbacks_feedbacks_to_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersNestedInput
    feedbacks_feedbacks_from_user_idTousers?: feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersNestedInput
    job_applications?: job_applicationsUncheckedUpdateManyWithoutUsersNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    user_devices?: user_devicesUncheckedUpdateManyWithoutUsersNestedInput
    verification_codes?: verification_codesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    kyc_status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    kyc_document_url?: NullableStringFieldUpdateOperationsInput | string | null
    mfa_enabled?: BoolFieldUpdateOperationsInput | boolean
    mfa_secret?: NullableStringFieldUpdateOperationsInput | string | null
    last_login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_ledgerCreateManyEscrow_recordsInput = {
    id?: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type escrow_ledgerUpdateWithoutEscrow_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_ledgerUncheckedUpdateWithoutEscrow_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escrow_ledgerUncheckedUpdateManyWithoutEscrow_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaction_logsCreateManyProvider_transactionsInput = {
    id?: string
    action: string
    previous_status?: string | null
    new_status: string
    note?: string | null
    created_at?: Date | string
  }

  export type transaction_logsUpdateWithoutProvider_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    previous_status?: NullableStringFieldUpdateOperationsInput | string | null
    new_status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaction_logsUncheckedUpdateWithoutProvider_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    previous_status?: NullableStringFieldUpdateOperationsInput | string | null
    new_status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaction_logsUncheckedUpdateManyWithoutProvider_transactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    previous_status?: NullableStringFieldUpdateOperationsInput | string | null
    new_status?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentsCreateManyJobsInput = {
    id?: string
    caregiver_id: string
    role?: $Enums.AssignmentRole
    shift_start_time: string
    shift_end_time: string
    days_of_week: JsonNullValueInput | InputJsonValue
    status?: $Enums.AssignmentStatus
    replaced_by?: string | null
    replacement_reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type care_logsCreateManyJobsInput = {
    id?: string
    assignment_id?: string | null
    caregiver_id: string
    patient_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type disputesCreateManyJobsInput = {
    id?: string
    raised_by: string
    against: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type paymentsCreateManyJobsInput = {
    id?: string
    payer_id: string
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type assignmentsUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers_assignments_replaced_byTocaregivers?: caregiversUpdateOneWithoutAssignments_assignments_replaced_byTocaregiversNestedInput
    caregivers_assignments_caregiver_idTocaregivers?: caregiversUpdateOneRequiredWithoutAssignments_assignments_caregiver_idTocaregiversNestedInput
    care_logs?: care_logsUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replaced_by?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateManyWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    role?: EnumAssignmentRoleFieldUpdateOperationsInput | $Enums.AssignmentRole
    shift_start_time?: StringFieldUpdateOperationsInput | string
    shift_end_time?: StringFieldUpdateOperationsInput | string
    days_of_week?: JsonNullValueInput | InputJsonValue
    status?: EnumAssignmentStatusFieldUpdateOperationsInput | $Enums.AssignmentStatus
    replaced_by?: NullableStringFieldUpdateOperationsInput | string | null
    replacement_reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: patientsUpdateOneRequiredWithoutCare_logsNestedInput
    caregivers?: caregiversUpdateOneRequiredWithoutCare_logsNestedInput
    assignments?: assignmentsUpdateOneWithoutCare_logsNestedInput
  }

  export type care_logsUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    caregiver_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsUncheckedUpdateManyWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    caregiver_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_disputes_againstTousers?: usersUpdateOneRequiredWithoutDisputes_disputes_againstTousersNestedInput
    users_disputes_raised_byTousers?: usersUpdateOneRequiredWithoutDisputes_disputes_raised_byTousersNestedInput
  }

  export type disputesUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    raised_by?: StringFieldUpdateOperationsInput | string
    against?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesUncheckedUpdateManyWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    raised_by?: StringFieldUpdateOperationsInput | string
    against?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    escrows?: escrowsUpdateOneWithoutPaymentsNestedInput
    users?: usersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payer_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    escrows?: escrowsUncheckedUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateManyWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payer_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsCreateManyMarketplace_jobsInput = {
    id?: string
    caregiver_id: string
    coverLetter?: string | null
    status?: string
    reviewed_by?: string | null
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type job_applicationsUpdateWithoutMarketplace_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutJob_applicationsNestedInput
    caregivers?: caregiversUpdateOneRequiredWithoutJob_applicationsNestedInput
  }

  export type job_applicationsUncheckedUpdateWithoutMarketplace_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsUncheckedUpdateManyWithoutMarketplace_jobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_by?: NullableStringFieldUpdateOperationsInput | string | null
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsCreateManyPackagesInput = {
    id?: string
    patient_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type jobsUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateManyWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsCreateManyPatientsInput = {
    id?: string
    job_id: string
    assignment_id?: string | null
    caregiver_id: string
    log_type: $Enums.CareLogType
    timestamp: Date | string
    location_lat?: Decimal | DecimalJsLike | number | string | null
    location_lng?: Decimal | DecimalJsLike | number | string | null
    data: JsonNullValueInput | InputJsonValue
    notes?: string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: boolean
    createdAt?: Date | string
  }

  export type health_recordsCreateManyPatientsInput = {
    id?: string
    record_type: $Enums.HealthRecordType
    title: string
    description?: string | null
    file_url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: string | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    is_archived?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type jobsCreateManyPatientsInput = {
    id?: string
    package_id: string
    company_id: string
    guardian_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type care_logsUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateOneRequiredWithoutCare_logsNestedInput
    assignments?: assignmentsUpdateOneWithoutCare_logsNestedInput
    jobs?: jobsUpdateOneRequiredWithoutCare_logsNestedInput
  }

  export type care_logsUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    caregiver_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type care_logsUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    assignment_id?: NullableStringFieldUpdateOperationsInput | string | null
    caregiver_id?: StringFieldUpdateOperationsInput | string
    log_type?: EnumCareLogTypeFieldUpdateOperationsInput | $Enums.CareLogType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    location_lat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location_lng?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    data?: JsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    photo_urls?: NullableJsonNullValueInput | InputJsonValue
    guardian_notified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type health_recordsUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    record_type?: EnumHealthRecordTypeFieldUpdateOperationsInput | $Enums.HealthRecordType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type health_recordsUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    record_type?: EnumHealthRecordTypeFieldUpdateOperationsInput | $Enums.HealthRecordType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type health_recordsUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    record_type?: EnumHealthRecordTypeFieldUpdateOperationsInput | $Enums.HealthRecordType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_archived?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    users?: usersUpdateOneRequiredWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    guardian_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsCreateManyUsersInput = {
    id?: string
    actor_role?: string | null
    action_type: string
    entity_type: string
    entity_id: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: string | null
    user_agent?: string | null
    timestamp?: Date | string
  }

  export type disputesCreateManyUsers_disputes_againstTousersInput = {
    id?: string
    job_id: string
    raised_by: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type disputesCreateManyUsers_disputes_raised_byTousersInput = {
    id?: string
    job_id: string
    against: string
    dispute_type: $Enums.DisputeType
    description: string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.DisputeStatus
    assigned_moderator?: string | null
    resolution?: string | null
    resolution_action?: string | null
    resolved_at?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbacksCreateManyUsers_feedbacks_to_user_idTousersInput = {
    id?: string
    job_id: string
    from_user_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type feedbacksCreateManyUsers_feedbacks_from_user_idTousersInput = {
    id?: string
    job_id: string
    to_user_id: string
    reviewee_type: $Enums.FeedbackType
    rating: number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    is_public?: boolean
    company_response?: string | null
    responded_at?: Date | string | null
    flagged_inappropriate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type job_applicationsCreateManyUsersInput = {
    id?: string
    marketplace_job_id: string
    caregiver_id: string
    coverLetter?: string | null
    status?: string
    reviewed_at?: Date | string | null
    review_notes?: string | null
    created_at?: Date | string
  }

  export type jobsCreateManyUsersInput = {
    id?: string
    package_id: string
    patient_id: string
    company_id: string
    start_date: Date | string
    end_date: Date | string
    status?: $Enums.JobStatus
    total_price: Decimal | DecimalJsLike | number | string
    commission_amount: Decimal | DecimalJsLike | number | string
    payout_amount: Decimal | DecimalJsLike | number | string
    special_instructions?: string | null
    completion_notes?: string | null
    cancelled_reason?: string | null
    cancelled_at?: Date | string | null
    cancelled_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type notificationsCreateManyUsersInput = {
    id?: string
    type: $Enums.NotificationType
    channel: string
    title?: string | null
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.NotificationStatus
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    error_message?: string | null
    createdAt?: Date | string
  }

  export type patientsCreateManyUsersInput = {
    id?: string
    user_id?: string | null
    name: string
    date_of_birth: Date | string
    gender: $Enums.Gender
    blood_group?: string | null
    address: string
    emergency_contact_name: string
    emergency_contact_phone: string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: string | null
    mobility_level?: $Enums.MobilityLevel
    cognitive_status?: $Enums.CognitiveStatus
    photoUrl?: string | null
    consent_data_sharing?: boolean
    consent_marketing?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type paymentsCreateManyUsersInput = {
    id?: string
    job_id?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: $Enums.PaymentMethod
    transaction_id: string
    status?: $Enums.PaymentStatus
    invoice_number: string
    invoice_url?: string | null
    receipt_url?: string | null
    paid_at?: Date | string | null
    refund_amount?: Decimal | DecimalJsLike | number | string | null
    refund_reason?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type user_devicesCreateManyUsersInput = {
    id?: string
    device_id: string
    fcm_token: string
    platform: string
    app_version?: string | null
    is_active?: boolean
    last_seen_at?: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type verification_codesCreateManyUsersInput = {
    id?: string
    code: string
    type: string
    expiresAt: Date | string
    isUsed?: boolean
    usedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type audit_logsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    actor_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    actor_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type audit_logsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    actor_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_type?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesUpdateWithoutUsers_disputes_againstTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_disputes_raised_byTousers?: usersUpdateOneRequiredWithoutDisputes_disputes_raised_byTousersNestedInput
    jobs?: jobsUpdateOneRequiredWithoutDisputesNestedInput
  }

  export type disputesUncheckedUpdateWithoutUsers_disputes_againstTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    raised_by?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesUncheckedUpdateManyWithoutUsers_disputes_againstTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    raised_by?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesUpdateWithoutUsers_disputes_raised_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_disputes_againstTousers?: usersUpdateOneRequiredWithoutDisputes_disputes_againstTousersNestedInput
    jobs?: jobsUpdateOneRequiredWithoutDisputesNestedInput
  }

  export type disputesUncheckedUpdateWithoutUsers_disputes_raised_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    against?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type disputesUncheckedUpdateManyWithoutUsers_disputes_raised_byTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    against?: StringFieldUpdateOperationsInput | string
    dispute_type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    description?: StringFieldUpdateOperationsInput | string
    evidence_urls?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    assigned_moderator?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolution_action?: NullableStringFieldUpdateOperationsInput | string | null
    resolved_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUpdateWithoutUsers_feedbacks_to_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_feedbacks_from_user_idTousers?: usersUpdateOneRequiredWithoutFeedbacks_feedbacks_from_user_idTousersNestedInput
  }

  export type feedbacksUncheckedUpdateWithoutUsers_feedbacks_to_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_to_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    from_user_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUpdateWithoutUsers_feedbacks_from_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_feedbacks_to_user_idTousers?: usersUpdateOneRequiredWithoutFeedbacks_feedbacks_to_user_idTousersNestedInput
  }

  export type feedbacksUncheckedUpdateWithoutUsers_feedbacks_from_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUncheckedUpdateManyWithoutUsers_feedbacks_from_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    to_user_id?: StringFieldUpdateOperationsInput | string
    reviewee_type?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    rating?: IntFieldUpdateOperationsInput | number
    tags?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    is_public?: BoolFieldUpdateOperationsInput | boolean
    company_response?: NullableStringFieldUpdateOperationsInput | string | null
    responded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged_inappropriate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    caregivers?: caregiversUpdateOneRequiredWithoutJob_applicationsNestedInput
    marketplace_jobs?: marketplace_jobsUpdateOneRequiredWithoutJob_applicationsNestedInput
  }

  export type job_applicationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplace_job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type job_applicationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketplace_job_id?: StringFieldUpdateOperationsInput | string
    caregiver_id?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUpdateManyWithoutJobsNestedInput
    disputes?: disputesUpdateManyWithoutJobsNestedInput
    companies?: companiesUpdateOneRequiredWithoutJobsNestedInput
    patients?: patientsUpdateOneRequiredWithoutJobsNestedInput
    packages?: packagesUpdateOneRequiredWithoutJobsNestedInput
    payments?: paymentsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: assignmentsUncheckedUpdateManyWithoutJobsNestedInput
    care_logs?: care_logsUncheckedUpdateManyWithoutJobsNestedInput
    disputes?: disputesUncheckedUpdateManyWithoutJobsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    package_id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    total_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    commission_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payout_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    special_instructions?: NullableStringFieldUpdateOperationsInput | string | null
    completion_notes?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    channel?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUpdateManyWithoutPatientsNestedInput
    health_records?: health_recordsUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    care_logs?: care_logsUncheckedUpdateManyWithoutPatientsNestedInput
    health_records?: health_recordsUncheckedUpdateManyWithoutPatientsNestedInput
    jobs?: jobsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    blood_group?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    emergency_contact_name?: StringFieldUpdateOperationsInput | string
    emergency_contact_phone?: StringFieldUpdateOperationsInput | string
    primaryConditions?: NullableJsonNullValueInput | InputJsonValue
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    mobility_level?: EnumMobilityLevelFieldUpdateOperationsInput | $Enums.MobilityLevel
    cognitive_status?: EnumCognitiveStatusFieldUpdateOperationsInput | $Enums.CognitiveStatus
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    consent_data_sharing?: BoolFieldUpdateOperationsInput | boolean
    consent_marketing?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    escrows?: escrowsUpdateOneWithoutPaymentsNestedInput
    jobs?: jobsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    escrows?: escrowsUncheckedUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    invoice_number?: StringFieldUpdateOperationsInput | string
    invoice_url?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    refund_reason?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    fcm_token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    app_version?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    last_seen_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    fcm_token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    app_version?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    last_seen_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_devicesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    device_id?: StringFieldUpdateOperationsInput | string
    fcm_token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    app_version?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    last_seen_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_codesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_codesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_codesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}